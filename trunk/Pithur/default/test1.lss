
test1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000a90  00800200  00003958  000039ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003958  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007d9  00800c90  00800c90  0000447c  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  0000447c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a08  00000000  00000000  0000453c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000436d  00000000  00000000  00004f44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d76  00000000  00000000  000092b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003bce  00000000  00000000  0000a027  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000740  00000000  00000000  0000dbf8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001ab1  00000000  00000000  0000e338  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002229  00000000  00000000  0000fde9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000208  00000000  00000000  00012012  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__ctors_end>
       4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      20:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      2c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      3c:	0c 94 b3 04 	jmp	0x966	; 0x966 <__vector_15>
      40:	0c 94 e6 04 	jmp	0x9cc	; 0x9cc <__vector_16>
      44:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      48:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      4c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      50:	0c 94 9c 04 	jmp	0x938	; 0x938 <__vector_20>
      54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      60:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      64:	0c 94 4a 01 	jmp	0x294	; 0x294 <__vector_25>
      68:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      6c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      70:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      74:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      78:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      7c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      80:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      84:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      88:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      8c:	0c 94 bd 04 	jmp	0x97a	; 0x97a <__vector_35>
      90:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      94:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      98:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      9c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      a0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      a4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      a8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      ac:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      b0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      b4:	0c 94 c7 04 	jmp	0x98e	; 0x98e <__vector_45>
      b8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      bc:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      c0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      c4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      c8:	0c 94 dc 04 	jmp	0x9b8	; 0x9b8 <__vector_50>

000000cc <__ctors_end>:
      cc:	11 24       	eor	r1, r1
      ce:	1f be       	out	0x3f, r1	; 63
      d0:	cf ef       	ldi	r28, 0xFF	; 255
      d2:	d1 e2       	ldi	r29, 0x21	; 33
      d4:	de bf       	out	0x3e, r29	; 62
      d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
      d8:	1c e0       	ldi	r17, 0x0C	; 12
      da:	a0 e0       	ldi	r26, 0x00	; 0
      dc:	b2 e0       	ldi	r27, 0x02	; 2
      de:	e8 e5       	ldi	r30, 0x58	; 88
      e0:	f9 e3       	ldi	r31, 0x39	; 57
      e2:	00 e0       	ldi	r16, 0x00	; 0
      e4:	0b bf       	out	0x3b, r16	; 59
      e6:	02 c0       	rjmp	.+4      	; 0xec <__do_copy_data+0x14>
      e8:	07 90       	elpm	r0, Z+
      ea:	0d 92       	st	X+, r0
      ec:	a0 39       	cpi	r26, 0x90	; 144
      ee:	b1 07       	cpc	r27, r17
      f0:	d9 f7       	brne	.-10     	; 0xe8 <__do_copy_data+0x10>

000000f2 <__do_clear_bss>:
      f2:	14 e1       	ldi	r17, 0x14	; 20
      f4:	a0 e9       	ldi	r26, 0x90	; 144
      f6:	bc e0       	ldi	r27, 0x0C	; 12
      f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>

000000fa <.do_clear_bss_loop>:
      fa:	1d 92       	st	X+, r1

000000fc <.do_clear_bss_start>:
      fc:	a9 36       	cpi	r26, 0x69	; 105
      fe:	b1 07       	cpc	r27, r17
     100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
     102:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <main>
     106:	0c 94 aa 1c 	jmp	0x3954	; 0x3954 <_exit>

0000010a <__bad_interrupt>:
     10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <com_init>:
 *  \param[in] rate Baudrate used by the AVR's USART.
 */
void com_init( baud_rate_t rate ){
  
    //Initialize USART module.
    UBRR0H = 0x00;
     10e:	10 92 c5 00 	sts	0x00C5, r1
    UBRR0L = rate;
     112:	80 93 c4 00 	sts	0x00C4, r24
  
    //Enable USART transmitter module. Always on.
    ENABLE_RECEIVER;
     116:	a1 ec       	ldi	r26, 0xC1	; 193
     118:	b0 e0       	ldi	r27, 0x00	; 0
     11a:	8c 91       	ld	r24, X
     11c:	80 61       	ori	r24, 0x10	; 16
     11e:	8c 93       	st	X, r24
    ENABLE_TRANSMITTER;
     120:	8c 91       	ld	r24, X
     122:	88 60       	ori	r24, 0x08	; 8
     124:	8c 93       	st	X, r24
	
    //8-N-1.
    UCSR0C |= ( 1 << UCSZ01 ) | ( 1 << UCSZ00 ); 
     126:	e2 ec       	ldi	r30, 0xC2	; 194
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	80 81       	ld	r24, Z
     12c:	86 60       	ori	r24, 0x06	; 6
     12e:	80 83       	st	Z, r24
  
    com_number_of_received_bytes = 0;
     130:	10 92 06 0d 	sts	0x0D06, r1
    com_data_reception_finished = false;
     134:	10 92 07 0d 	sts	0x0D07, r1
    ENABLE_RECEIVE_COMPLETE_INTERRUPT;
     138:	8c 91       	ld	r24, X
     13a:	80 68       	ori	r24, 0x80	; 128
     13c:	8c 93       	st	X, r24

}
     13e:	08 95       	ret

00000140 <com_send_string>:
/*! \brief This function sends data on the chosen communication interface (USB or USART).
 *  
 *  \param[in] data Pointer to data that is to be sent on the communication interface.
 *  \param[in] data_length Number of bytes to read from the array pointed to by data.
 */
void com_send_string( uint8_t *data, uint8_t data_length ){
     140:	fc 01       	movw	r30, r24
     142:	07 c0       	rjmp	.+14     	; 0x152 <com_send_string+0x12>
    
    while (--data_length > 0) {
        
        for(; !(UCSR0A & (1 << UDRE0));) {;}
     144:	80 91 c0 00 	lds	r24, 0x00C0
     148:	85 ff       	sbrs	r24, 5
     14a:	fc cf       	rjmp	.-8      	; 0x144 <com_send_string+0x4>
  	    UDR0 = *data++; //Put symbol in data register.
     14c:	81 91       	ld	r24, Z+
     14e:	80 93 c6 00 	sts	0x00C6, r24
 *  \param[in] data Pointer to data that is to be sent on the communication interface.
 *  \param[in] data_length Number of bytes to read from the array pointed to by data.
 */
void com_send_string( uint8_t *data, uint8_t data_length ){
    
    while (--data_length > 0) {
     152:	61 50       	subi	r22, 0x01	; 1
     154:	b9 f7       	brne	.-18     	; 0x144 <com_send_string+0x4>
        
        for(; !(UCSR0A & (1 << UDRE0));) {;}
  	    UDR0 = *data++; //Put symbol in data register.
    
    }    
}
     156:	08 95       	ret

00000158 <comPrintString>:

void comPrintString(char *data)
{
     158:	fc 01       	movw	r30, r24
     15a:	07 c0       	rjmp	.+14     	; 0x16a <comPrintString+0x12>
	
	while (*data!='\0')
	{    
        for(; !(UCSR0A & (1 << UDRE0));) {;}
     15c:	80 91 c0 00 	lds	r24, 0x00C0
     160:	85 ff       	sbrs	r24, 5
     162:	fc cf       	rjmp	.-8      	; 0x15c <comPrintString+0x4>
  	    UDR0 = *data++; //Put symbol in data register.
     164:	90 93 c6 00 	sts	0x00C6, r25
     168:	31 96       	adiw	r30, 0x01	; 1
}

void comPrintString(char *data)
{
	
	while (*data!='\0')
     16a:	90 81       	ld	r25, Z
     16c:	99 23       	and	r25, r25
     16e:	b1 f7       	brne	.-20     	; 0x15c <comPrintString+0x4>
	{    
        for(; !(UCSR0A & (1 << UDRE0));) {;}
  	    UDR0 = *data++; //Put symbol in data register.
    }    
}
     170:	08 95       	ret

00000172 <com_send_hex>:

/*! \brief This function prints the supplied argument as a hex number.
 *  
 *  \param[in] nmbr Number to be printed as a hexadescimal number.
 */
void com_send_hex( uint8_t nmbr ){
     172:	98 2f       	mov	r25, r24

        for(; !(UCSR0A & (1 << UDRE0));) {;}
     174:	80 91 c0 00 	lds	r24, 0x00C0
     178:	85 ff       	sbrs	r24, 5
     17a:	fc cf       	rjmp	.-8      	; 0x174 <com_send_hex+0x2>
  	    UDR0 = '0'; //Put symbol in data register.
     17c:	80 e3       	ldi	r24, 0x30	; 48
     17e:	80 93 c6 00 	sts	0x00C6, r24
    
        for(; !(UCSR0A & (1 << UDRE0));) {;}
     182:	80 91 c0 00 	lds	r24, 0x00C0
     186:	85 ff       	sbrs	r24, 5
     188:	fc cf       	rjmp	.-8      	; 0x182 <com_send_hex+0x10>
  	    UDR0 = 'x'; //Put symbol in data register.
     18a:	88 e7       	ldi	r24, 0x78	; 120
     18c:	80 93 c6 00 	sts	0x00C6, r24
        
        for(; !(UCSR0A & (1 << UDRE0));) {;}
     190:	80 91 c0 00 	lds	r24, 0x00C0
     194:	85 ff       	sbrs	r24, 5
     196:	fc cf       	rjmp	.-8      	; 0x190 <com_send_hex+0x1e>
  	    UDR0 = hex_lookup[ ( nmbr >> 4 ) & 0x0F ];
     198:	e9 2f       	mov	r30, r25
     19a:	e2 95       	swap	r30
     19c:	ef 70       	andi	r30, 0x0F	; 15
     19e:	f0 e0       	ldi	r31, 0x00	; 0
     1a0:	e0 50       	subi	r30, 0x00	; 0
     1a2:	fe 4f       	sbci	r31, 0xFE	; 254
     1a4:	80 81       	ld	r24, Z
     1a6:	80 93 c6 00 	sts	0x00C6, r24
        
        for(; !(UCSR0A & (1 << UDRE0));) {;}
     1aa:	80 91 c0 00 	lds	r24, 0x00C0
     1ae:	85 ff       	sbrs	r24, 5
     1b0:	fc cf       	rjmp	.-8      	; 0x1aa <com_send_hex+0x38>
  	    UDR0 = hex_lookup[ ( nmbr & 0x0F ) ];
     1b2:	e9 2f       	mov	r30, r25
     1b4:	f0 e0       	ldi	r31, 0x00	; 0
     1b6:	ef 70       	andi	r30, 0x0F	; 15
     1b8:	f0 70       	andi	r31, 0x00	; 0
     1ba:	e0 50       	subi	r30, 0x00	; 0
     1bc:	fe 4f       	sbci	r31, 0xFE	; 254
     1be:	80 81       	ld	r24, Z
     1c0:	80 93 c6 00 	sts	0x00C6, r24
}
     1c4:	08 95       	ret

000001c6 <com_send_char>:

void com_send_char( uint8_t nmbr )
{
     1c6:	98 2f       	mov	r25, r24
	for(; !(UCSR0A & (1 << UDRE0));) {;}
     1c8:	80 91 c0 00 	lds	r24, 0x00C0
     1cc:	85 ff       	sbrs	r24, 5
     1ce:	fc cf       	rjmp	.-8      	; 0x1c8 <com_send_char+0x2>
	UDR0 =nmbr; //Put symbol in data register.
     1d0:	90 93 c6 00 	sts	0x00C6, r25
}
     1d4:	08 95       	ret

000001d6 <com_send_dec>:

void com_send_dec(uint8_t numbr)
{
     1d6:	28 2f       	mov	r18, r24
  	    UDR0 = hex_lookup[ ( nmbr & 0x0F ) ];
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
     1d8:	80 91 c0 00 	lds	r24, 0x00C0
     1dc:	85 ff       	sbrs	r24, 5
     1de:	fc cf       	rjmp	.-8      	; 0x1d8 <com_send_dec+0x2>

void com_send_dec(uint8_t numbr)
{
	uint8_t tmp=0;
	
	tmp=(numbr/100)+0x30;
     1e0:	82 2f       	mov	r24, r18
     1e2:	64 e6       	ldi	r22, 0x64	; 100
     1e4:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
     1e8:	80 5d       	subi	r24, 0xD0	; 208
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
	UDR0 =nmbr; //Put symbol in data register.
     1ea:	80 93 c6 00 	sts	0x00C6, r24
  	    UDR0 = hex_lookup[ ( nmbr & 0x0F ) ];
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
     1ee:	80 91 c0 00 	lds	r24, 0x00C0
     1f2:	85 ff       	sbrs	r24, 5
     1f4:	fc cf       	rjmp	.-8      	; 0x1ee <com_send_dec+0x18>
	uint8_t tmp=0;
	
	tmp=(numbr/100)+0x30;
	com_send_char(tmp);

	tmp=(numbr%100)/10+0x30;
     1f6:	82 2f       	mov	r24, r18
     1f8:	64 e6       	ldi	r22, 0x64	; 100
     1fa:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
     1fe:	89 2f       	mov	r24, r25
     200:	6a e0       	ldi	r22, 0x0A	; 10
     202:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
     206:	80 5d       	subi	r24, 0xD0	; 208
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
	UDR0 =nmbr; //Put symbol in data register.
     208:	80 93 c6 00 	sts	0x00C6, r24
  	    UDR0 = hex_lookup[ ( nmbr & 0x0F ) ];
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
     20c:	80 91 c0 00 	lds	r24, 0x00C0
     210:	85 ff       	sbrs	r24, 5
     212:	fc cf       	rjmp	.-8      	; 0x20c <com_send_dec+0x36>
	com_send_char(tmp);

	tmp=(numbr%100)/10+0x30;
	com_send_char(tmp);

	tmp=(numbr%10)+0x30;
     214:	82 2f       	mov	r24, r18
     216:	6a e0       	ldi	r22, 0x0A	; 10
     218:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
     21c:	90 5d       	subi	r25, 0xD0	; 208
}

void com_send_char( uint8_t nmbr )
{
	for(; !(UCSR0A & (1 << UDRE0));) {;}
	UDR0 =nmbr; //Put symbol in data register.
     21e:	90 93 c6 00 	sts	0x00C6, r25
	com_send_char(tmp);

	tmp=(numbr%10)+0x30;
	com_send_char(tmp);

}
     222:	08 95       	ret

00000224 <com_get_received_data>:
 *  \return Pointer to the first byte in the array of received data.
 */
uint8_t * com_get_received_data( void )
{
    return &com_buffer[0];
}
     224:	80 e9       	ldi	r24, 0x90	; 144
     226:	9c e0       	ldi	r25, 0x0C	; 12
     228:	08 95       	ret

0000022a <com_get_received_data_use>:
void com_get_received_data_use(uint8_t useful[] )
{
     22a:	ac 01       	movw	r20, r24
     22c:	20 e0       	ldi	r18, 0x00	; 0
     22e:	30 e0       	ldi	r19, 0x00	; 0
    int i;
	for(i=0;i<=20;i++)
	useful[i]=com_buffer[i];
     230:	fa 01       	movw	r30, r20
     232:	e2 0f       	add	r30, r18
     234:	f3 1f       	adc	r31, r19
     236:	d9 01       	movw	r26, r18
     238:	a0 57       	subi	r26, 0x70	; 112
     23a:	b3 4f       	sbci	r27, 0xF3	; 243
     23c:	8c 91       	ld	r24, X
     23e:	80 83       	st	Z, r24
    return &com_buffer[0];
}
void com_get_received_data_use(uint8_t useful[] )
{
    int i;
	for(i=0;i<=20;i++)
     240:	2f 5f       	subi	r18, 0xFF	; 255
     242:	3f 4f       	sbci	r19, 0xFF	; 255
     244:	25 31       	cpi	r18, 0x15	; 21
     246:	31 05       	cpc	r19, r1
     248:	99 f7       	brne	.-26     	; 0x230 <com_get_received_data_use+0x6>
	useful[i]=com_buffer[i];
}
     24a:	08 95       	ret

0000024c <com_get_number_of_received_bytes>:
 *  \retval 1 Error: Typed Frame Too Long.
 *  \return Any non zero value returned indicatest that data is available and should be read.
 */
uint8_t com_get_number_of_received_bytes( void ){
    
    if (com_data_reception_finished == true) {
     24c:	80 91 07 0d 	lds	r24, 0x0D07
     250:	88 23       	and	r24, r24
     252:	11 f0       	breq	.+4      	; 0x258 <com_get_number_of_received_bytes+0xc>
        return com_number_of_received_bytes; 
     254:	80 91 06 0d 	lds	r24, 0x0D06
    } else { return 0; }
}
     258:	08 95       	ret

0000025a <com_reset_receiver>:
 *         data reception is done, and the end-user has read data.
 *  
 */
void com_reset_receiver( void ){
    int i;
    DISABLE_RECEIVE_COMPLETE_INTERRUPT;
     25a:	80 91 c1 00 	lds	r24, 0x00C1
     25e:	8f 77       	andi	r24, 0x7F	; 127
     260:	80 93 c1 00 	sts	0x00C1, r24
    
    com_number_of_received_bytes = 0;
     264:	10 92 06 0d 	sts	0x0D06, r1
    com_data_reception_finished = false;
     268:	10 92 07 0d 	sts	0x0D07, r1
     26c:	02 c0       	rjmp	.+4      	; 0x272 <com_reset_receiver+0x18>
    uint8_t dummy = 0;
    //Following loop is used to ensure that the rx FIFO is flushed.
	//Sometimes it gets cloged up with old data.
	for( ;  UCSR0A & ( 1 << RXC0 ); )
	{
		dummy = UDR0;  
     26e:	80 91 c6 00 	lds	r24, 0x00C6
    com_data_reception_finished = false;
    
    uint8_t dummy = 0;
    //Following loop is used to ensure that the rx FIFO is flushed.
	//Sometimes it gets cloged up with old data.
	for( ;  UCSR0A & ( 1 << RXC0 ); )
     272:	80 91 c0 00 	lds	r24, 0x00C0
     276:	87 fd       	sbrc	r24, 7
     278:	fa cf       	rjmp	.-12     	; 0x26e <com_reset_receiver+0x14>
     27a:	e0 e9       	ldi	r30, 0x90	; 144
     27c:	fc e0       	ldi	r31, 0x0C	; 12
	{
		dummy = UDR0;  
	}
    for(i=0;i<=20;i++)//改过
    	com_buffer[i]=0x00;	
     27e:	11 92       	st	Z+, r1
	//Sometimes it gets cloged up with old data.
	for( ;  UCSR0A & ( 1 << RXC0 ); )
	{
		dummy = UDR0;  
	}
    for(i=0;i<=20;i++)//改过
     280:	8c e0       	ldi	r24, 0x0C	; 12
     282:	e5 3a       	cpi	r30, 0xA5	; 165
     284:	f8 07       	cpc	r31, r24
     286:	d9 f7       	brne	.-10     	; 0x27e <com_reset_receiver+0x24>
    	com_buffer[i]=0x00;	
	ENABLE_RECEIVE_COMPLETE_INTERRUPT;
     288:	80 91 c1 00 	lds	r24, 0x00C1
     28c:	80 68       	ori	r24, 0x80	; 128
     28e:	80 93 c1 00 	sts	0x00C1, r24
}
     292:	08 95       	ret

00000294 <__vector_25>:
 *  terminated when the EOT character is detected ('\n'). The serial interface will be
 *  stoped and the since the com_data_reception_finished flag set to true.
 *  The routine appends two characters at 
 */
ISR( USART0_RX_vect )
{
     294:	1f 92       	push	r1
     296:	0f 92       	push	r0
     298:	0f b6       	in	r0, 0x3f	; 63
     29a:	0f 92       	push	r0
     29c:	0b b6       	in	r0, 0x3b	; 59
     29e:	0f 92       	push	r0
     2a0:	11 24       	eor	r1, r1
     2a2:	2f 93       	push	r18
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	ef 93       	push	r30
     2ae:	ff 93       	push	r31
	
  	uint8_t receivedData;
	
	receivedData = ( uint8_t )UDR0;	//Collect data.
     2b0:	90 91 c6 00 	lds	r25, 0x00C6
	
    if (com_number_of_received_bytes < COM_RX_MAX_BYTES) 
     2b4:	80 91 06 0d 	lds	r24, 0x0D06
     2b8:	84 37       	cpi	r24, 0x74	; 116
     2ba:	28 f5       	brcc	.+74     	; 0x306 <__vector_25+0x72>
     2bc:	a8 2f       	mov	r26, r24
     2be:	b0 e0       	ldi	r27, 0x00	; 0
     2c0:	28 2f       	mov	r18, r24
     2c2:	2f 5f       	subi	r18, 0xFF	; 255
	{
        
        //End of data stream.
        if (receivedData == '\n') 
     2c4:	9a 30       	cpi	r25, 0x0A	; 10
     2c6:	c9 f4       	brne	.+50     	; 0x2fa <__vector_25+0x66>
		{            
	        DISABLE_RECEIVE_COMPLETE_INTERRUPT;
     2c8:	80 91 c1 00 	lds	r24, 0x00C1
     2cc:	8f 77       	andi	r24, 0x7F	; 127
     2ce:	80 93 c1 00 	sts	0x00C1, r24
            com_buffer[com_number_of_received_bytes++] = receivedData;
     2d2:	a0 57       	subi	r26, 0x70	; 112
     2d4:	b3 4f       	sbci	r27, 0xF3	; 243
     2d6:	9c 93       	st	X, r25
            com_buffer[com_number_of_received_bytes++] = 0x00;
     2d8:	e2 2f       	mov	r30, r18
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	e0 57       	subi	r30, 0x70	; 112
     2de:	f3 4f       	sbci	r31, 0xF3	; 243
     2e0:	10 82       	st	Z, r1
     2e2:	82 2f       	mov	r24, r18
     2e4:	8f 5f       	subi	r24, 0xFF	; 255
            com_buffer[com_number_of_received_bytes++] = 0x00;
     2e6:	e8 2f       	mov	r30, r24
     2e8:	f0 e0       	ldi	r31, 0x00	; 0
     2ea:	e0 57       	subi	r30, 0x70	; 112
     2ec:	f3 4f       	sbci	r31, 0xF3	; 243
     2ee:	10 82       	st	Z, r1
     2f0:	8f 5f       	subi	r24, 0xFF	; 255
     2f2:	80 93 06 0d 	sts	0x0D06, r24
            
            com_data_reception_finished = true;
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	0e c0       	rjmp	.+28     	; 0x316 <__vector_25+0x82>
        } 
		else 
		{
            com_buffer[com_number_of_received_bytes++] = receivedData;
     2fa:	a0 57       	subi	r26, 0x70	; 112
     2fc:	b3 4f       	sbci	r27, 0xF3	; 243
     2fe:	9c 93       	st	X, r25
     300:	20 93 06 0d 	sts	0x0D06, r18
     304:	0a c0       	rjmp	.+20     	; 0x31a <__vector_25+0x86>
        }
    }
    
    else
	{        
        DISABLE_RECEIVE_COMPLETE_INTERRUPT;
     306:	80 91 c1 00 	lds	r24, 0x00C1
     30a:	8f 77       	andi	r24, 0x7F	; 127
     30c:	80 93 c1 00 	sts	0x00C1, r24
        com_number_of_received_bytes = 1;
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	80 93 06 0d 	sts	0x0D06, r24
        com_data_reception_finished = true;
     316:	80 93 07 0d 	sts	0x0D07, r24
    }
}
     31a:	ff 91       	pop	r31
     31c:	ef 91       	pop	r30
     31e:	bf 91       	pop	r27
     320:	af 91       	pop	r26
     322:	9f 91       	pop	r25
     324:	8f 91       	pop	r24
     326:	2f 91       	pop	r18
     328:	0f 90       	pop	r0
     32a:	0b be       	out	0x3b, r0	; 59
     32c:	0f 90       	pop	r0
     32e:	0f be       	out	0x3f, r0	; 63
     330:	0f 90       	pop	r0
     332:	1f 90       	pop	r1
     334:	18 95       	reti

00000336 <hal_init>:
/*! \brief  This function initializes the Hardware Abstraction Layer.
 *
 *  \ingroup hal_avr_api
 */
retval_t  hal_init( void )
{
     336:	df 93       	push	r29
     338:	cf 93       	push	r28
     33a:	0f 92       	push	r0
     33c:	cd b7       	in	r28, 0x3d	; 61
     33e:	de b7       	in	r29, 0x3e	; 62
    
	/*Reset variables used in file.*/
	hal_system_time = 0;
     340:	10 92 09 0d 	sts	0x0D09, r1
     344:	10 92 08 0d 	sts	0x0D08, r1
 *
 *  \ingroup hal_avr_api
 */
void hal_reset_flags( void ){
    
    AVR_ENTER_CRITICAL_REGION( );
     348:	8f b7       	in	r24, 0x3f	; 63
     34a:	89 83       	std	Y+1, r24	; 0x01
     34c:	f8 94       	cli
    
    //Reset Flags.
    hal_bat_low_flag     = 0;
     34e:	10 92 0b 0d 	sts	0x0D0B, r1
    hal_trx_ur_flag      = 0;
     352:	10 92 0c 0d 	sts	0x0D0C, r1
    hal_trx_end_flag     = 0;
     356:	10 92 0d 0d 	sts	0x0D0D, r1
    hal_rx_start_flag    = 0;  
     35a:	10 92 0e 0d 	sts	0x0D0E, r1
    hal_unknown_isr_flag = 0;
     35e:	10 92 0f 0d 	sts	0x0D0F, r1
    hal_pll_unlock_flag  = 0;
     362:	10 92 10 0d 	sts	0x0D10, r1
    hal_pll_lock_flag    = 0;
     366:	10 92 11 0d 	sts	0x0D11, r1
    
    //Reset Associated Event Handlers.
    rx_start_callback = NULL;
     36a:	10 92 13 0d 	sts	0x0D13, r1
     36e:	10 92 12 0d 	sts	0x0D12, r1
    trx_end_callback  = NULL;
     372:	10 92 15 0d 	sts	0x0D15, r1
     376:	10 92 14 0d 	sts	0x0D14, r1
    
    AVR_LEAVE_CRITICAL_REGION( )
     37a:	89 81       	ldd	r24, Y+1	; 0x01
     37c:	8f bf       	out	0x3f, r24	; 63
	/*Reset variables used in file.*/
	hal_system_time = 0;
	hal_reset_flags( );

	/*IO Specific Initialization.*/
	DDR_SLP_TR |= (1 << SLP_TR); //Enable SLP_TR as output.
     37e:	24 9a       	sbi	0x04, 4	; 4
	DDR_RST    |= (1 << RST);    //Enable RST as output.
     380:	25 9a       	sbi	0x04, 5	; 4
	HAL_DDR_DATA_LED |= (1 << DATA_LED);
     382:	26 9a       	sbi	0x04, 6	; 4
	HAL_DDR_NET_LED |= (1<< NET_LED);
     384:	57 9a       	sbi	0x0a, 7	; 10

	/*SPI Specific Initialization.*/    
	//Set SS, CLK and MOSI as output.
	HAL_DDR_SPI  |= (1 << HAL_DD_SS) | (1 << HAL_DD_SCK) | (1 << HAL_DD_MOSI);
     386:	84 b1       	in	r24, 0x04	; 4
     388:	87 60       	ori	r24, 0x07	; 7
     38a:	84 b9       	out	0x04, r24	; 4
	HAL_PORT_SPI |= (1 << HAL_DD_SS) | (1 << HAL_DD_SCK); //Set SS and CLK high
     38c:	85 b1       	in	r24, 0x05	; 5
     38e:	83 60       	ori	r24, 0x03	; 3
     390:	85 b9       	out	0x05, r24	; 5
	SPCR         = (1 << SPE) | (1 << MSTR); //Enable SPI module and master operation.
     392:	80 e5       	ldi	r24, 0x50	; 80
     394:	8c bd       	out	0x2c, r24	; 44
	SPSR         = (1 << SPI2X); //Enable doubled SPI speed in master mode.
     396:	81 e0       	ldi	r24, 0x01	; 1
     398:	8d bd       	out	0x2d, r24	; 45

	/*TIMER1 Specific Initialization.*/    
	TCCR1B = HAL_TCCR1B_CONFIG;       //Set clock prescaler  
     39a:	83 e4       	ldi	r24, 0x43	; 67
     39c:	80 93 81 00 	sts	0x0081, r24
	TIFR1 |= (1 << ICF1);             //Clear Input Capture Flag.
     3a0:	b5 9a       	sbi	0x16, 5	; 22
	HAL_ENABLE_OVERFLOW_INTERRUPT( ); //Enable Timer1 overflow interrupt. 
     3a2:	ef e6       	ldi	r30, 0x6F	; 111
     3a4:	f0 e0       	ldi	r31, 0x00	; 0
     3a6:	80 81       	ld	r24, Z
     3a8:	81 60       	ori	r24, 0x01	; 1
     3aa:	80 83       	st	Z, r24
	hal_enable_trx_interrupt( );    //Enable interrupts from the radio transceiver.
     3ac:	80 81       	ld	r24, Z
     3ae:	80 62       	ori	r24, 0x20	; 32
     3b0:	80 83       	st	Z, r24
	return SUCCESS;
}
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	0f 90       	pop	r0
     3b6:	cf 91       	pop	r28
     3b8:	df 91       	pop	r29
     3ba:	08 95       	ret

000003bc <Timer4_disable>:

void Timer4_disable(void)
{
	power_timer4_disable() ;
     3bc:	e5 e6       	ldi	r30, 0x65	; 101
     3be:	f0 e0       	ldi	r31, 0x00	; 0
     3c0:	80 81       	ld	r24, Z
     3c2:	80 61       	ori	r24, 0x10	; 16
     3c4:	80 83       	st	Z, r24
}
     3c6:	08 95       	ret

000003c8 <Timer4_init>:

void Timer4_init(void)//风扇转速计数器:1S
{
	power_timer4_enable() ;
     3c8:	e5 e6       	ldi	r30, 0x65	; 101
     3ca:	f0 e0       	ldi	r31, 0x00	; 0
     3cc:	80 81       	ld	r24, Z
     3ce:	8f 7e       	andi	r24, 0xEF	; 239
     3d0:	80 83       	st	Z, r24
	TCCR4A=0x00;
     3d2:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B=0X05;
     3d6:	85 e0       	ldi	r24, 0x05	; 5
     3d8:	80 93 a1 00 	sts	0x00A1, r24

	TCNT4L=0xe0;   //1S  1024
     3dc:	80 ee       	ldi	r24, 0xE0	; 224
     3de:	80 93 a4 00 	sts	0x00A4, r24
	TCNT4H=0xe3;
     3e2:	83 ee       	ldi	r24, 0xE3	; 227
     3e4:	80 93 a5 00 	sts	0x00A5, r24

	TIMSK4=0x01;
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	80 93 72 00 	sts	0x0072, r24
	SREG|=BIT(7);
     3ee:	8f b7       	in	r24, 0x3f	; 63
     3f0:	80 68       	ori	r24, 0x80	; 128
     3f2:	8f bf       	out	0x3f, r24	; 63
}
     3f4:	08 95       	ret

000003f6 <get_timer4_flag>:

bool get_timer4_flag(void)
{
	return (timer4_flag);
}
     3f6:	80 91 0a 0d 	lds	r24, 0x0D0A
     3fa:	08 95       	ret

000003fc <clear_timer4_flag>:

void clear_timer4_flag(void)
{
	timer4_flag = false;
     3fc:	10 92 0a 0d 	sts	0x0D0A, r1
}
     400:	08 95       	ret

00000402 <hal_reset_flags>:
/*! \brief  This function reset the interrupt flags and interrupt event handlers 
 *          (Callbacks) to their default value.
 *
 *  \ingroup hal_avr_api
 */
void hal_reset_flags( void ){
     402:	df 93       	push	r29
     404:	cf 93       	push	r28
     406:	0f 92       	push	r0
     408:	cd b7       	in	r28, 0x3d	; 61
     40a:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     40c:	8f b7       	in	r24, 0x3f	; 63
     40e:	89 83       	std	Y+1, r24	; 0x01
     410:	f8 94       	cli
    
    //Reset Flags.
    hal_bat_low_flag     = 0;
     412:	10 92 0b 0d 	sts	0x0D0B, r1
    hal_trx_ur_flag      = 0;
     416:	10 92 0c 0d 	sts	0x0D0C, r1
    hal_trx_end_flag     = 0;
     41a:	10 92 0d 0d 	sts	0x0D0D, r1
    hal_rx_start_flag    = 0;  
     41e:	10 92 0e 0d 	sts	0x0D0E, r1
    hal_unknown_isr_flag = 0;
     422:	10 92 0f 0d 	sts	0x0D0F, r1
    hal_pll_unlock_flag  = 0;
     426:	10 92 10 0d 	sts	0x0D10, r1
    hal_pll_lock_flag    = 0;
     42a:	10 92 11 0d 	sts	0x0D11, r1
    
    //Reset Associated Event Handlers.
    rx_start_callback = NULL;
     42e:	10 92 13 0d 	sts	0x0D13, r1
     432:	10 92 12 0d 	sts	0x0D12, r1
    trx_end_callback  = NULL;
     436:	10 92 15 0d 	sts	0x0D15, r1
     43a:	10 92 14 0d 	sts	0x0D14, r1
    
    AVR_LEAVE_CRITICAL_REGION( )
     43e:	89 81       	ldd	r24, Y+1	; 0x01
     440:	8f bf       	out	0x3f, r24	; 63
}
     442:	0f 90       	pop	r0
     444:	cf 91       	pop	r28
     446:	df 91       	pop	r29
     448:	08 95       	ret

0000044a <hal_get_bat_low_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_bat_low_flag( void ){
    return hal_bat_low_flag;
     44a:	80 91 0b 0d 	lds	r24, 0x0D0B
}
     44e:	08 95       	ret

00000450 <hal_clear_bat_low_flag>:

/*! \brief  This function clears the BAT_LOW flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_bat_low_flag( void ){
     450:	df 93       	push	r29
     452:	cf 93       	push	r28
     454:	0f 92       	push	r0
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     45a:	8f b7       	in	r24, 0x3f	; 63
     45c:	89 83       	std	Y+1, r24	; 0x01
     45e:	f8 94       	cli
    hal_bat_low_flag = 0;
     460:	10 92 0b 0d 	sts	0x0D0B, r1
    AVR_LEAVE_CRITICAL_REGION( );
     464:	89 81       	ldd	r24, Y+1	; 0x01
     466:	8f bf       	out	0x3f, r24	; 63
}
     468:	0f 90       	pop	r0
     46a:	cf 91       	pop	r28
     46c:	df 91       	pop	r29
     46e:	08 95       	ret

00000470 <hal_get_trx_ur_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_trx_ur_flag( void ){
    return hal_trx_ur_flag;
     470:	80 91 0c 0d 	lds	r24, 0x0D0C
}
     474:	08 95       	ret

00000476 <hal_clear_trx_ur_flag>:

/*! \brief  This function clears the TRX_UR flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_trx_ur_flag( void ){
     476:	df 93       	push	r29
     478:	cf 93       	push	r28
     47a:	0f 92       	push	r0
     47c:	cd b7       	in	r28, 0x3d	; 61
     47e:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     480:	8f b7       	in	r24, 0x3f	; 63
     482:	89 83       	std	Y+1, r24	; 0x01
     484:	f8 94       	cli
    hal_trx_ur_flag = 0;
     486:	10 92 0c 0d 	sts	0x0D0C, r1
    AVR_LEAVE_CRITICAL_REGION( );
     48a:	89 81       	ldd	r24, Y+1	; 0x01
     48c:	8f bf       	out	0x3f, r24	; 63
}
     48e:	0f 90       	pop	r0
     490:	cf 91       	pop	r28
     492:	df 91       	pop	r29
     494:	08 95       	ret

00000496 <hal_get_trx_end_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_trx_end_flag( void ){
    return hal_trx_end_flag;
     496:	80 91 0d 0d 	lds	r24, 0x0D0D
}
     49a:	08 95       	ret

0000049c <hal_clear_trx_end_flag>:

/*! \brief  This function clears the TRX_END flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_trx_end_flag( void ){
     49c:	df 93       	push	r29
     49e:	cf 93       	push	r28
     4a0:	0f 92       	push	r0
     4a2:	cd b7       	in	r28, 0x3d	; 61
     4a4:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     4a6:	8f b7       	in	r24, 0x3f	; 63
     4a8:	89 83       	std	Y+1, r24	; 0x01
     4aa:	f8 94       	cli
    hal_trx_end_flag = 0;
     4ac:	10 92 0d 0d 	sts	0x0D0D, r1
    AVR_LEAVE_CRITICAL_REGION( );
     4b0:	89 81       	ldd	r24, Y+1	; 0x01
     4b2:	8f bf       	out	0x3f, r24	; 63
}
     4b4:	0f 90       	pop	r0
     4b6:	cf 91       	pop	r28
     4b8:	df 91       	pop	r29
     4ba:	08 95       	ret

000004bc <hal_get_trx_end_event_handler>:
 *
 *  \ingroup hal_avr_api
 */
hal_trx_end_isr_event_handler_t hal_get_trx_end_event_handler( void ){
    return trx_end_callback;
}
     4bc:	80 91 14 0d 	lds	r24, 0x0D14
     4c0:	90 91 15 0d 	lds	r25, 0x0D15
     4c4:	08 95       	ret

000004c6 <hal_set_trx_end_event_handler>:
/*! \brief  This function is used to set new TRX_END event handler, overriding 
 *          old handler reference.
 *
 *  \ingroup hal_avr_api
 */
void hal_set_trx_end_event_handler( hal_trx_end_isr_event_handler_t trx_end_callback_handle ){
     4c6:	df 93       	push	r29
     4c8:	cf 93       	push	r28
     4ca:	0f 92       	push	r0
     4cc:	cd b7       	in	r28, 0x3d	; 61
     4ce:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     4d0:	2f b7       	in	r18, 0x3f	; 63
     4d2:	29 83       	std	Y+1, r18	; 0x01
     4d4:	f8 94       	cli
    trx_end_callback = trx_end_callback_handle;
     4d6:	90 93 15 0d 	sts	0x0D15, r25
     4da:	80 93 14 0d 	sts	0x0D14, r24
    AVR_LEAVE_CRITICAL_REGION( );
     4de:	89 81       	ldd	r24, Y+1	; 0x01
     4e0:	8f bf       	out	0x3f, r24	; 63
}
     4e2:	0f 90       	pop	r0
     4e4:	cf 91       	pop	r28
     4e6:	df 91       	pop	r29
     4e8:	08 95       	ret

000004ea <hal_clear_trx_end_event_handler>:

/*! \brief  Remove event handler reference.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_trx_end_event_handler( void ){
     4ea:	df 93       	push	r29
     4ec:	cf 93       	push	r28
     4ee:	0f 92       	push	r0
     4f0:	cd b7       	in	r28, 0x3d	; 61
     4f2:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     4f4:	8f b7       	in	r24, 0x3f	; 63
     4f6:	89 83       	std	Y+1, r24	; 0x01
     4f8:	f8 94       	cli
    trx_end_callback = NULL;
     4fa:	10 92 15 0d 	sts	0x0D15, r1
     4fe:	10 92 14 0d 	sts	0x0D14, r1
    AVR_LEAVE_CRITICAL_REGION( );
     502:	89 81       	ldd	r24, Y+1	; 0x01
     504:	8f bf       	out	0x3f, r24	; 63
}
     506:	0f 90       	pop	r0
     508:	cf 91       	pop	r28
     50a:	df 91       	pop	r29
     50c:	08 95       	ret

0000050e <hal_get_rx_start_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_rx_start_flag( void ){
    return hal_rx_start_flag;
     50e:	80 91 0e 0d 	lds	r24, 0x0D0E
}
     512:	08 95       	ret

00000514 <hal_clear_rx_start_flag>:

/*! \brief  This function clears the RX_START flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_rx_start_flag( void ){
     514:	df 93       	push	r29
     516:	cf 93       	push	r28
     518:	0f 92       	push	r0
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     51e:	8f b7       	in	r24, 0x3f	; 63
     520:	89 83       	std	Y+1, r24	; 0x01
     522:	f8 94       	cli
    hal_rx_start_flag = 0;
     524:	10 92 0e 0d 	sts	0x0D0E, r1
    AVR_LEAVE_CRITICAL_REGION( );
     528:	89 81       	ldd	r24, Y+1	; 0x01
     52a:	8f bf       	out	0x3f, r24	; 63
}
     52c:	0f 90       	pop	r0
     52e:	cf 91       	pop	r28
     530:	df 91       	pop	r29
     532:	08 95       	ret

00000534 <hal_get_rx_start_event_handler>:
 *  \return Current RX_START event handler registered.
 *  \ingroup hal_avr_api
 */
hal_rx_start_isr_event_handler_t hal_get_rx_start_event_handler( void ){
    return rx_start_callback;    
}
     534:	80 91 12 0d 	lds	r24, 0x0D12
     538:	90 91 13 0d 	lds	r25, 0x0D13
     53c:	08 95       	ret

0000053e <hal_set_rx_start_event_handler>:
/*! \brief  This function is used to set new RX_START event handler, overriding 
 *          old handler reference.
 *
 *  \ingroup hal_avr_api
 */
void hal_set_rx_start_event_handler( hal_rx_start_isr_event_handler_t rx_start_callback_handle ){
     53e:	df 93       	push	r29
     540:	cf 93       	push	r28
     542:	0f 92       	push	r0
     544:	cd b7       	in	r28, 0x3d	; 61
     546:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     548:	2f b7       	in	r18, 0x3f	; 63
     54a:	29 83       	std	Y+1, r18	; 0x01
     54c:	f8 94       	cli
    rx_start_callback = rx_start_callback_handle;
     54e:	90 93 13 0d 	sts	0x0D13, r25
     552:	80 93 12 0d 	sts	0x0D12, r24
    AVR_LEAVE_CRITICAL_REGION( );
     556:	89 81       	ldd	r24, Y+1	; 0x01
     558:	8f bf       	out	0x3f, r24	; 63
}
     55a:	0f 90       	pop	r0
     55c:	cf 91       	pop	r28
     55e:	df 91       	pop	r29
     560:	08 95       	ret

00000562 <hal_clear_rx_start_event_handler>:

/*! \brief  Remove event handler reference.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_rx_start_event_handler( void ){
     562:	df 93       	push	r29
     564:	cf 93       	push	r28
     566:	0f 92       	push	r0
     568:	cd b7       	in	r28, 0x3d	; 61
     56a:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     56c:	8f b7       	in	r24, 0x3f	; 63
     56e:	89 83       	std	Y+1, r24	; 0x01
     570:	f8 94       	cli
    rx_start_callback = NULL;
     572:	10 92 13 0d 	sts	0x0D13, r1
     576:	10 92 12 0d 	sts	0x0D12, r1
    AVR_LEAVE_CRITICAL_REGION( );
     57a:	89 81       	ldd	r24, Y+1	; 0x01
     57c:	8f bf       	out	0x3f, r24	; 63
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <hal_get_unknown_isr_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_unknown_isr_flag( void ){
    return hal_unknown_isr_flag;
     586:	80 91 0f 0d 	lds	r24, 0x0D0F
}
     58a:	08 95       	ret

0000058c <hal_clear_unknown_isr_flag>:

/*! \brief  This function clears the UNKNOWN_ISR flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_unknown_isr_flag( void ){
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	0f 92       	push	r0
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     596:	8f b7       	in	r24, 0x3f	; 63
     598:	89 83       	std	Y+1, r24	; 0x01
     59a:	f8 94       	cli
    hal_unknown_isr_flag = 0;
     59c:	10 92 0f 0d 	sts	0x0D0F, r1
    AVR_LEAVE_CRITICAL_REGION( );
     5a0:	89 81       	ldd	r24, Y+1	; 0x01
     5a2:	8f bf       	out	0x3f, r24	; 63
}
     5a4:	0f 90       	pop	r0
     5a6:	cf 91       	pop	r28
     5a8:	df 91       	pop	r29
     5aa:	08 95       	ret

000005ac <hal_get_pll_unlock_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_pll_unlock_flag( void ){
    return hal_pll_unlock_flag;
     5ac:	80 91 10 0d 	lds	r24, 0x0D10
}
     5b0:	08 95       	ret

000005b2 <hal_clear_pll_unlock_flag>:

/*! \brief  This function clears the PLL_UNLOCK flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_pll_unlock_flag( void ){
     5b2:	df 93       	push	r29
     5b4:	cf 93       	push	r28
     5b6:	0f 92       	push	r0
     5b8:	cd b7       	in	r28, 0x3d	; 61
     5ba:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     5bc:	8f b7       	in	r24, 0x3f	; 63
     5be:	89 83       	std	Y+1, r24	; 0x01
     5c0:	f8 94       	cli
    hal_pll_unlock_flag = 0;
     5c2:	10 92 10 0d 	sts	0x0D10, r1
    AVR_LEAVE_CRITICAL_REGION( );
     5c6:	89 81       	ldd	r24, Y+1	; 0x01
     5c8:	8f bf       	out	0x3f, r24	; 63
}
     5ca:	0f 90       	pop	r0
     5cc:	cf 91       	pop	r28
     5ce:	df 91       	pop	r29
     5d0:	08 95       	ret

000005d2 <hal_get_pll_lock_flag>:
 *  for new event occurances. 
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_get_pll_lock_flag( void ){
    return hal_pll_lock_flag;
     5d2:	80 91 11 0d 	lds	r24, 0x0D11
}
     5d6:	08 95       	ret

000005d8 <hal_clear_pll_lock_flag>:

/*! \brief  This function clears the PLL_LOCK flag.
 *
 *  \ingroup hal_avr_api
 */
void hal_clear_pll_lock_flag( void ){
     5d8:	df 93       	push	r29
     5da:	cf 93       	push	r28
     5dc:	0f 92       	push	r0
     5de:	cd b7       	in	r28, 0x3d	; 61
     5e0:	de b7       	in	r29, 0x3e	; 62
    
    AVR_ENTER_CRITICAL_REGION( );
     5e2:	8f b7       	in	r24, 0x3f	; 63
     5e4:	89 83       	std	Y+1, r24	; 0x01
     5e6:	f8 94       	cli
    hal_pll_lock_flag = 0;
     5e8:	10 92 11 0d 	sts	0x0D11, r1
    AVR_LEAVE_CRITICAL_REGION( );
     5ec:	89 81       	ldd	r24, Y+1	; 0x01
     5ee:	8f bf       	out	0x3f, r24	; 63
}
     5f0:	0f 90       	pop	r0
     5f2:	cf 91       	pop	r28
     5f4:	df 91       	pop	r29
     5f6:	08 95       	ret

000005f8 <hal_register_read>:
 *
 *  \returns The actual value of the read register.
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_register_read( uint8_t address ){
     5f8:	df 93       	push	r29
     5fa:	cf 93       	push	r28
     5fc:	0f 92       	push	r0
     5fe:	cd b7       	in	r28, 0x3d	; 61
     600:	de b7       	in	r29, 0x3e	; 62
    
    //Add the register read command to the register address.
    address &= HAL_TRX_CMD_RADDRM;
    address |= HAL_TRX_CMD_RR;
     602:	80 68       	ori	r24, 0x80	; 128
    
    uint8_t register_value = 0;
    
    AVR_ENTER_CRITICAL_REGION( );
     604:	9f b7       	in	r25, 0x3f	; 63
     606:	99 83       	std	Y+1, r25	; 0x01
     608:	f8 94       	cli
    
    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
     60a:	28 98       	cbi	0x05, 0	; 5
    
    /*Send Register address and read register content.*/
    SPDR = address;
     60c:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     60e:	0d b4       	in	r0, 0x2d	; 45
     610:	07 fe       	sbrs	r0, 7
     612:	fd cf       	rjmp	.-6      	; 0x60e <hal_register_read+0x16>
    register_value = SPDR;
     614:	8e b5       	in	r24, 0x2e	; 46
    
    SPDR = register_value;
     616:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     618:	0d b4       	in	r0, 0x2d	; 45
     61a:	07 fe       	sbrs	r0, 7
     61c:	fd cf       	rjmp	.-6      	; 0x618 <hal_register_read+0x20>
    register_value = SPDR;
     61e:	8e b5       	in	r24, 0x2e	; 46

    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Select High.  
     620:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     622:	99 81       	ldd	r25, Y+1	; 0x01
     624:	9f bf       	out	0x3f, r25	; 63
    
    return register_value;
}
     626:	0f 90       	pop	r0
     628:	cf 91       	pop	r28
     62a:	df 91       	pop	r29
     62c:	08 95       	ret

0000062e <hal_register_write>:
 *  \param  address Address of register to write.
 *  \param  value   Value to write.
 *
 *  \ingroup hal_avr_api
 */
void hal_register_write( uint8_t address, uint8_t value ){
     62e:	df 93       	push	r29
     630:	cf 93       	push	r28
     632:	0f 92       	push	r0
     634:	cd b7       	in	r28, 0x3d	; 61
     636:	de b7       	in	r29, 0x3e	; 62
                                       
    //Add the Register Write command to the address.
    address = HAL_TRX_CMD_RW | (HAL_TRX_CMD_RADDRM & address);
     638:	80 6c       	ori	r24, 0xC0	; 192
    
    AVR_ENTER_CRITICAL_REGION( );    
     63a:	9f b7       	in	r25, 0x3f	; 63
     63c:	99 83       	std	Y+1, r25	; 0x01
     63e:	f8 94       	cli
    
    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
     640:	28 98       	cbi	0x05, 0	; 5
    
    /*Send Register address and write register content.*/
    SPDR = address;
     642:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     644:	0d b4       	in	r0, 0x2d	; 45
     646:	07 fe       	sbrs	r0, 7
     648:	fd cf       	rjmp	.-6      	; 0x644 <hal_register_write+0x16>
    uint8_t dummy_read = SPDR;
     64a:	8e b5       	in	r24, 0x2e	; 46
    
    SPDR = value;
     64c:	6e bd       	out	0x2e, r22	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     64e:	0d b4       	in	r0, 0x2d	; 45
     650:	07 fe       	sbrs	r0, 7
     652:	fd cf       	rjmp	.-6      	; 0x64e <hal_register_write+0x20>
    dummy_read = SPDR;
     654:	8e b5       	in	r24, 0x2e	; 46
    
    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Slect High.
     656:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     658:	89 81       	ldd	r24, Y+1	; 0x01
     65a:	8f bf       	out	0x3f, r24	; 63
}
     65c:	0f 90       	pop	r0
     65e:	cf 91       	pop	r28
     660:	df 91       	pop	r29
     662:	08 95       	ret

00000664 <hal_subregister_read>:
 *  \param  position   Bit position of the subregister
 *  \retval Value of the read subregister.
 *
 *  \ingroup hal_avr_api
 */
uint8_t hal_subregister_read( uint8_t address, uint8_t mask, uint8_t position ){
     664:	ff 92       	push	r15
     666:	0f 93       	push	r16
     668:	1f 93       	push	r17
     66a:	06 2f       	mov	r16, r22
     66c:	f4 2e       	mov	r15, r20
    
    //Read current register value and mask out subregister.
    uint8_t register_value = hal_register_read( address );
     66e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    register_value &= mask;
    register_value >>= position; //Align subregister value.
     672:	08 23       	and	r16, r24
     674:	10 e0       	ldi	r17, 0x00	; 0
     676:	02 c0       	rjmp	.+4      	; 0x67c <hal_subregister_read+0x18>
     678:	15 95       	asr	r17
     67a:	07 95       	ror	r16
     67c:	fa 94       	dec	r15
     67e:	e2 f7       	brpl	.-8      	; 0x678 <hal_subregister_read+0x14>
    
    return register_value;
}
     680:	80 2f       	mov	r24, r16
     682:	1f 91       	pop	r17
     684:	0f 91       	pop	r16
     686:	ff 90       	pop	r15
     688:	08 95       	ret

0000068a <hal_subregister_write>:
 *  \param  value  Value to write into the subregister.
 *
 *  \ingroup hal_avr_api
 */
void hal_subregister_write( uint8_t address, uint8_t mask, uint8_t position, 
                            uint8_t value ){
     68a:	ef 92       	push	r14
     68c:	ff 92       	push	r15
     68e:	0f 93       	push	r16
     690:	1f 93       	push	r17
     692:	df 93       	push	r29
     694:	cf 93       	push	r28
     696:	0f 92       	push	r0
     698:	cd b7       	in	r28, 0x3d	; 61
     69a:	de b7       	in	r29, 0x3e	; 62
     69c:	18 2f       	mov	r17, r24
     69e:	06 2f       	mov	r16, r22
     6a0:	e4 2e       	mov	r14, r20
     6a2:	f2 2e       	mov	r15, r18
    
    //Read current register value and mask area outside the subregister.
    uint8_t register_value = hal_register_read( address );
     6a4:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
     6a8:	28 2f       	mov	r18, r24
 *  \ingroup hal_avr_api
 */
void hal_register_write( uint8_t address, uint8_t value ){
                                       
    //Add the Register Write command to the address.
    address = HAL_TRX_CMD_RW | (HAL_TRX_CMD_RADDRM & address);
     6aa:	10 6c       	ori	r17, 0xC0	; 192
    
    AVR_ENTER_CRITICAL_REGION( );    
     6ac:	8f b7       	in	r24, 0x3f	; 63
     6ae:	89 83       	std	Y+1, r24	; 0x01
     6b0:	f8 94       	cli
    
    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
     6b2:	28 98       	cbi	0x05, 0	; 5
    
    /*Send Register address and write register content.*/
    SPDR = address;
     6b4:	1e bd       	out	0x2e, r17	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     6b6:	0d b4       	in	r0, 0x2d	; 45
     6b8:	07 fe       	sbrs	r0, 7
     6ba:	fd cf       	rjmp	.-6      	; 0x6b6 <hal_subregister_write+0x2c>
    uint8_t dummy_read = SPDR;
     6bc:	8e b5       	in	r24, 0x2e	; 46
    //Read current register value and mask area outside the subregister.
    uint8_t register_value = hal_register_read( address );
    register_value &= ~mask;
    
    //Start preparing the new subregister value. shift in place and mask.
    value <<= position;
     6be:	8f 2d       	mov	r24, r15
     6c0:	90 e0       	ldi	r25, 0x00	; 0
     6c2:	02 c0       	rjmp	.+4      	; 0x6c8 <hal_subregister_write+0x3e>
     6c4:	88 0f       	add	r24, r24
     6c6:	99 1f       	adc	r25, r25
     6c8:	ea 94       	dec	r14
     6ca:	e2 f7       	brpl	.-8      	; 0x6c4 <hal_subregister_write+0x3a>
    value &= mask;
     6cc:	80 23       	and	r24, r16
void hal_subregister_write( uint8_t address, uint8_t mask, uint8_t position, 
                            uint8_t value ){
    
    //Read current register value and mask area outside the subregister.
    uint8_t register_value = hal_register_read( address );
    register_value &= ~mask;
     6ce:	00 95       	com	r16
     6d0:	02 23       	and	r16, r18
    
    //Start preparing the new subregister value. shift in place and mask.
    value <<= position;
    value &= mask;
    
    value |= register_value; //Set the new subregister value.
     6d2:	80 2b       	or	r24, r16
    /*Send Register address and write register content.*/
    SPDR = address;
    while ((SPSR & (1 << SPIF)) == 0) {;}
    uint8_t dummy_read = SPDR;
    
    SPDR = value;
     6d4:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     6d6:	0d b4       	in	r0, 0x2d	; 45
     6d8:	07 fe       	sbrs	r0, 7
     6da:	fd cf       	rjmp	.-6      	; 0x6d6 <hal_subregister_write+0x4c>
    dummy_read = SPDR;
     6dc:	8e b5       	in	r24, 0x2e	; 46
    
    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Slect High.
     6de:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     6e0:	89 81       	ldd	r24, Y+1	; 0x01
     6e2:	8f bf       	out	0x3f, r24	; 63
    
    value |= register_value; //Set the new subregister value.

    //Write the modified register value.
    hal_register_write( address, value );
}
     6e4:	0f 90       	pop	r0
     6e6:	cf 91       	pop	r28
     6e8:	df 91       	pop	r29
     6ea:	1f 91       	pop	r17
     6ec:	0f 91       	pop	r16
     6ee:	ff 90       	pop	r15
     6f0:	ef 90       	pop	r14
     6f2:	08 95       	ret

000006f4 <hal_frame_read>:
 *
 *  \param  rx_frame    Pointer to the data structure where the frame is stored.
 *
 *  \ingroup hal_avr_api
 */
__z void hal_frame_read( hal_rx_frame_t *rx_frame ){
     6f4:	df 93       	push	r29
     6f6:	cf 93       	push	r28
     6f8:	0f 92       	push	r0
     6fa:	cd b7       	in	r28, 0x3d	; 61
     6fc:	de b7       	in	r29, 0x3e	; 62
     6fe:	fc 01       	movw	r30, r24
    
    AVR_ENTER_CRITICAL_REGION( );
     700:	8f b7       	in	r24, 0x3f	; 63
     702:	89 83       	std	Y+1, r24	; 0x01
     704:	f8 94       	cli
    
    HAL_SS_LOW( );
     706:	28 98       	cbi	0x05, 0	; 5
    
    /*Send frame read command.*/
    SPDR = HAL_TRX_CMD_FR;
     708:	80 e2       	ldi	r24, 0x20	; 32
     70a:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     70c:	0d b4       	in	r0, 0x2d	; 45
     70e:	07 fe       	sbrs	r0, 7
     710:	fd cf       	rjmp	.-6      	; 0x70c <hal_frame_read+0x18>
    uint8_t frame_length = SPDR;
     712:	8e b5       	in	r24, 0x2e	; 46
    
    /*Read frame length.*/    
    SPDR = frame_length;
     714:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     716:	0d b4       	in	r0, 0x2d	; 45
     718:	07 fe       	sbrs	r0, 7
     71a:	fd cf       	rjmp	.-6      	; 0x716 <hal_frame_read+0x22>
    frame_length = SPDR;
     71c:	9e b5       	in	r25, 0x2e	; 46
    
    /*Check for correct frame length.*/
    if ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH)) {
     71e:	89 2f       	mov	r24, r25
     720:	83 50       	subi	r24, 0x03	; 3
     722:	8d 37       	cpi	r24, 0x7D	; 125
     724:	60 f5       	brcc	.+88     	; 0x77e <hal_frame_read+0x8a>
        
        uint16_t crc = 0;
        uint8_t *rx_data = (rx_frame->data);
        
        rx_frame->length = frame_length; //Store frame length.
     726:	90 83       	st	Z, r25
        
        /*Upload frame buffer to data pointer. Calculate CRC.*/
        SPDR = frame_length;
     728:	9e bd       	out	0x2e, r25	; 46
        while ((SPSR & (1 << SPIF)) == 0) {;}
     72a:	0d b4       	in	r0, 0x2d	; 45
     72c:	07 fe       	sbrs	r0, 7
     72e:	fd cf       	rjmp	.-6      	; 0x72a <hal_frame_read+0x36>
    
    /*Check for correct frame length.*/
    if ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH)) {
        
        uint16_t crc = 0;
        uint8_t *rx_data = (rx_frame->data);
     730:	df 01       	movw	r26, r30
     732:	11 96       	adiw	r26, 0x01	; 1
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	30 e0       	ldi	r19, 0x00	; 0
        SPDR = frame_length;
        while ((SPSR & (1 << SPIF)) == 0) {;}
            
        do {
            
            uint8_t const tempData = SPDR;
     738:	8e b5       	in	r24, 0x2e	; 46
            SPDR = tempData; // Any data will do, and tempData is readily available. Saving cycles.
     73a:	8e bd       	out	0x2e, r24	; 46
            
            *rx_data++ = tempData;      
     73c:	8d 93       	st	X+, r24
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
     73e:	28 27       	eor	r18, r24
     740:	02 2e       	mov	r0, r18
     742:	22 95       	swap	r18
     744:	20 7f       	andi	r18, 0xF0	; 240
     746:	20 25       	eor	r18, r0
     748:	03 2e       	mov	r0, r19
     74a:	32 2f       	mov	r19, r18
     74c:	22 95       	swap	r18
     74e:	2f 70       	andi	r18, 0x0F	; 15
     750:	02 26       	eor	r0, r18
     752:	26 95       	lsr	r18
     754:	32 27       	eor	r19, r18
     756:	23 27       	eor	r18, r19
     758:	22 0f       	add	r18, r18
     75a:	22 0f       	add	r18, r18
     75c:	22 0f       	add	r18, r18
     75e:	20 25       	eor	r18, r0
            
            crc = crc_ccitt_update( crc, tempData );
            
            while ((SPSR & (1 << SPIF)) == 0) {;}
     760:	0d b4       	in	r0, 0x2d	; 45
     762:	07 fe       	sbrs	r0, 7
     764:	fd cf       	rjmp	.-6      	; 0x760 <hal_frame_read+0x6c>
        } while (--frame_length > 0);
     766:	91 50       	subi	r25, 0x01	; 1
     768:	39 f7       	brne	.-50     	; 0x738 <hal_frame_read+0x44>
        
        /*Read LQI value for this frame.*/
        rx_frame->lqi = SPDR;
     76a:	8e b5       	in	r24, 0x2e	; 46
     76c:	e0 58       	subi	r30, 0x80	; 128
     76e:	ff 4f       	sbci	r31, 0xFF	; 255
     770:	81 93       	st	Z+, r24
        
        HAL_SS_HIGH( );
     772:	28 9a       	sbi	0x05, 0	; 5
        
        /*Check calculated crc, and set crc field in hal_rx_frame_t accordingly.*/
        if (crc == HAL_CALCULATED_CRC_OK) {
     774:	23 2b       	or	r18, r19
     776:	41 f4       	brne	.+16     	; 0x788 <hal_frame_read+0x94>
            rx_frame->crc = true; 
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	80 83       	st	Z, r24
     77c:	06 c0       	rjmp	.+12     	; 0x78a <hal_frame_read+0x96>
        } else { rx_frame->crc = false; }
    } else {
        
        HAL_SS_HIGH( );
     77e:	28 9a       	sbi	0x05, 0	; 5
        
        rx_frame->length = 0;
     780:	10 82       	st	Z, r1
        rx_frame->lqi    = 0;
     782:	e0 58       	subi	r30, 0x80	; 128
     784:	ff 4f       	sbci	r31, 0xFF	; 255
     786:	11 92       	st	Z+, r1
        rx_frame->crc    = false;    
     788:	10 82       	st	Z, r1
    }
    
    AVR_LEAVE_CRITICAL_REGION( );
     78a:	89 81       	ldd	r24, Y+1	; 0x01
     78c:	8f bf       	out	0x3f, r24	; 63
}
     78e:	0f 90       	pop	r0
     790:	cf 91       	pop	r28
     792:	df 91       	pop	r29
     794:	08 95       	ret

00000796 <hal_frame_write>:
 *  \param  write_buffer    Pointer to data that is to be written to frame buffer.
 *  \param  length          Length of data. The maximum length is 127 bytes.
 *
 *  \ingroup hal_avr_api
 */
__z void hal_frame_write( uint8_t *write_buffer, uint8_t length ){
     796:	df 93       	push	r29
     798:	cf 93       	push	r28
     79a:	0f 92       	push	r0
     79c:	cd b7       	in	r28, 0x3d	; 61
     79e:	de b7       	in	r29, 0x3e	; 62
     7a0:	fc 01       	movw	r30, r24
    
    length &= HAL_TRX_CMD_RADDRM; //Truncate length to maximum frame length.
     7a2:	6f 77       	andi	r22, 0x7F	; 127
    
    AVR_ENTER_CRITICAL_REGION( );
     7a4:	8f b7       	in	r24, 0x3f	; 63
     7a6:	89 83       	std	Y+1, r24	; 0x01
     7a8:	f8 94       	cli
    
    HAL_SS_LOW( ); //Initiate the SPI transaction.
     7aa:	28 98       	cbi	0x05, 0	; 5
    
    /*SEND FRAME WRITE COMMAND AND FRAME LENGTH.*/
    SPDR = HAL_TRX_CMD_FW;
     7ac:	80 e6       	ldi	r24, 0x60	; 96
     7ae:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     7b0:	0d b4       	in	r0, 0x2d	; 45
     7b2:	07 fe       	sbrs	r0, 7
     7b4:	fd cf       	rjmp	.-6      	; 0x7b0 <hal_frame_write+0x1a>
    uint8_t dummy_read = SPDR;
     7b6:	8e b5       	in	r24, 0x2e	; 46
        
    SPDR = length;
     7b8:	6e bd       	out	0x2e, r22	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     7ba:	0d b4       	in	r0, 0x2d	; 45
     7bc:	07 fe       	sbrs	r0, 7
     7be:	fd cf       	rjmp	.-6      	; 0x7ba <hal_frame_write+0x24>
    dummy_read = SPDR;
     7c0:	8e b5       	in	r24, 0x2e	; 46
    
    //Download to the Frame Buffer.
    do {
        
        SPDR = *write_buffer++;
     7c2:	81 91       	ld	r24, Z+
     7c4:	8e bd       	out	0x2e, r24	; 46
        --length;
     7c6:	61 50       	subi	r22, 0x01	; 1
        
        while ((SPSR & (1 << SPIF)) == 0) {;}
     7c8:	0d b4       	in	r0, 0x2d	; 45
     7ca:	07 fe       	sbrs	r0, 7
     7cc:	fd cf       	rjmp	.-6      	; 0x7c8 <hal_frame_write+0x32>
        
        dummy_read = SPDR;
     7ce:	8e b5       	in	r24, 0x2e	; 46
    } while (length > 0);
     7d0:	66 23       	and	r22, r22
     7d2:	b9 f7       	brne	.-18     	; 0x7c2 <hal_frame_write+0x2c>
    
    HAL_SS_HIGH( ); //Terminate SPI transaction.
     7d4:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     7d6:	89 81       	ldd	r24, Y+1	; 0x01
     7d8:	8f bf       	out	0x3f, r24	; 63
}
     7da:	0f 90       	pop	r0
     7dc:	cf 91       	pop	r28
     7de:	df 91       	pop	r29
     7e0:	08 95       	ret

000007e2 <hal_sram_read>:
 * \param length Length of the read burst
 * \param data Pointer to buffer where data is stored.
 *
 * \ingroup hal_avr_api
 */
__z void hal_sram_read( uint8_t address, uint8_t length, uint8_t *data ){
     7e2:	df 93       	push	r29
     7e4:	cf 93       	push	r28
     7e6:	0f 92       	push	r0
     7e8:	cd b7       	in	r28, 0x3d	; 61
     7ea:	de b7       	in	r29, 0x3e	; 62
     7ec:	98 2f       	mov	r25, r24
     7ee:	fa 01       	movw	r30, r20
    
    AVR_ENTER_CRITICAL_REGION( );
     7f0:	8f b7       	in	r24, 0x3f	; 63
     7f2:	89 83       	std	Y+1, r24	; 0x01
     7f4:	f8 94       	cli
    
    HAL_SS_LOW( ); //Initiate the SPI transaction.
     7f6:	28 98       	cbi	0x05, 0	; 5
    
    /*Send SRAM read command.*/
    SPDR = HAL_TRX_CMD_SR;
     7f8:	1e bc       	out	0x2e, r1	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     7fa:	0d b4       	in	r0, 0x2d	; 45
     7fc:	07 fe       	sbrs	r0, 7
     7fe:	fd cf       	rjmp	.-6      	; 0x7fa <hal_sram_read+0x18>
    uint8_t dummy_read = SPDR;
     800:	8e b5       	in	r24, 0x2e	; 46
    
    /*Send address where to start reading.*/    
    SPDR = address;
     802:	9e bd       	out	0x2e, r25	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     804:	0d b4       	in	r0, 0x2d	; 45
     806:	07 fe       	sbrs	r0, 7
     808:	fd cf       	rjmp	.-6      	; 0x804 <hal_sram_read+0x22>
    dummy_read = SPDR;
     80a:	8e b5       	in	r24, 0x2e	; 46
    
    /*Upload the chosen memory area.*/
    do {
        
        SPDR = HAL_DUMMY_READ;
     80c:	1e bc       	out	0x2e, r1	; 46
        while ((SPSR & (1 << SPIF)) == 0) {;}
     80e:	0d b4       	in	r0, 0x2d	; 45
     810:	07 fe       	sbrs	r0, 7
     812:	fd cf       	rjmp	.-6      	; 0x80e <hal_sram_read+0x2c>
        *data++ = SPDR;
     814:	8e b5       	in	r24, 0x2e	; 46
     816:	80 83       	st	Z, r24
    } while (--length > 0);
     818:	61 50       	subi	r22, 0x01	; 1
     81a:	11 f0       	breq	.+4      	; 0x820 <hal_sram_read+0x3e>
    /*Upload the chosen memory area.*/
    do {
        
        SPDR = HAL_DUMMY_READ;
        while ((SPSR & (1 << SPIF)) == 0) {;}
        *data++ = SPDR;
     81c:	31 96       	adiw	r30, 0x01	; 1
     81e:	f6 cf       	rjmp	.-20     	; 0x80c <hal_sram_read+0x2a>
    } while (--length > 0);

    HAL_SS_HIGH( );
     820:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	8f bf       	out	0x3f, r24	; 63
}
     826:	0f 90       	pop	r0
     828:	cf 91       	pop	r28
     82a:	df 91       	pop	r29
     82c:	08 95       	ret

0000082e <hal_sram_write>:
 * \param length  Length of the write burst
 * \param data    Pointer to an array of bytes that should be written
 *
 * \ingroup hal_avr_api
 */
__z void hal_sram_write( uint8_t address, uint8_t length, uint8_t *data ){
     82e:	df 93       	push	r29
     830:	cf 93       	push	r28
     832:	0f 92       	push	r0
     834:	cd b7       	in	r28, 0x3d	; 61
     836:	de b7       	in	r29, 0x3e	; 62
     838:	98 2f       	mov	r25, r24
     83a:	fa 01       	movw	r30, r20
    
    AVR_ENTER_CRITICAL_REGION( );
     83c:	8f b7       	in	r24, 0x3f	; 63
     83e:	89 83       	std	Y+1, r24	; 0x01
     840:	f8 94       	cli
        
    HAL_SS_LOW( );
     842:	28 98       	cbi	0x05, 0	; 5
    
    /*Send SRAM write command.*/
    SPDR = HAL_TRX_CMD_SW;
     844:	80 e4       	ldi	r24, 0x40	; 64
     846:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     848:	0d b4       	in	r0, 0x2d	; 45
     84a:	07 fe       	sbrs	r0, 7
     84c:	fd cf       	rjmp	.-6      	; 0x848 <hal_sram_write+0x1a>
    uint8_t dummy_read = SPDR;
     84e:	8e b5       	in	r24, 0x2e	; 46
    
    /*Send address where to start writing to.*/
    SPDR = address;
     850:	9e bd       	out	0x2e, r25	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     852:	0d b4       	in	r0, 0x2d	; 45
     854:	07 fe       	sbrs	r0, 7
     856:	fd cf       	rjmp	.-6      	; 0x852 <hal_sram_write+0x24>
    dummy_read = SPDR;
     858:	8e b5       	in	r24, 0x2e	; 46
    
    /*Upload the chosen memory area.*/
    do {
        
        SPDR = *data++;
     85a:	81 91       	ld	r24, Z+
     85c:	8e bd       	out	0x2e, r24	; 46
        while ((SPSR & (1 << SPIF)) == 0) {;}
     85e:	0d b4       	in	r0, 0x2d	; 45
     860:	07 fe       	sbrs	r0, 7
     862:	fd cf       	rjmp	.-6      	; 0x85e <hal_sram_write+0x30>
        dummy_read = SPDR;
     864:	8e b5       	in	r24, 0x2e	; 46
    } while (--length > 0);
     866:	61 50       	subi	r22, 0x01	; 1
     868:	c1 f7       	brne	.-16     	; 0x85a <hal_sram_write+0x2c>
    
    HAL_SS_HIGH( );
     86a:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     86c:	89 81       	ldd	r24, Y+1	; 0x01
     86e:	8f bf       	out	0x3f, r24	; 63
}
     870:	0f 90       	pop	r0
     872:	cf 91       	pop	r28
     874:	df 91       	pop	r29
     876:	08 95       	ret

00000878 <hal_trx_aes_wrrd>:
 * @param addr Start address in the SRAM for the write operation
 * @param idata Pointer to the data written/read into/from SRAM
 * @param length Number of bytes written/read into/from SRAM
 */
__z void hal_trx_aes_wrrd(uint8_t addr, uint8_t *idata, uint8_t length)
{
     878:	df 93       	push	r29
     87a:	cf 93       	push	r28
     87c:	0f 92       	push	r0
     87e:	cd b7       	in	r28, 0x3d	; 61
     880:	de b7       	in	r29, 0x3e	; 62
     882:	98 2f       	mov	r25, r24
     884:	db 01       	movw	r26, r22
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     886:	82 e0       	ldi	r24, 0x02	; 2
     888:	8a 95       	dec	r24
     88a:	f1 f7       	brne	.-4      	; 0x888 <hal_trx_aes_wrrd+0x10>
    uint8_t *odata;

    delay_us(1);

    AVR_ENTER_CRITICAL_REGION();
     88c:	8f b7       	in	r24, 0x3f	; 63
     88e:	89 83       	std	Y+1, r24	; 0x01
     890:	f8 94       	cli
    /* Start SPI transaction by pulling SEL low */
    HAL_SS_LOW();
     892:	28 98       	cbi	0x05, 0	; 5

    /* Send the command byte */
    SPDR = HAL_TRX_CMD_SW;
     894:	80 e4       	ldi	r24, 0x40	; 64
     896:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     898:	0d b4       	in	r0, 0x2d	; 45
     89a:	07 fe       	sbrs	r0, 7
     89c:	fd cf       	rjmp	.-6      	; 0x898 <hal_trx_aes_wrrd+0x20>

    /* write SRAM start address */
    SPDR = addr;
     89e:	9e bd       	out	0x2e, r25	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     8a0:	0d b4       	in	r0, 0x2d	; 45
     8a2:	07 fe       	sbrs	r0, 7
     8a4:	fd cf       	rjmp	.-6      	; 0x8a0 <hal_trx_aes_wrrd+0x28>

    /* now transfer data */
    odata = idata;

    /* write data byte 0 - the obtained value in SPDR is meaningless */
    SPDR = *idata++;
     8a6:	8c 91       	ld	r24, X
     8a8:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     8aa:	0d b4       	in	r0, 0x2d	; 45
     8ac:	07 fe       	sbrs	r0, 7
     8ae:	fd cf       	rjmp	.-6      	; 0x8aa <hal_trx_aes_wrrd+0x32>
     8b0:	94 2f       	mov	r25, r20
     8b2:	fd 01       	movw	r30, r26
     8b4:	07 c0       	rjmp	.+14     	; 0x8c4 <hal_trx_aes_wrrd+0x4c>

    /* process data bytes 1...length-1: write and read */
    while (--length)
    {
        SPDR = *idata++;
     8b6:	81 81       	ldd	r24, Z+1	; 0x01
     8b8:	8e bd       	out	0x2e, r24	; 46
        while ((SPSR & (1 << SPIF)) == 0) {;}
     8ba:	0d b4       	in	r0, 0x2d	; 45
     8bc:	07 fe       	sbrs	r0, 7
     8be:	fd cf       	rjmp	.-6      	; 0x8ba <hal_trx_aes_wrrd+0x42>
        *odata++ = SPDR;
     8c0:	8e b5       	in	r24, 0x2e	; 46
     8c2:	81 93       	st	Z+, r24
    /* write data byte 0 - the obtained value in SPDR is meaningless */
    SPDR = *idata++;
    while ((SPSR & (1 << SPIF)) == 0) {;}

    /* process data bytes 1...length-1: write and read */
    while (--length)
     8c4:	91 50       	subi	r25, 0x01	; 1
     8c6:	b9 f7       	brne	.-18     	; 0x8b6 <hal_trx_aes_wrrd+0x3e>
     8c8:	41 50       	subi	r20, 0x01	; 1
     8ca:	fd 01       	movw	r30, r26
     8cc:	e4 0f       	add	r30, r20
     8ce:	f1 1d       	adc	r31, r1
        while ((SPSR & (1 << SPIF)) == 0) {;}
        *odata++ = SPDR;
    }

    /* to get the last data byte, write some dummy byte */
    SPDR = SPI_DUMMY_VALUE;
     8d0:	1e bc       	out	0x2e, r1	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     8d2:	0d b4       	in	r0, 0x2d	; 45
     8d4:	07 fe       	sbrs	r0, 7
     8d6:	fd cf       	rjmp	.-6      	; 0x8d2 <hal_trx_aes_wrrd+0x5a>
    *odata++ = SPDR;
     8d8:	8e b5       	in	r24, 0x2e	; 46
     8da:	80 83       	st	Z, r24

    /* Stop the SPI transaction by setting SEL high */
    HAL_SS_HIGH();
     8dc:	28 9a       	sbi	0x05, 0	; 5
    AVR_LEAVE_CRITICAL_REGION();
     8de:	89 81       	ldd	r24, Y+1	; 0x01
     8e0:	8f bf       	out	0x3f, r24	; 63
}
     8e2:	0f 90       	pop	r0
     8e4:	cf 91       	pop	r28
     8e6:	df 91       	pop	r29
     8e8:	08 95       	ret

000008ea <hal_get_system_time>:
 *
 * \returns The system time with symbol resolution.
 *
 * \ingroup hal_avr_api
 */
uint32_t hal_get_system_time( void ){
     8ea:	df 93       	push	r29
     8ec:	cf 93       	push	r28
     8ee:	0f 92       	push	r0
     8f0:	cd b7       	in	r28, 0x3d	; 61
     8f2:	de b7       	in	r29, 0x3e	; 62
    
    uint32_t system_time = hal_system_time; //Read current system time (MSB).
     8f4:	20 91 08 0d 	lds	r18, 0x0D08
     8f8:	30 91 09 0d 	lds	r19, 0x0D09
     8fc:	40 e0       	ldi	r20, 0x00	; 0
     8fe:	50 e0       	ldi	r21, 0x00	; 0
    system_time <<= 16;
     900:	a9 01       	movw	r20, r18
     902:	33 27       	eor	r19, r19
     904:	22 27       	eor	r18, r18
    
    /*Disable interrupts. This is done since the TCNT1 value should not 
      be read when the timer is running.*/
    AVR_ENTER_CRITICAL_REGION( );
     906:	8f b7       	in	r24, 0x3f	; 63
     908:	89 83       	std	Y+1, r24	; 0x01
     90a:	f8 94       	cli
    
    system_time |= TCNT1; //Add 16 LSB. 
     90c:	80 91 84 00 	lds	r24, 0x0084
     910:	90 91 85 00 	lds	r25, 0x0085
    
    AVR_LEAVE_CRITICAL_REGION( );
     914:	69 81       	ldd	r22, Y+1	; 0x01
     916:	6f bf       	out	0x3f, r22	; 63
     918:	a0 e0       	ldi	r26, 0x00	; 0
     91a:	b0 e0       	ldi	r27, 0x00	; 0
     91c:	28 2b       	or	r18, r24
     91e:	39 2b       	or	r19, r25
     920:	4a 2b       	or	r20, r26
     922:	5b 2b       	or	r21, r27
     924:	56 95       	lsr	r21
     926:	47 95       	ror	r20
     928:	37 95       	ror	r19
     92a:	27 95       	ror	r18
    
    //Return the system time in symbols.
    return ((system_time / HAL_US_PER_SYMBOL) & HAL_SYMBOL_MASK);
}
     92c:	b9 01       	movw	r22, r18
     92e:	ca 01       	movw	r24, r20
     930:	0f 90       	pop	r0
     932:	cf 91       	pop	r28
     934:	df 91       	pop	r29
     936:	08 95       	ret

00000938 <__vector_20>:
ISR( TIMER1_OVF_vect )
{
     938:	1f 92       	push	r1
     93a:	0f 92       	push	r0
     93c:	0f b6       	in	r0, 0x3f	; 63
     93e:	0f 92       	push	r0
     940:	11 24       	eor	r1, r1
     942:	8f 93       	push	r24
     944:	9f 93       	push	r25
 	hal_system_time++;
     946:	80 91 08 0d 	lds	r24, 0x0D08
     94a:	90 91 09 0d 	lds	r25, 0x0D09
     94e:	01 96       	adiw	r24, 0x01	; 1
     950:	90 93 09 0d 	sts	0x0D09, r25
     954:	80 93 08 0d 	sts	0x0D08, r24
}
     958:	9f 91       	pop	r25
     95a:	8f 91       	pop	r24
     95c:	0f 90       	pop	r0
     95e:	0f be       	out	0x3f, r0	; 63
     960:	0f 90       	pop	r0
     962:	1f 90       	pop	r1
     964:	18 95       	reti

00000966 <__vector_15>:
ISR(TIMER2_OVF_vect)
{
     966:	1f 92       	push	r1
     968:	0f 92       	push	r0
     96a:	0f b6       	in	r0, 0x3f	; 63
     96c:	0f 92       	push	r0
     96e:	11 24       	eor	r1, r1
}
     970:	0f 90       	pop	r0
     972:	0f be       	out	0x3f, r0	; 63
     974:	0f 90       	pop	r0
     976:	1f 90       	pop	r1
     978:	18 95       	reti

0000097a <__vector_35>:
ISR(TIMER3_OVF_vect)
{
     97a:	1f 92       	push	r1
     97c:	0f 92       	push	r0
     97e:	0f b6       	in	r0, 0x3f	; 63
     980:	0f 92       	push	r0
     982:	11 24       	eor	r1, r1
}
     984:	0f 90       	pop	r0
     986:	0f be       	out	0x3f, r0	; 63
     988:	0f 90       	pop	r0
     98a:	1f 90       	pop	r1
     98c:	18 95       	reti

0000098e <__vector_45>:
ISR(TIMER4_OVF_vect )
{
     98e:	1f 92       	push	r1
     990:	0f 92       	push	r0
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	0f 92       	push	r0
     996:	11 24       	eor	r1, r1
     998:	8f 93       	push	r24
	TCNT4L=0xE0;
     99a:	80 ee       	ldi	r24, 0xE0	; 224
     99c:	80 93 a4 00 	sts	0x00A4, r24
	TCNT4H=0xE3;
     9a0:	83 ee       	ldi	r24, 0xE3	; 227
     9a2:	80 93 a5 00 	sts	0x00A5, r24
	timer4_flag = true;
     9a6:	81 e0       	ldi	r24, 0x01	; 1
     9a8:	80 93 0a 0d 	sts	0x0D0A, r24
//	hal_set_slptr_low( );
}
     9ac:	8f 91       	pop	r24
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	0f 90       	pop	r0
     9b4:	1f 90       	pop	r1
     9b6:	18 95       	reti

000009b8 <__vector_50>:

ISR(TIMER5_OVF_vect)
{
     9b8:	1f 92       	push	r1
     9ba:	0f 92       	push	r0
     9bc:	0f b6       	in	r0, 0x3f	; 63
     9be:	0f 92       	push	r0
     9c0:	11 24       	eor	r1, r1
}
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	0f 90       	pop	r0
     9c8:	1f 90       	pop	r1
     9ca:	18 95       	reti

000009cc <__vector_16>:


//This #if compile switch is used to provide a "standard" function body for the 
//doxygen documentation.
ISR( TIMER1_CAPT_vect ){
     9cc:	1f 92       	push	r1
     9ce:	0f 92       	push	r0
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	0f 92       	push	r0
     9d4:	0b b6       	in	r0, 0x3b	; 59
     9d6:	0f 92       	push	r0
     9d8:	11 24       	eor	r1, r1
     9da:	0f 93       	push	r16
     9dc:	1f 93       	push	r17
     9de:	2f 93       	push	r18
     9e0:	3f 93       	push	r19
     9e2:	4f 93       	push	r20
     9e4:	5f 93       	push	r21
     9e6:	6f 93       	push	r22
     9e8:	7f 93       	push	r23
     9ea:	8f 93       	push	r24
     9ec:	9f 93       	push	r25
     9ee:	af 93       	push	r26
     9f0:	bf 93       	push	r27
     9f2:	ef 93       	push	r30
     9f4:	ff 93       	push	r31
     9f6:	df 93       	push	r29
     9f8:	cf 93       	push	r28
     9fa:	0f 92       	push	r0
     9fc:	cd b7       	in	r28, 0x3d	; 61
     9fe:	de b7       	in	r29, 0x3e	; 62
    
    /*The following code reads the current system time. This is done by first 
      reading the hal_system_time and then adding the 16 LSB directly from the
      TCNT1 register.
     */
    uint32_t isr_timestamp = hal_system_time;
     a00:	80 91 08 0d 	lds	r24, 0x0D08
     a04:	90 91 09 0d 	lds	r25, 0x0D09
     a08:	a0 e0       	ldi	r26, 0x00	; 0
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
    isr_timestamp <<= 16;
     a0c:	9c 01       	movw	r18, r24
     a0e:	11 27       	eor	r17, r17
     a10:	00 27       	eor	r16, r16
    isr_timestamp |= TCNT1; 
     a12:	80 91 84 00 	lds	r24, 0x0084
     a16:	90 91 85 00 	lds	r25, 0x0085
     a1a:	a0 e0       	ldi	r26, 0x00	; 0
     a1c:	b0 e0       	ldi	r27, 0x00	; 0
     a1e:	08 2b       	or	r16, r24
     a20:	19 2b       	or	r17, r25
     a22:	2a 2b       	or	r18, r26
     a24:	3b 2b       	or	r19, r27
    
    /*Read Interrupt source.*/
    HAL_SS_LOW( );
     a26:	28 98       	cbi	0x05, 0	; 5
    
    /*Send Register address and read register content.*/
    SPDR = RG_IRQ_STATUS | HAL_TRX_CMD_RR;
     a28:	8f e8       	ldi	r24, 0x8F	; 143
     a2a:	8e bd       	out	0x2e, r24	; 46
    /* This is the second part of the convertion of system time to a 16 us time 
       base. The division is moved here so we can spend less time waiting for SPI
       data.    
     */
    isr_timestamp /= HAL_US_PER_SYMBOL; //Divide so that we get time in 16us resolution.
    isr_timestamp &= HAL_SYMBOL_MASK;  
     a2c:	36 95       	lsr	r19
     a2e:	27 95       	ror	r18
     a30:	17 95       	ror	r17
     a32:	07 95       	ror	r16
    
    while ((SPSR & (1 << SPIF)) == 0) {;}
     a34:	0d b4       	in	r0, 0x2d	; 45
     a36:	07 fe       	sbrs	r0, 7
     a38:	fd cf       	rjmp	.-6      	; 0xa34 <__vector_16+0x68>
    uint8_t interrupt_source = SPDR; //The interrupt variable is used as a dummy read.
     a3a:	8e b5       	in	r24, 0x2e	; 46
    
    SPDR = interrupt_source;
     a3c:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}	
     a3e:	0d b4       	in	r0, 0x2d	; 45
     a40:	07 fe       	sbrs	r0, 7
     a42:	fd cf       	rjmp	.-6      	; 0xa3e <__vector_16+0x72>
    interrupt_source = SPDR; //The interrupt source is read.
     a44:	9e b5       	in	r25, 0x2e	; 46

    HAL_SS_HIGH( );
     a46:	28 9a       	sbi	0x05, 0	; 5

    /*Handle the incomming interrupt. Prioritized.*/
    if ((interrupt_source & HAL_RX_START_MASK)) {
     a48:	92 ff       	sbrs	r25, 2
     a4a:	1d c0       	rjmp	.+58     	; 0xa86 <__vector_16+0xba>
        
        hal_rx_start_flag++; //Increment RX_START flag.
     a4c:	80 91 0e 0d 	lds	r24, 0x0D0E
     a50:	8f 5f       	subi	r24, 0xFF	; 255
     a52:	80 93 0e 0d 	sts	0x0D0E, r24
        
        if( rx_start_callback != NULL ){
     a56:	e0 91 12 0d 	lds	r30, 0x0D12
     a5a:	f0 91 13 0d 	lds	r31, 0x0D13
     a5e:	30 97       	sbiw	r30, 0x00	; 0
     a60:	09 f4       	brne	.+2      	; 0xa64 <__vector_16+0x98>
     a62:	5f c0       	rjmp	.+190    	; 0xb22 <__vector_16+0x156>
            
            /*Read Frame length and call rx_start callback.*/
            HAL_SS_LOW( );
     a64:	28 98       	cbi	0x05, 0	; 5
    
            SPDR = HAL_TRX_CMD_FR;
     a66:	80 e2       	ldi	r24, 0x20	; 32
     a68:	8e bd       	out	0x2e, r24	; 46
            while ((SPSR & (1 << SPIF)) == 0) {;}
     a6a:	0d b4       	in	r0, 0x2d	; 45
     a6c:	07 fe       	sbrs	r0, 7
     a6e:	fd cf       	rjmp	.-6      	; 0xa6a <__vector_16+0x9e>
            uint8_t frame_length = SPDR;
     a70:	8e b5       	in	r24, 0x2e	; 46
        
            SPDR = frame_length; //Any data will do, so frame_length is used.
     a72:	8e bd       	out	0x2e, r24	; 46
            while ((SPSR & (1 << SPIF)) == 0) {;}
     a74:	0d b4       	in	r0, 0x2d	; 45
     a76:	07 fe       	sbrs	r0, 7
     a78:	fd cf       	rjmp	.-6      	; 0xa74 <__vector_16+0xa8>
            frame_length = SPDR;
     a7a:	4e b5       	in	r20, 0x2e	; 46
            
            HAL_SS_HIGH( );
     a7c:	28 9a       	sbi	0x05, 0	; 5
            
            rx_start_callback( isr_timestamp, frame_length );
     a7e:	c9 01       	movw	r24, r18
     a80:	b8 01       	movw	r22, r16
     a82:	09 95       	icall
     a84:	4e c0       	rjmp	.+156    	; 0xb22 <__vector_16+0x156>
        }
    }
    else if (interrupt_source & HAL_TRX_END_MASK) {
     a86:	93 ff       	sbrs	r25, 3
     a88:	10 c0       	rjmp	.+32     	; 0xaaa <__vector_16+0xde>
        
        hal_trx_end_flag++; //Increment TRX_END flag.
     a8a:	80 91 0d 0d 	lds	r24, 0x0D0D
     a8e:	8f 5f       	subi	r24, 0xFF	; 255
     a90:	80 93 0d 0d 	sts	0x0D0D, r24
        
        if( trx_end_callback != NULL ){
     a94:	e0 91 14 0d 	lds	r30, 0x0D14
     a98:	f0 91 15 0d 	lds	r31, 0x0D15
     a9c:	30 97       	sbiw	r30, 0x00	; 0
     a9e:	09 f4       	brne	.+2      	; 0xaa2 <__vector_16+0xd6>
     aa0:	40 c0       	rjmp	.+128    	; 0xb22 <__vector_16+0x156>
            trx_end_callback( isr_timestamp );
     aa2:	c9 01       	movw	r24, r18
     aa4:	b8 01       	movw	r22, r16
     aa6:	09 95       	icall
     aa8:	3c c0       	rjmp	.+120    	; 0xb22 <__vector_16+0x156>
        }
    } else if (interrupt_source & HAL_TRX_UR_MASK) {
     aaa:	96 ff       	sbrs	r25, 6
     aac:	06 c0       	rjmp	.+12     	; 0xaba <__vector_16+0xee>
        hal_trx_ur_flag++; //Increment TRX_UR flag.    
     aae:	80 91 0c 0d 	lds	r24, 0x0D0C
     ab2:	8f 5f       	subi	r24, 0xFF	; 255
     ab4:	80 93 0c 0d 	sts	0x0D0C, r24
     ab8:	34 c0       	rjmp	.+104    	; 0xb22 <__vector_16+0x156>
    } else if (interrupt_source & HAL_PLL_UNLOCK_MASK) {
     aba:	91 ff       	sbrs	r25, 1
     abc:	06 c0       	rjmp	.+12     	; 0xaca <__vector_16+0xfe>
        hal_pll_unlock_flag++; //Increment PLL_UNLOCK flag.   
     abe:	80 91 10 0d 	lds	r24, 0x0D10
     ac2:	8f 5f       	subi	r24, 0xFF	; 255
     ac4:	80 93 10 0d 	sts	0x0D10, r24
     ac8:	2c c0       	rjmp	.+88     	; 0xb22 <__vector_16+0x156>
    } else if (interrupt_source & HAL_PLL_LOCK_MASK) {
     aca:	90 ff       	sbrs	r25, 0
     acc:	06 c0       	rjmp	.+12     	; 0xada <__vector_16+0x10e>
        hal_pll_lock_flag++; //Increment PLL_LOCK flag.
     ace:	80 91 11 0d 	lds	r24, 0x0D11
     ad2:	8f 5f       	subi	r24, 0xFF	; 255
     ad4:	80 93 11 0d 	sts	0x0D11, r24
     ad8:	24 c0       	rjmp	.+72     	; 0xb22 <__vector_16+0x156>
    } else if (interrupt_source & HAL_BAT_LOW_MASK) {
     ada:	97 ff       	sbrs	r25, 7
     adc:	1d c0       	rjmp	.+58     	; 0xb18 <__vector_16+0x14c>

        //Disable BAT_LOW interrupt to prevent interrupt storm. The interrupt 
        //will continously be signaled when the supply voltage is less than the 
        //user defined voltage threshold.
        uint8_t trx_isr_mask = hal_register_read( RG_IRQ_MASK );
     ade:	8e e0       	ldi	r24, 0x0E	; 14
     ae0:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
     ae4:	98 2f       	mov	r25, r24
void hal_register_write( uint8_t address, uint8_t value ){
                                       
    //Add the Register Write command to the address.
    address = HAL_TRX_CMD_RW | (HAL_TRX_CMD_RADDRM & address);
    
    AVR_ENTER_CRITICAL_REGION( );    
     ae6:	8f b7       	in	r24, 0x3f	; 63
     ae8:	89 83       	std	Y+1, r24	; 0x01
     aea:	f8 94       	cli
    
    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
     aec:	28 98       	cbi	0x05, 0	; 5
    
    /*Send Register address and write register content.*/
    SPDR = address;
     aee:	8e ec       	ldi	r24, 0xCE	; 206
     af0:	8e bd       	out	0x2e, r24	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     af2:	0d b4       	in	r0, 0x2d	; 45
     af4:	07 fe       	sbrs	r0, 7
     af6:	fd cf       	rjmp	.-6      	; 0xaf2 <__vector_16+0x126>
    uint8_t dummy_read = SPDR;
     af8:	8e b5       	in	r24, 0x2e	; 46

        //Disable BAT_LOW interrupt to prevent interrupt storm. The interrupt 
        //will continously be signaled when the supply voltage is less than the 
        //user defined voltage threshold.
        uint8_t trx_isr_mask = hal_register_read( RG_IRQ_MASK );
        trx_isr_mask &= ~HAL_BAT_LOW_MASK;
     afa:	9f 77       	andi	r25, 0x7F	; 127
    /*Send Register address and write register content.*/
    SPDR = address;
    while ((SPSR & (1 << SPIF)) == 0) {;}
    uint8_t dummy_read = SPDR;
    
    SPDR = value;
     afc:	9e bd       	out	0x2e, r25	; 46
    while ((SPSR & (1 << SPIF)) == 0) {;}
     afe:	0d b4       	in	r0, 0x2d	; 45
     b00:	07 fe       	sbrs	r0, 7
     b02:	fd cf       	rjmp	.-6      	; 0xafe <__vector_16+0x132>
    dummy_read = SPDR;
     b04:	8e b5       	in	r24, 0x2e	; 46
    
    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Slect High.
     b06:	28 9a       	sbi	0x05, 0	; 5
    
    AVR_LEAVE_CRITICAL_REGION( );
     b08:	89 81       	ldd	r24, Y+1	; 0x01
     b0a:	8f bf       	out	0x3f, r24	; 63
        //will continously be signaled when the supply voltage is less than the 
        //user defined voltage threshold.
        uint8_t trx_isr_mask = hal_register_read( RG_IRQ_MASK );
        trx_isr_mask &= ~HAL_BAT_LOW_MASK;
        hal_register_write( RG_IRQ_MASK, trx_isr_mask );
        hal_bat_low_flag++; //Increment BAT_LOW flag.
     b0c:	80 91 0b 0d 	lds	r24, 0x0D0B
     b10:	8f 5f       	subi	r24, 0xFF	; 255
     b12:	80 93 0b 0d 	sts	0x0D0B, r24
     b16:	05 c0       	rjmp	.+10     	; 0xb22 <__vector_16+0x156>
    } else {
        hal_unknown_isr_flag++;  //Increment UNKNOWN_ISR flag.
     b18:	80 91 0f 0d 	lds	r24, 0x0D0F
     b1c:	8f 5f       	subi	r24, 0xFF	; 255
     b1e:	80 93 0f 0d 	sts	0x0D0F, r24
    } 
}
     b22:	0f 90       	pop	r0
     b24:	cf 91       	pop	r28
     b26:	df 91       	pop	r29
     b28:	ff 91       	pop	r31
     b2a:	ef 91       	pop	r30
     b2c:	bf 91       	pop	r27
     b2e:	af 91       	pop	r26
     b30:	9f 91       	pop	r25
     b32:	8f 91       	pop	r24
     b34:	7f 91       	pop	r23
     b36:	6f 91       	pop	r22
     b38:	5f 91       	pop	r21
     b3a:	4f 91       	pop	r20
     b3c:	3f 91       	pop	r19
     b3e:	2f 91       	pop	r18
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	0f 90       	pop	r0
     b46:	0b be       	out	0x3b, r0	; 59
     b48:	0f 90       	pop	r0
     b4a:	0f be       	out	0x3f, r0	; 63
     b4c:	0f 90       	pop	r0
     b4e:	1f 90       	pop	r1
     b50:	18 95       	reti

00000b52 <sal_init>:
 * For chips with SPI, this function is empty.
 *
 */
void sal_init(void)
{
}
     b52:	08 95       	ret

00000b54 <sal_aes_read>:
 * of a series of sal_aes_wrrd() calls.
 *
 * @param[out] data     - result of previous operation
 */
void sal_aes_read(uint8_t *data)
{
     b54:	ac 01       	movw	r20, r24
    hal_sram_read(AES_STATE_KEY, AES_BLOCKSIZE, data);
     b56:	84 e8       	ldi	r24, 0x84	; 132
     b58:	60 e1       	ldi	r22, 0x10	; 16
     b5a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <hal_sram_read>
}
     b5e:	08 95       	ret

00000b60 <sal_aes_wrrd>:
 * @param[in]  idata  AES block to be en/decrypted
 * @param[out] odata  Result of previous operation
 *                    (odata may be NULL or equal to idata)
 */
void sal_aes_wrrd(uint8_t *idata, uint8_t *odata)
{
     b60:	1f 93       	push	r17
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
     b66:	eb 01       	movw	r28, r22
     * Write data and start the operation.
     * AES_MODE in aes_buf[0] and aes_buf[AES_BLOCKSIZE+1] as well as
     * AES_REQUEST in aes_buf[AES_BLOCKSIZE+1]
     * were set before in sal_aes_setup()
     */
    memcpy(aes_buf+1, idata, AES_BLOCKSIZE);
     b68:	a9 e1       	ldi	r26, 0x19	; 25
     b6a:	bd e0       	ldi	r27, 0x0D	; 13
     b6c:	fc 01       	movw	r30, r24
     b6e:	80 e1       	ldi	r24, 0x10	; 16
     b70:	01 90       	ld	r0, Z+
     b72:	0d 92       	st	X+, r0
     b74:	81 50       	subi	r24, 0x01	; 1
     b76:	e1 f7       	brne	.-8      	; 0xb70 <sal_aes_wrrd+0x10>

    /* pal_trx_aes_wrrd() overwrites aes_buf, the last byte must be saved. */
    save_cmd = aes_buf[AES_BLOCKSIZE+1];
     b78:	10 91 29 0d 	lds	r17, 0x0D29

    if (setup_flag)
     b7c:	80 91 17 0d 	lds	r24, 0x0D17
     b80:	88 23       	and	r24, r24
     b82:	49 f0       	breq	.+18     	; 0xb96 <sal_aes_wrrd+0x36>
    {
        hal_trx_aes_wrrd(AES_CON, aes_buf, AES_BLOCKSIZE+2);
     b84:	83 e8       	ldi	r24, 0x83	; 131
     b86:	68 e1       	ldi	r22, 0x18	; 24
     b88:	7d e0       	ldi	r23, 0x0D	; 13
     b8a:	42 e1       	ldi	r20, 0x12	; 18
     b8c:	0e 94 3c 04 	call	0x878	; 0x878 <hal_trx_aes_wrrd>
        setup_flag = false;
     b90:	10 92 17 0d 	sts	0x0D17, r1
     b94:	06 c0       	rjmp	.+12     	; 0xba2 <sal_aes_wrrd+0x42>
    }
    else
    {
        hal_trx_aes_wrrd(AES_STATE_KEY, aes_buf+1, AES_BLOCKSIZE+1);
     b96:	84 e8       	ldi	r24, 0x84	; 132
     b98:	69 e1       	ldi	r22, 0x19	; 25
     b9a:	7d e0       	ldi	r23, 0x0D	; 13
     b9c:	41 e1       	ldi	r20, 0x11	; 17
     b9e:	0e 94 3c 04 	call	0x878	; 0x878 <hal_trx_aes_wrrd>
    }

    /* Restore the result. */
    if (odata != NULL)
     ba2:	20 97       	sbiw	r28, 0x00	; 0
     ba4:	41 f0       	breq	.+16     	; 0xbb6 <sal_aes_wrrd+0x56>
    {
        memcpy(odata, aes_buf+1, AES_BLOCKSIZE);
     ba6:	de 01       	movw	r26, r28
     ba8:	e9 e1       	ldi	r30, 0x19	; 25
     baa:	fd e0       	ldi	r31, 0x0D	; 13
     bac:	80 e1       	ldi	r24, 0x10	; 16
     bae:	01 90       	ld	r0, Z+
     bb0:	0d 92       	st	X+, r0
     bb2:	81 50       	subi	r24, 0x01	; 1
     bb4:	e1 f7       	brne	.-8      	; 0xbae <sal_aes_wrrd+0x4e>
    }

    aes_buf[AES_BLOCKSIZE+1] = save_cmd;
     bb6:	10 93 29 0d 	sts	0x0D29, r17
     bba:	8a e3       	ldi	r24, 0x3A	; 58
     bbc:	8a 95       	dec	r24
     bbe:	f1 f7       	brne	.-4      	; 0xbbc <sal_aes_wrrd+0x5c>

    /* Wait for the operation to finish for 24 us. */
    delay_us(24);
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	1f 91       	pop	r17
     bc6:	08 95       	ret

00000bc8 <sal_aes_restart>:
 * When using sal_aes_wrrd(), call sal_aes_read() to get the result
 * of the last AES operation BEFORE you put the transceiver unit to
 * sleep state!
 */
void sal_aes_restart(void)
{
     bc8:	1f 93       	push	r17
    uint8_t *keyp;
    uint8_t save_cmd;

    if (last_dir == AES_DIR_ENCRYPT)
     bca:	80 91 11 02 	lds	r24, 0x0211
     bce:	88 23       	and	r24, r24
     bd0:	19 f0       	breq	.+6      	; 0xbd8 <sal_aes_restart+0x10>
     bd2:	2a e3       	ldi	r18, 0x3A	; 58
     bd4:	3d e0       	ldi	r19, 0x0D	; 13
     bd6:	02 c0       	rjmp	.+4      	; 0xbdc <sal_aes_restart+0x14>
     bd8:	2a e2       	ldi	r18, 0x2A	; 42
     bda:	3d e0       	ldi	r19, 0x0D	; 13
    else
    {
        keyp = dec_key;
    }

    save_cmd = aes_buf[0];
     bdc:	10 91 18 0d 	lds	r17, 0x0D18
    aes_buf[0] = AES_MODE_KEY;
     be0:	80 e1       	ldi	r24, 0x10	; 16
     be2:	80 93 18 0d 	sts	0x0D18, r24

    /* Fill in key. */
    memcpy(aes_buf+1, keyp, AES_KEYSIZE);
     be6:	a9 e1       	ldi	r26, 0x19	; 25
     be8:	bd e0       	ldi	r27, 0x0D	; 13
     bea:	f9 01       	movw	r30, r18
     bec:	01 90       	ld	r0, Z+
     bee:	0d 92       	st	X+, r0
     bf0:	81 50       	subi	r24, 0x01	; 1
     bf2:	e1 f7       	brne	.-8      	; 0xbec <sal_aes_restart+0x24>

    /* Write to SRAM in one step. */
    hal_sram_write(AES_CON, AES_BLOCKSIZE+1, aes_buf);
     bf4:	83 e8       	ldi	r24, 0x83	; 131
     bf6:	61 e1       	ldi	r22, 0x11	; 17
     bf8:	48 e1       	ldi	r20, 0x18	; 24
     bfa:	5d e0       	ldi	r21, 0x0D	; 13
     bfc:	0e 94 17 04 	call	0x82e	; 0x82e <hal_sram_write>

    aes_buf[0] = save_cmd;
     c00:	10 93 18 0d 	sts	0x0D18, r17
    setup_flag = true;
     c04:	81 e0       	ldi	r24, 0x01	; 1
     c06:	80 93 17 0d 	sts	0x0D17, r24
}
     c0a:	1f 91       	pop	r17
     c0c:	08 95       	ret

00000c0e <sal_aes_setup>:
 * @return  False if some parameter was illegal, true else
 */
bool sal_aes_setup(uint8_t *key,
                   uint8_t enc_mode,
                   uint8_t dir)
{
     c0e:	ff 92       	push	r15
     c10:	0f 93       	push	r16
     c12:	1f 93       	push	r17
     c14:	df 93       	push	r29
     c16:	cf 93       	push	r28
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	60 97       	sbiw	r28, 0x10	; 16
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	de bf       	out	0x3e, r29	; 62
     c24:	0f be       	out	0x3f, r0	; 63
     c26:	cd bf       	out	0x3d, r28	; 61
     c28:	9c 01       	movw	r18, r24
     c2a:	f6 2e       	mov	r15, r22
     c2c:	04 2f       	mov	r16, r20
    if (key != NULL)
     c2e:	00 97       	sbiw	r24, 0x00	; 0
     c30:	e9 f0       	breq	.+58     	; 0xc6c <sal_aes_setup+0x5e>
    {
        /* Setup key. */
        dec_initialized = false;
     c32:	10 92 16 0d 	sts	0x0D16, r1

        last_dir = AES_DIR_VOID;
     c36:	89 e0       	ldi	r24, 0x09	; 9
     c38:	80 93 11 02 	sts	0x0211, r24

        /* Save key for later use after decryption or sleep. */
        memcpy(enc_key, key, AES_KEYSIZE);
     c3c:	aa e2       	ldi	r26, 0x2A	; 42
     c3e:	bd e0       	ldi	r27, 0x0D	; 13
     c40:	f9 01       	movw	r30, r18
     c42:	80 e1       	ldi	r24, 0x10	; 16
     c44:	01 90       	ld	r0, Z+
     c46:	0d 92       	st	X+, r0
     c48:	81 50       	subi	r24, 0x01	; 1
     c4a:	e1 f7       	brne	.-8      	; 0xc44 <sal_aes_setup+0x36>

        /* Set subregister AES_MODE (Bits 4:6 in AES_CON) to 1: KEY SETUP. */
        aes_buf[0] = AES_MODE_KEY;
     c4c:	80 e1       	ldi	r24, 0x10	; 16
     c4e:	80 93 18 0d 	sts	0x0D18, r24

        /* Fill in key. */
        memcpy(aes_buf+1, key, AES_KEYSIZE);
     c52:	a9 e1       	ldi	r26, 0x19	; 25
     c54:	bd e0       	ldi	r27, 0x0D	; 13
     c56:	f9 01       	movw	r30, r18
     c58:	01 90       	ld	r0, Z+
     c5a:	0d 92       	st	X+, r0
     c5c:	81 50       	subi	r24, 0x01	; 1
     c5e:	e1 f7       	brne	.-8      	; 0xc58 <sal_aes_setup+0x4a>

        /* Write to SRAM in one step. */
        hal_sram_write(AES_CON, AES_BLOCKSIZE+1, aes_buf);
     c60:	83 e8       	ldi	r24, 0x83	; 131
     c62:	61 e1       	ldi	r22, 0x11	; 17
     c64:	48 e1       	ldi	r20, 0x18	; 24
     c66:	5d e0       	ldi	r21, 0x0D	; 13
     c68:	0e 94 17 04 	call	0x82e	; 0x82e <hal_sram_write>
    }

    /* Set encryption direction. */
    switch(dir)
     c6c:	00 23       	and	r16, r16
     c6e:	21 f0       	breq	.+8      	; 0xc78 <sal_aes_setup+0x6a>
     c70:	08 30       	cpi	r16, 0x08	; 8
     c72:	09 f0       	breq	.+2      	; 0xc76 <sal_aes_setup+0x68>
     c74:	63 c0       	rjmp	.+198    	; 0xd3c <sal_aes_setup+0x12e>
     c76:	17 c0       	rjmp	.+46     	; 0xca6 <sal_aes_setup+0x98>
    {
        case AES_DIR_ENCRYPT:
            if (last_dir == AES_DIR_DECRYPT)
     c78:	80 91 11 02 	lds	r24, 0x0211
     c7c:	88 30       	cpi	r24, 0x08	; 8
     c7e:	09 f0       	breq	.+2      	; 0xc82 <sal_aes_setup+0x74>
     c80:	4b c0       	rjmp	.+150    	; 0xd18 <sal_aes_setup+0x10a>
            {
                /*
                 * If the last operation was decryption, the encryption
                 * key must be stored in enc_key, so re-initialize it.
                 */
                aes_buf[0] = AES_MODE_KEY;
     c82:	80 e1       	ldi	r24, 0x10	; 16
     c84:	80 93 18 0d 	sts	0x0D18, r24

                /* Fill in key. */
                memcpy(aes_buf+1, enc_key, AES_KEYSIZE);
     c88:	a9 e1       	ldi	r26, 0x19	; 25
     c8a:	bd e0       	ldi	r27, 0x0D	; 13
     c8c:	ea e2       	ldi	r30, 0x2A	; 42
     c8e:	fd e0       	ldi	r31, 0x0D	; 13
     c90:	01 90       	ld	r0, Z+
     c92:	0d 92       	st	X+, r0
     c94:	81 50       	subi	r24, 0x01	; 1
     c96:	e1 f7       	brne	.-8      	; 0xc90 <sal_aes_setup+0x82>

                /* Write to SRAM in one step. */
                hal_sram_write(AES_CON, AES_BLOCKSIZE+1, aes_buf);
     c98:	83 e8       	ldi	r24, 0x83	; 131
     c9a:	61 e1       	ldi	r22, 0x11	; 17
     c9c:	48 e1       	ldi	r20, 0x18	; 24
     c9e:	5d e0       	ldi	r21, 0x0D	; 13
     ca0:	0e 94 17 04 	call	0x82e	; 0x82e <hal_sram_write>
     ca4:	39 c0       	rjmp	.+114    	; 0xd18 <sal_aes_setup+0x10a>
            }
            break;

        case AES_DIR_DECRYPT:
            if (last_dir != AES_DIR_DECRYPT)
     ca6:	80 91 11 02 	lds	r24, 0x0211
     caa:	88 30       	cpi	r24, 0x08	; 8
     cac:	a9 f1       	breq	.+106    	; 0xd18 <sal_aes_setup+0x10a>
            {
                aes_buf[0] = AES_MODE_KEY;
     cae:	10 e1       	ldi	r17, 0x10	; 16
     cb0:	10 93 18 0d 	sts	0x0D18, r17

                if (!dec_initialized)
     cb4:	80 91 16 0d 	lds	r24, 0x0D16
     cb8:	88 23       	and	r24, r24
     cba:	e1 f4       	brne	.+56     	; 0xcf4 <sal_aes_setup+0xe6>
                    uint8_t dummy[AES_BLOCKSIZE];

                    /* Compute decryption key and initialize unit with it. */

                    /* Dummy ECB encryption. */
                    aes_buf[0] = AES_MODE_ECB;
     cbc:	10 92 18 0d 	sts	0x0D18, r1
                    aes_buf[AES_BLOCKSIZE+1] = AES_MODE_ECB | AES_REQUEST;
     cc0:	80 e8       	ldi	r24, 0x80	; 128
     cc2:	80 93 29 0d 	sts	0x0D29, r24
                    setup_flag = true;  /* Needed in sal_aes_wrrd(). */
     cc6:	81 e0       	ldi	r24, 0x01	; 1
     cc8:	80 93 17 0d 	sts	0x0D17, r24
                    sal_aes_wrrd(dummy, NULL);
     ccc:	ce 01       	movw	r24, r28
     cce:	01 96       	adiw	r24, 0x01	; 1
     cd0:	60 e0       	ldi	r22, 0x00	; 0
     cd2:	70 e0       	ldi	r23, 0x00	; 0
     cd4:	0e 94 b0 05 	call	0xb60	; 0xb60 <sal_aes_wrrd>

                    /* Read last round key: */

                    /* Set to key mode. */
                    aes_buf[0] = AES_MODE_KEY;
     cd8:	10 93 18 0d 	sts	0x0D18, r17
                    hal_sram_write(AES_CON, 1, aes_buf);
     cdc:	83 e8       	ldi	r24, 0x83	; 131
     cde:	61 e0       	ldi	r22, 0x01	; 1
     ce0:	48 e1       	ldi	r20, 0x18	; 24
     ce2:	5d e0       	ldi	r21, 0x0D	; 13
     ce4:	0e 94 17 04 	call	0x82e	; 0x82e <hal_sram_write>

                    /* Read the key. */
                    hal_sram_read(AES_STATE_KEY, AES_KEYSIZE, dec_key);
     ce8:	84 e8       	ldi	r24, 0x84	; 132
     cea:	60 e1       	ldi	r22, 0x10	; 16
     cec:	4a e3       	ldi	r20, 0x3A	; 58
     cee:	5d e0       	ldi	r21, 0x0D	; 13
     cf0:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <hal_sram_read>
                 * simply re-initialize the unit;
                 * aes_buf[0] is AES_MODE_KEY
                 */

                /* Fill in key. */
                memcpy(aes_buf+1, dec_key, AES_KEYSIZE);
     cf4:	a9 e1       	ldi	r26, 0x19	; 25
     cf6:	bd e0       	ldi	r27, 0x0D	; 13
     cf8:	ea e3       	ldi	r30, 0x3A	; 58
     cfa:	fd e0       	ldi	r31, 0x0D	; 13
     cfc:	80 e1       	ldi	r24, 0x10	; 16
     cfe:	01 90       	ld	r0, Z+
     d00:	0d 92       	st	X+, r0
     d02:	81 50       	subi	r24, 0x01	; 1
     d04:	e1 f7       	brne	.-8      	; 0xcfe <sal_aes_setup+0xf0>

                /* Write to SRAM in one step. */
                hal_sram_write(AES_CON, AES_BLOCKSIZE+1, aes_buf);
     d06:	83 e8       	ldi	r24, 0x83	; 131
     d08:	61 e1       	ldi	r22, 0x11	; 17
     d0a:	48 e1       	ldi	r20, 0x18	; 24
     d0c:	5d e0       	ldi	r21, 0x0D	; 13
     d0e:	0e 94 17 04 	call	0x82e	; 0x82e <hal_sram_write>

                dec_initialized = true;
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	80 93 16 0d 	sts	0x0D16, r24

        default:
            return false;
    }

    last_dir = dir;
     d18:	00 93 11 02 	sts	0x0211, r16

    /* Set encryption mode. */
    switch(enc_mode)
     d1c:	ff 20       	and	r15, r15
     d1e:	19 f0       	breq	.+6      	; 0xd26 <sal_aes_setup+0x118>
     d20:	80 e2       	ldi	r24, 0x20	; 32
     d22:	f8 16       	cp	r15, r24
     d24:	59 f4       	brne	.+22     	; 0xd3c <sal_aes_setup+0x12e>
    {
        case AES_MODE_ECB:
        case AES_MODE_CBC:
            {
                aes_buf[0] = enc_mode | dir;
     d26:	80 2f       	mov	r24, r16
     d28:	8f 29       	or	r24, r15
     d2a:	80 93 18 0d 	sts	0x0D18, r24
                aes_buf[AES_BLOCKSIZE+1] = enc_mode | dir | AES_REQUEST;
     d2e:	80 68       	ori	r24, 0x80	; 128
     d30:	80 93 29 0d 	sts	0x0D29, r24

        default:
            return (false);
    }

    setup_flag = true;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	80 93 17 0d 	sts	0x0D17, r24
     d3a:	01 c0       	rjmp	.+2      	; 0xd3e <sal_aes_setup+0x130>

    return (true);
     d3c:	80 e0       	ldi	r24, 0x00	; 0
}
     d3e:	60 96       	adiw	r28, 0x10	; 16
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	de bf       	out	0x3e, r29	; 62
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	cd bf       	out	0x3d, r28	; 61
     d4a:	cf 91       	pop	r28
     d4c:	df 91       	pop	r29
     d4e:	1f 91       	pop	r17
     d50:	0f 91       	pop	r16
     d52:	ff 90       	pop	r15
     d54:	08 95       	ret

00000d56 <tat_get_device_role>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_device_role( void )
{
	return hal_subregister_read( SR_I_AM_COORD);
     d56:	8e e2       	ldi	r24, 0x2E	; 46
     d58:	68 e0       	ldi	r22, 0x08	; 8
     d5a:	43 e0       	ldi	r20, 0x03	; 3
     d5c:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     d60:	08 95       	ret

00000d62 <trx_reset>:
 *          the radio transceiver.
 *
 *  \ingroup tat
 */
retval_t trx_reset(void)//R212 Modify
{
     d62:	1f 93       	push	r17
    tal_trx_status_t trx_status;
    uint8_t poll_counter = 0;

    /* trx might sleep, so wake it up */
    hal_set_rst_low( );
     d64:	2d 98       	cbi	0x05, 5	; 5
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     d66:	8a eb       	ldi	r24, 0xBA	; 186
     d68:	91 e0       	ldi	r25, 0x01	; 1
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	f1 f7       	brne	.-4      	; 0xd6a <trx_reset+0x8>
    delay_us(SLEEP_TO_TRX_OFF_US);

    /* Apply reset pulse */
    hal_set_rst_low( );
     d6e:	2d 98       	cbi	0x05, 5	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     d70:	82 e0       	ldi	r24, 0x02	; 2
     d72:	8a 95       	dec	r24
     d74:	f1 f7       	brne	.-4      	; 0xd72 <trx_reset+0x10>
    delay_us(RST_PULSE_WIDTH_US);
    hal_set_rst_high( );
     d76:	2d 9a       	sbi	0x05, 5	; 5
     d78:	10 e0       	ldi	r17, 0x00	; 0

    /* verify that trx has reached TRX_OFF */
    do
    {
        trx_status = (tal_trx_status_t)hal_subregister_read(SR_TRX_STATUS);
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	6f e1       	ldi	r22, 0x1F	; 31
     d7e:	40 e0       	ldi	r20, 0x00	; 0
     d80:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
        poll_counter++;
     d84:	1f 5f       	subi	r17, 0xFF	; 255
        if (poll_counter > 10)
     d86:	1b 30       	cpi	r17, 0x0B	; 11
     d88:	11 f4       	brne	.+4      	; 0xd8e <trx_reset+0x2c>
     d8a:	85 e8       	ldi	r24, 0x85	; 133
     d8c:	05 c0       	rjmp	.+10     	; 0xd98 <trx_reset+0x36>
        {
            return FAILURE;
        }
    } while (trx_status != TRX_OFF);
     d8e:	88 30       	cpi	r24, 0x08	; 8
     d90:	a1 f7       	brne	.-24     	; 0xd7a <trx_reset+0x18>

    tal_trx_status = TRX_OFF;
     d92:	80 93 04 14 	sts	0x1404, r24
     d96:	80 e0       	ldi	r24, 0x00	; 0

    // Write 16MHz xtal trim value to trx.
    // It's only necessary if it differs from the reset value.

    return SUCCESS;
}
     d98:	1f 91       	pop	r17
     d9a:	08 95       	ret

00000d9c <tat_get_trx_state>:
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	6f e1       	ldi	r22, 0x1F	; 31
     da0:	40 e0       	ldi	r20, 0x00	; 0
     da2:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     da6:	08 95       	ret

00000da8 <tat_send_data_with_retry>:
 *
 *  \ingroup tat
 */
__x tat_status_t tat_send_data_with_retry( uint8_t frame_length, uint8_t *frame, 
                                       uint8_t retries )
{ 
     da8:	0f 93       	push	r16
     daa:	1f 93       	push	r17
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	08 2f       	mov	r16, r24
     db2:	eb 01       	movw	r28, r22
     db4:	14 2f       	mov	r17, r20
     db6:	88 ee       	ldi	r24, 0xE8	; 232
     db8:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     dba:	28 eb       	ldi	r18, 0xB8	; 184
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	f9 01       	movw	r30, r18
     dc0:	31 97       	sbiw	r30, 0x01	; 1
     dc2:	f1 f7       	brne	.-4      	; 0xdc0 <tat_send_data_with_retry+0x18>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dc4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     dc6:	d9 f7       	brne	.-10     	; 0xdbe <tat_send_data_with_retry+0x16>
	delay_ms(100);//修改过
	tat_status_t task_status = TAT_CHANNEL_ACCESS_FAILURE;          
	/*Do sanity check on function parameters and current state.*/
	if ((frame_length > RF212_MAX_TX_FRAME_LENGTH) || 
     dc8:	80 2f       	mov	r24, r16
     dca:	85 50       	subi	r24, 0x05	; 5
     dcc:	8b 37       	cpi	r24, 0x7B	; 123
     dce:	10 f0       	brcs	.+4      	; 0xdd4 <tat_send_data_with_retry+0x2c>
     dd0:	82 e4       	ldi	r24, 0x42	; 66
     dd2:	31 c0       	rjmp	.+98     	; 0xe36 <tat_send_data_with_retry+0x8e>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     dd4:	81 e0       	ldi	r24, 0x01	; 1
     dd6:	6f e1       	ldi	r22, 0x1F	; 31
     dd8:	40 e0       	ldi	r20, 0x00	; 0
     dda:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	if ((frame_length > RF212_MAX_TX_FRAME_LENGTH) || 
	(frame_length < TAT_MIN_IEEE_FRAME_LENGTH)) 
	{ 
		return TAT_INVALID_ARGUMENT; 
	}
	if (tat_get_trx_state( ) != TX_ARET_ON) 
     dde:	89 31       	cpi	r24, 0x19	; 25
     de0:	11 f0       	breq	.+4      	; 0xde6 <tat_send_data_with_retry+0x3e>
     de2:	84 e4       	ldi	r24, 0x44	; 68
     de4:	28 c0       	rjmp	.+80     	; 0xe36 <tat_send_data_with_retry+0x8e>
	{ 
		return TAT_WRONG_STATE;
	}
	hal_clear_trx_end_flag( );
     de6:	0e 94 4e 02 	call	0x49c	; 0x49c <hal_clear_trx_end_flag>
	/*Do initial frame transmission.*/
	hal_set_slptr_high( );
     dea:	2c 9a       	sbi	0x05, 4	; 5
	hal_set_slptr_low( );
     dec:	2c 98       	cbi	0x05, 4	; 5
	hal_frame_write( frame, frame_length ); //Then write data to the frame buffer.
     dee:	ce 01       	movw	r24, r28
     df0:	60 2f       	mov	r22, r16
     df2:	0e 94 cb 03 	call	0x796	; 0x796 <hal_frame_write>
	bool retry = false; // Variable used to control the retry loop.
	/*Do retry if requested.*/
	do{
	//Wait for TRX_END interrupt.
		while (hal_get_trx_end_flag( ) == 0) {;}
     df6:	0e 94 4b 02 	call	0x496	; 0x496 <hal_get_trx_end_flag>
     dfa:	88 23       	and	r24, r24
     dfc:	e1 f3       	breq	.-8      	; 0xdf6 <tat_send_data_with_retry+0x4e>
	//Check status.
		uint8_t transaction_status = hal_subregister_read( SR_TRAC_STATUS );
     dfe:	82 e0       	ldi	r24, 0x02	; 2
     e00:	60 ee       	ldi	r22, 0xE0	; 224
     e02:	45 e0       	ldi	r20, 0x05	; 5
     e04:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	//Check for failure.
		if ((transaction_status != TAT_TRANSMISSION_SUCCESS)) 
     e08:	88 23       	and	r24, r24
     e0a:	a1 f0       	breq	.+40     	; 0xe34 <tat_send_data_with_retry+0x8c>
		{
			if (transaction_status == TAT_BUSY_CHANNEL) 
     e0c:	83 30       	cpi	r24, 0x03	; 3
     e0e:	11 f0       	breq	.+4      	; 0xe14 <tat_send_data_with_retry+0x6c>
     e10:	8e e4       	ldi	r24, 0x4E	; 78
     e12:	01 c0       	rjmp	.+2      	; 0xe16 <tat_send_data_with_retry+0x6e>
     e14:	8d e4       	ldi	r24, 0x4D	; 77
			} 
			else
			{
				task_status = TAT_NO_ACK;
			}
			if ((retries--) > 0)
     e16:	11 23       	and	r17, r17
     e18:	71 f0       	breq	.+28     	; 0xe36 <tat_send_data_with_retry+0x8e>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	6f e1       	ldi	r22, 0x1F	; 31
     e1e:	40 e0       	ldi	r20, 0x00	; 0
     e20:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
			}
			if ((retries--) > 0)
			{
				retry = true;
				//Wait for the TRX to go back to TX_ARET_ON.
				while (tat_get_trx_state() != TX_ARET_ON) {;}
     e24:	89 31       	cpi	r24, 0x19	; 25
     e26:	c9 f7       	brne	.-14     	; 0xe1a <tat_send_data_with_retry+0x72>
			} 
			else
			{
				task_status = TAT_NO_ACK;
			}
			if ((retries--) > 0)
     e28:	11 50       	subi	r17, 0x01	; 1
			{
				retry = true;
				//Wait for the TRX to go back to TX_ARET_ON.
				while (tat_get_trx_state() != TX_ARET_ON) {;}

				hal_clear_trx_end_flag( );
     e2a:	0e 94 4e 02 	call	0x49c	; 0x49c <hal_clear_trx_end_flag>
				hal_set_slptr_high( );
     e2e:	2c 9a       	sbi	0x05, 4	; 5
				hal_set_slptr_low( );
     e30:	2c 98       	cbi	0x05, 4	; 5
     e32:	e1 cf       	rjmp	.-62     	; 0xdf6 <tat_send_data_with_retry+0x4e>
     e34:	80 e4       	ldi	r24, 0x40	; 64
			task_status = TAT_SUCCESS;
			retry = false;            
		} // end: if ((transaction_status != TAT_TRANSMISSION_SUCCESS)) ...
	} while (retry == true);
	return task_status;                                       
}
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <tat_send_data>:
 *                          detected this error message will be returned.
 *
 *  \ingroup tat
 */
__x tat_status_t tat_send_data( uint8_t data_length, uint8_t *data )
{
     e40:	1f 93       	push	r17
     e42:	cf 93       	push	r28
     e44:	df 93       	push	r29
     e46:	18 2f       	mov	r17, r24
     e48:	eb 01       	movw	r28, r22
    
	/*Check function parameters and current state.*/
	if (data_length > RF212_MAX_TX_FRAME_LENGTH) 
     e4a:	87 ff       	sbrs	r24, 7
     e4c:	02 c0       	rjmp	.+4      	; 0xe52 <tat_send_data+0x12>
     e4e:	82 e4       	ldi	r24, 0x42	; 66
     e50:	10 c0       	rjmp	.+32     	; 0xe72 <tat_send_data+0x32>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     e52:	81 e0       	ldi	r24, 0x01	; 1
     e54:	6f e1       	ldi	r22, 0x1F	; 31
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	if (data_length > RF212_MAX_TX_FRAME_LENGTH) 
	{ 
		return TAT_INVALID_ARGUMENT; 
	}

	if ((tat_get_trx_state( ) != PLL_ON)) 
     e5c:	89 30       	cpi	r24, 0x09	; 9
     e5e:	11 f0       	breq	.+4      	; 0xe64 <tat_send_data+0x24>
     e60:	84 e4       	ldi	r24, 0x44	; 68
     e62:	07 c0       	rjmp	.+14     	; 0xe72 <tat_send_data+0x32>
		return TAT_WRONG_STATE;
	}

	/*Do frame transmission.*/
	//Toggle the SLP_TR pin to initiate the frame transmission.
	hal_set_slptr_high( );
     e64:	2c 9a       	sbi	0x05, 4	; 5
	hal_set_slptr_low( );
     e66:	2c 98       	cbi	0x05, 4	; 5

	hal_frame_write( data, data_length ); //Then write data to the frame buffer.
     e68:	ce 01       	movw	r24, r28
     e6a:	61 2f       	mov	r22, r17
     e6c:	0e 94 cb 03 	call	0x796	; 0x796 <hal_frame_write>
     e70:	80 e4       	ldi	r24, 0x40	; 64

	return TAT_SUCCESS; 
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	1f 91       	pop	r17
     e78:	08 95       	ret

00000e7a <tat_leave_sleep_mode>:
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
     e7a:	1c 99       	sbic	0x03, 4	; 3
     e7c:	12 c0       	rjmp	.+36     	; 0xea2 <tat_leave_sleep_mode+0x28>
     e7e:	0f c0       	rjmp	.+30     	; 0xe9e <tat_leave_sleep_mode+0x24>
     e80:	ca 01       	movw	r24, r20
     e82:	01 97       	sbiw	r24, 0x01	; 1
     e84:	f1 f7       	brne	.-4      	; 0xe82 <tat_leave_sleep_mode+0x8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e86:	21 50       	subi	r18, 0x01	; 1
     e88:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e8a:	d1 f7       	brne	.-12     	; 0xe80 <tat_leave_sleep_mode+0x6>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     e8c:	81 e0       	ldi	r24, 0x01	; 1
     e8e:	6f e1       	ldi	r22, 0x1F	; 31
     e90:	40 e0       	ldi	r20, 0x00	; 0
     e92:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	//delay_us( TIME_SLEEP_TO_TRX_OFF );
	delay_ms(50);
	tat_status_t leave_sleep_status = TAT_TIMED_OUT;

	//Ensure that the radio transceiver is in the TRX_OFF state.
	if (tat_get_trx_state( ) == TRX_OFF) 
     e96:	88 30       	cpi	r24, 0x08	; 8
     e98:	11 f0       	breq	.+4      	; 0xe9e <tat_leave_sleep_mode+0x24>
     e9a:	83 e4       	ldi	r24, 0x43	; 67
     e9c:	08 95       	ret
     e9e:	80 e4       	ldi	r24, 0x40	; 64
	{
		leave_sleep_status = TAT_SUCCESS;
	}

	return leave_sleep_status;
}
     ea0:	08 95       	ret
	if (is_sleeping( ) == false) 
	{ 
		return TAT_SUCCESS;
	}

	hal_set_slptr_low( );
     ea2:	2c 98       	cbi	0x05, 4	; 5
     ea4:	24 ef       	ldi	r18, 0xF4	; 244
     ea6:	31 e0       	ldi	r19, 0x01	; 1
     ea8:	48 eb       	ldi	r20, 0xB8	; 184
     eaa:	50 e0       	ldi	r21, 0x00	; 0
     eac:	e9 cf       	rjmp	.-46     	; 0xe80 <tat_leave_sleep_mode+0x6>

00000eae <tat_get_clock_speed>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_clock_speed( void )//R212 Modify
{
	return hal_subregister_read( SR_CLKM_CTRL );
     eae:	83 e0       	ldi	r24, 0x03	; 3
     eb0:	67 e0       	ldi	r22, 0x07	; 7
     eb2:	40 e0       	ldi	r20, 0x00	; 0
     eb4:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     eb8:	08 95       	ret

00000eba <tat_batmon_get_status>:
tat_status_t tat_batmon_get_status( void )
{
    
	tat_status_t batmon_status = TAT_BAT_LOW;

	if (hal_subregister_read( SR_BATMON_OK ) != BATTERY_MONITOR_VOLTAGE_UNDER_THRESHOLD) 
     eba:	81 e1       	ldi	r24, 0x11	; 17
     ebc:	60 e2       	ldi	r22, 0x20	; 32
     ebe:	45 e0       	ldi	r20, 0x05	; 5
     ec0:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
     ec4:	88 23       	and	r24, r24
     ec6:	11 f0       	breq	.+4      	; 0xecc <tat_batmon_get_status+0x12>
     ec8:	8b e4       	ldi	r24, 0x4B	; 75
     eca:	08 95       	ret
     ecc:	8a e4       	ldi	r24, 0x4A	; 74
	{
		batmon_status = TAT_BAT_OK;
	}

	return batmon_status;
}
     ece:	08 95       	ret

00000ed0 <tat_batmon_get_voltage_range>:
 *
 *  \ingroup tat
 */
uint8_t tat_batmon_get_voltage_range( void )
{
	return hal_subregister_read( SR_BATMON_HR );
     ed0:	81 e1       	ldi	r24, 0x11	; 17
     ed2:	60 e1       	ldi	r22, 0x10	; 16
     ed4:	44 e0       	ldi	r20, 0x04	; 4
     ed6:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     eda:	08 95       	ret

00000edc <tat_batmon_get_voltage_threshold>:
 *
 *  \ingroup tat
 */
uint8_t tat_batmon_get_voltage_threshold( void )
{
	return hal_subregister_read( SR_BATMON_VTH );
     edc:	81 e1       	ldi	r24, 0x11	; 17
     ede:	6f e0       	ldi	r22, 0x0F	; 15
     ee0:	40 e0       	ldi	r20, 0x00	; 0
     ee2:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     ee6:	08 95       	ret

00000ee8 <tat_get_rssi_value>:
 *  \retval TAT_WRONG_STATE The radio transceiver is not in RX_ON or BUSY_RX.
 *
 *  \ingroup tat
 */
tat_status_t tat_get_rssi_value( uint8_t *rssi )
{
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	ec 01       	movw	r28, r24
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	6f e1       	ldi	r22, 0x1F	; 31
     ef2:	40 e0       	ldi	r20, 0x00	; 0
     ef4:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
    
	uint8_t current_state = tat_get_trx_state( );
	tat_status_t retval = TAT_WRONG_STATE;

	/*The RSSI measurement should only be done in RX_ON or BUSY_RX.*/
	if ((current_state == RX_ON) || (current_state == BUSY_RX)) 
     ef8:	86 30       	cpi	r24, 0x06	; 6
     efa:	21 f0       	breq	.+8      	; 0xf04 <tat_get_rssi_value+0x1c>
     efc:	81 30       	cpi	r24, 0x01	; 1
     efe:	11 f0       	breq	.+4      	; 0xf04 <tat_get_rssi_value+0x1c>
     f00:	84 e4       	ldi	r24, 0x44	; 68
     f02:	07 c0       	rjmp	.+14     	; 0xf12 <tat_get_rssi_value+0x2a>
	{        
		*rssi = hal_subregister_read( SR_RSSI );
     f04:	86 e0       	ldi	r24, 0x06	; 6
     f06:	6f e1       	ldi	r22, 0x1F	; 31
     f08:	40 e0       	ldi	r20, 0x00	; 0
     f0a:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
     f0e:	88 83       	st	Y, r24
     f10:	80 e4       	ldi	r24, 0x40	; 64
		retval = TAT_SUCCESS;
	}

	return retval;
}
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	08 95       	ret

00000f18 <tat_get_ed_threshold>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_ed_threshold( void )
{
	return hal_subregister_read( SR_CCA_ED_THRES );
     f18:	89 e0       	ldi	r24, 0x09	; 9
     f1a:	6f e0       	ldi	r22, 0x0F	; 15
     f1c:	40 e0       	ldi	r20, 0x00	; 0
     f1e:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     f22:	08 95       	ret

00000f24 <tat_get_cca_mode>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_cca_mode( void )
{           
	return hal_subregister_read( SR_CCA_MODE );
     f24:	88 e0       	ldi	r24, 0x08	; 8
     f26:	60 e6       	ldi	r22, 0x60	; 96
     f28:	45 e0       	ldi	r20, 0x05	; 5
     f2a:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
}
     f2e:	08 95       	ret

00000f30 <tat_set_device_role>:
	{
		hal_subregister_write( SR_I_AM_COORD, 0);
	} 
	else 
	{
		hal_subregister_write( SR_I_AM_COORD, 0);
     f30:	8e e2       	ldi	r24, 0x2E	; 46
     f32:	68 e0       	ldi	r22, 0x08	; 8
     f34:	43 e0       	ldi	r20, 0x03	; 3
     f36:	20 e0       	ldi	r18, 0x00	; 0
     f38:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
     f3c:	08 95       	ret

00000f3e <tat_use_auto_tx_crc>:
 *
 *  \ingroup tat
 */
void tat_use_auto_tx_crc( bool auto_crc_on )
{
	if (auto_crc_on == true) 
     f3e:	88 23       	and	r24, r24
     f40:	29 f0       	breq	.+10     	; 0xf4c <tat_use_auto_tx_crc+0xe>
	{
		hal_subregister_write( SR_TX_AUTO_CRC_ON, 1 );
     f42:	84 e0       	ldi	r24, 0x04	; 4
     f44:	60 e2       	ldi	r22, 0x20	; 32
     f46:	45 e0       	ldi	r20, 0x05	; 5
     f48:	21 e0       	ldi	r18, 0x01	; 1
     f4a:	04 c0       	rjmp	.+8      	; 0xf54 <tat_use_auto_tx_crc+0x16>
	} 
	else
	{
		hal_subregister_write( SR_TX_AUTO_CRC_ON, 0 );
     f4c:	84 e0       	ldi	r24, 0x04	; 4
     f4e:	60 e2       	ldi	r22, 0x20	; 32
     f50:	45 e0       	ldi	r20, 0x05	; 5
     f52:	20 e0       	ldi	r18, 0x00	; 0
     f54:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
     f58:	08 95       	ret

00000f5a <tat_reset_state_machine>:
 *
 *  \ingroup tat
 */
void tat_reset_state_machine( void )
{    
	hal_set_slptr_low( );
     f5a:	2c 98       	cbi	0x05, 4	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     f5c:	8e e0       	ldi	r24, 0x0E	; 14
     f5e:	8a 95       	dec	r24
     f60:	f1 f7       	brne	.-4      	; 0xf5e <tat_reset_state_machine+0x4>
	delay_us( TIME_NOCLK_TO_WAKE );
	hal_subregister_write( SR_TRX_CMD, CMD_FORCE_TRX_OFF );
     f62:	82 e0       	ldi	r24, 0x02	; 2
     f64:	6f e1       	ldi	r22, 0x1F	; 31
     f66:	40 e0       	ldi	r20, 0x00	; 0
     f68:	23 e0       	ldi	r18, 0x03	; 3
     f6a:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
     f6e:	82 e0       	ldi	r24, 0x02	; 2
     f70:	8a 95       	dec	r24
     f72:	f1 f7       	brne	.-4      	; 0xf70 <tat_reset_state_machine+0x16>
	delay_us( TIME_CMD_FORCE_TRX_OFF );
}
     f74:	08 95       	ret

00000f76 <tat_enter_sleep_mode>:
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
     f76:	1c 9b       	sbis	0x03, 4	; 3
     f78:	02 c0       	rjmp	.+4      	; 0xf7e <tat_enter_sleep_mode+0x8>
     f7a:	80 e4       	ldi	r24, 0x40	; 64
     f7c:	08 95       	ret
	if (is_sleeping( ) == true) 
	{ 
		return TAT_SUCCESS;
	}

	tat_reset_state_machine( ); //Force the device into TRX_OFF.
     f7e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <tat_reset_state_machine>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	6f e1       	ldi	r22, 0x1F	; 31
     f86:	40 e0       	ldi	r20, 0x00	; 0
     f88:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>

	tat_reset_state_machine( ); //Force the device into TRX_OFF.

	tat_status_t enter_sleep_status = TAT_TIMED_OUT;

	if (tat_get_trx_state( ) == TRX_OFF) 
     f8c:	88 30       	cpi	r24, 0x08	; 8
     f8e:	11 f0       	breq	.+4      	; 0xf94 <tat_enter_sleep_mode+0x1e>
     f90:	83 e4       	ldi	r24, 0x43	; 67
     f92:	08 95       	ret
	{
		//Enter Sleep.
		hal_set_slptr_high( );    
     f94:	2c 9a       	sbi	0x05, 4	; 5
     f96:	80 e4       	ldi	r24, 0x40	; 64
		enter_sleep_status = TAT_SUCCESS;
	}
	return enter_sleep_status;  
}
     f98:	08 95       	ret

00000f9a <set_trx_state>:
 *
 *  \ingroup tat
 */
 
tat_status_t set_trx_state( uint8_t new_state )
{
     f9a:	0f 93       	push	r16
     f9c:	1f 93       	push	r17
     f9e:	08 2f       	mov	r16, r24

	if (!((new_state == TRX_OFF ) || (new_state == RX_ON) || (new_state == PLL_ON) || 
     fa0:	88 30       	cpi	r24, 0x08	; 8
     fa2:	51 f0       	breq	.+20     	; 0xfb8 <set_trx_state+0x1e>
     fa4:	86 30       	cpi	r24, 0x06	; 6
     fa6:	41 f0       	breq	.+16     	; 0xfb8 <set_trx_state+0x1e>
     fa8:	89 30       	cpi	r24, 0x09	; 9
     faa:	31 f0       	breq	.+12     	; 0xfb8 <set_trx_state+0x1e>
     fac:	86 31       	cpi	r24, 0x16	; 22
     fae:	21 f0       	breq	.+8      	; 0xfb8 <set_trx_state+0x1e>
     fb0:	89 31       	cpi	r24, 0x19	; 25
     fb2:	11 f0       	breq	.+4      	; 0xfb8 <set_trx_state+0x1e>
     fb4:	82 e4       	ldi	r24, 0x42	; 66
     fb6:	4b c0       	rjmp	.+150    	; 0x104e <set_trx_state+0xb4>
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
     fb8:	1c 9b       	sbis	0x03, 4	; 3
     fba:	02 c0       	rjmp	.+4      	; 0xfc0 <set_trx_state+0x26>
     fbc:	84 e4       	ldi	r24, 0x44	; 68
     fbe:	47 c0       	rjmp	.+142    	; 0x104e <set_trx_state+0xb4>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	6f e1       	ldi	r22, 0x1F	; 31
     fc4:	40 e0       	ldi	r20, 0x00	; 0
     fc6:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
     fca:	18 2f       	mov	r17, r24
		return TAT_WRONG_STATE; 
	}

	uint8_t original_state = tat_get_trx_state( );

	if ((original_state == BUSY_RX ) || (original_state == BUSY_TX) || 
     fcc:	81 50       	subi	r24, 0x01	; 1
     fce:	82 30       	cpi	r24, 0x02	; 2
     fd0:	08 f4       	brcc	.+2      	; 0xfd4 <set_trx_state+0x3a>
     fd2:	3a c0       	rjmp	.+116    	; 0x1048 <set_trx_state+0xae>
     fd4:	11 31       	cpi	r17, 0x11	; 17
     fd6:	c1 f1       	breq	.+112    	; 0x1048 <set_trx_state+0xae>
     fd8:	12 31       	cpi	r17, 0x12	; 18
     fda:	b1 f1       	breq	.+108    	; 0x1048 <set_trx_state+0xae>
	(original_state == BUSY_RX_AACK) || (original_state == BUSY_TX_ARET))
	{ 
		return TAT_BUSY_STATE;
	}

	if (new_state == original_state) 
     fdc:	01 17       	cp	r16, r17
     fde:	b1 f1       	breq	.+108    	; 0x104c <set_trx_state+0xb2>
	//At this point it is clear that the requested new_state is:
	//TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.

	//The radio transceiver can be in one of the following states:
	//TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON, TX_ARET_ON.
	if( new_state == TRX_OFF )
     fe0:	08 30       	cpi	r16, 0x08	; 8
     fe2:	19 f4       	brne	.+6      	; 0xfea <set_trx_state+0x50>
	{
		tat_reset_state_machine( ); //Go to TRX_OFF from any state.
     fe4:	0e 94 ad 07 	call	0xf5a	; 0xf5a <tat_reset_state_machine>
     fe8:	26 c0       	rjmp	.+76     	; 0x1036 <set_trx_state+0x9c>
	else 
	{

	//It is not allowed to go from RX_AACK_ON or TX_AACK_ON and directly to
	//TX_AACK_ON or RX_AACK_ON respectively. Need to go via RX_ON or PLL_ON.
		if ((new_state == TX_ARET_ON) && (original_state == RX_AACK_ON))
     fea:	09 31       	cpi	r16, 0x19	; 25
     fec:	39 f4       	brne	.+14     	; 0xffc <set_trx_state+0x62>
     fee:	16 31       	cpi	r17, 0x16	; 22
     ff0:	91 f4       	brne	.+36     	; 0x1016 <set_trx_state+0x7c>
		{

		//First do intermediate state transition to PLL_ON, then to TX_ARET_ON.
		//The final state transition to TX_ARET_ON is handled after the if-else if.
			hal_subregister_write( SR_TRX_CMD, PLL_ON );
     ff2:	82 e0       	ldi	r24, 0x02	; 2
     ff4:	6f e1       	ldi	r22, 0x1F	; 31
     ff6:	40 e0       	ldi	r20, 0x00	; 0
     ff8:	29 e0       	ldi	r18, 0x09	; 9
     ffa:	08 c0       	rjmp	.+16     	; 0x100c <set_trx_state+0x72>
			delay_us( TIME_STATE_TRANSITION_PLL_ACTIVE );
		} 
		else if ((new_state == RX_AACK_ON) && (original_state == TX_ARET_ON)) 
     ffc:	06 31       	cpi	r16, 0x16	; 22
     ffe:	59 f4       	brne	.+22     	; 0x1016 <set_trx_state+0x7c>
    1000:	19 31       	cpi	r17, 0x19	; 25
    1002:	49 f4       	brne	.+18     	; 0x1016 <set_trx_state+0x7c>
		{

		//First do intermediate state transition to RX_ON, then to RX_AACK_ON.
		//The final state transition to RX_AACK_ON is handled after the if-else if.
			hal_subregister_write( SR_TRX_CMD, RX_ON );
    1004:	82 e0       	ldi	r24, 0x02	; 2
    1006:	6f e1       	ldi	r22, 0x1F	; 31
    1008:	40 e0       	ldi	r20, 0x00	; 0
    100a:	26 e0       	ldi	r18, 0x06	; 6
    100c:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    1010:	82 e0       	ldi	r24, 0x02	; 2
    1012:	8a 95       	dec	r24
    1014:	f1 f7       	brne	.-4      	; 0x1012 <set_trx_state+0x78>
			delay_us( TIME_STATE_TRANSITION_PLL_ACTIVE );
		}

	//Any other state transition can be done directly.    
		hal_subregister_write( SR_TRX_CMD, new_state );
    1016:	82 e0       	ldi	r24, 0x02	; 2
    1018:	6f e1       	ldi	r22, 0x1F	; 31
    101a:	40 e0       	ldi	r20, 0x00	; 0
    101c:	20 2f       	mov	r18, r16
    101e:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>

	//When the PLL is active most states can be reached in 1us. However, from
	//TRX_OFF the PLL needs time to activate.
		if (original_state == TRX_OFF)
    1022:	18 30       	cpi	r17, 0x08	; 8
    1024:	29 f4       	brne	.+10     	; 0x1030 <set_trx_state+0x96>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1026:	8b e4       	ldi	r24, 0x4B	; 75
    1028:	91 e0       	ldi	r25, 0x01	; 1
    102a:	01 97       	sbiw	r24, 0x01	; 1
    102c:	f1 f7       	brne	.-4      	; 0x102a <set_trx_state+0x90>
    102e:	03 c0       	rjmp	.+6      	; 0x1036 <set_trx_state+0x9c>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1030:	82 e0       	ldi	r24, 0x02	; 2
    1032:	8a 95       	dec	r24
    1034:	f1 f7       	brne	.-4      	; 0x1032 <set_trx_state+0x98>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	6f e1       	ldi	r22, 0x1F	; 31
    103a:	40 e0       	ldi	r20, 0x00	; 0
    103c:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	} // end: if( new_state == TRX_OFF ) ...

	//Verify state transition.
	tat_status_t set_state_status = TAT_TIMED_OUT;

	if( tat_get_trx_state( ) == new_state )
    1040:	80 17       	cp	r24, r16
    1042:	21 f0       	breq	.+8      	; 0x104c <set_trx_state+0xb2>
    1044:	83 e4       	ldi	r24, 0x43	; 67
    1046:	03 c0       	rjmp	.+6      	; 0x104e <set_trx_state+0xb4>
    1048:	85 e4       	ldi	r24, 0x45	; 69
    104a:	01 c0       	rjmp	.+2      	; 0x104e <set_trx_state+0xb4>
    104c:	80 e4       	ldi	r24, 0x40	; 64
	{ 
		set_state_status = TAT_SUCCESS; 
	}

	return set_state_status;
}
    104e:	1f 91       	pop	r17
    1050:	0f 91       	pop	r16
    1052:	08 95       	ret

00001054 <tat_calibrate_filter>:
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	6f e1       	ldi	r22, 0x1F	; 31
    1058:	40 e0       	ldi	r20, 0x00	; 0
    105a:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
{
    
    /*Check current state. Only possible to do filter calibration from TRX_OFF or PLL_ON.*/
	uint8_t trx_state = tat_get_trx_state( );

	if ((trx_state != TRX_OFF ) && (trx_state != PLL_ON)) 
    105e:	88 50       	subi	r24, 0x08	; 8
    1060:	82 30       	cpi	r24, 0x02	; 2
    1062:	10 f0       	brcs	.+4      	; 0x1068 <tat_calibrate_filter+0x14>
    1064:	84 e4       	ldi	r24, 0x44	; 68
    1066:	08 95       	ret
	{ 
		return TAT_WRONG_STATE;
	}

	//Start the tuning algorithm by writing one to the FTN_START subregister.
	hal_subregister_write( SR_FTN_START, 1 );   
    1068:	88 e1       	ldi	r24, 0x18	; 24
    106a:	60 e8       	ldi	r22, 0x80	; 128
    106c:	47 e0       	ldi	r20, 0x07	; 7
    106e:	21 e0       	ldi	r18, 0x01	; 1
    1070:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    1074:	8d e3       	ldi	r24, 0x3D	; 61
    1076:	8a 95       	dec	r24
    1078:	f1 f7       	brne	.-4      	; 0x1076 <tat_calibrate_filter+0x22>
	delay_us( TIME_FTN_TUNING ); //Wait for the calibration to finish.

	tat_status_t filter_calibration_status = TAT_TIMED_OUT;    

	//Verify the calibration result.
	if (hal_subregister_read( SR_FTN_START ) == FTN_CALIBRATION_DONE) 
    107a:	88 e1       	ldi	r24, 0x18	; 24
    107c:	60 e8       	ldi	r22, 0x80	; 128
    107e:	47 e0       	ldi	r20, 0x07	; 7
    1080:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
    1084:	88 23       	and	r24, r24
    1086:	11 f4       	brne	.+4      	; 0x108c <tat_calibrate_filter+0x38>
    1088:	80 e4       	ldi	r24, 0x40	; 64
    108a:	08 95       	ret
    108c:	83 e4       	ldi	r24, 0x43	; 67
	{
		filter_calibration_status = TAT_SUCCESS;
	}
    
	return filter_calibration_status;
}
    108e:	08 95       	ret

00001090 <tat_set_clock_speed>:
 *  \retval TAT_INVALID_ARGUMENT Requested clock speed is out of bounds.
 *  
 * \ingroup tat
 */
tat_status_t tat_set_clock_speed( bool direct, uint8_t clock_speed )//R212 Modify
{
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	08 2f       	mov	r16, r24
    1096:	16 2f       	mov	r17, r22

	//Check function parameter and current clock speed.//
	if (clock_speed > CLKM_16MHZ) 
    1098:	66 30       	cpi	r22, 0x06	; 6
    109a:	10 f0       	brcs	.+4      	; 0x10a0 <tat_set_clock_speed+0x10>
    109c:	82 e4       	ldi	r24, 0x42	; 66
    109e:	1b c0       	rjmp	.+54     	; 0x10d6 <tat_set_clock_speed+0x46>
 *
 *  \ingroup tat
 */
uint8_t tat_get_clock_speed( void )//R212 Modify
{
	return hal_subregister_read( SR_CLKM_CTRL );
    10a0:	83 e0       	ldi	r24, 0x03	; 3
    10a2:	67 e0       	ldi	r22, 0x07	; 7
    10a4:	40 e0       	ldi	r20, 0x00	; 0
    10a6:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
	if (clock_speed > CLKM_16MHZ) 
	{ 
		return TAT_INVALID_ARGUMENT; 
	}

	if (tat_get_clock_speed( ) == clock_speed)
    10aa:	81 17       	cp	r24, r17
    10ac:	99 f0       	breq	.+38     	; 0x10d4 <tat_set_clock_speed+0x44>
	{ 
		return TAT_SUCCESS; 
	}

	//Select to change the CLKM frequency directly or after returning from SLEEP.//
	if (direct == false) 
    10ae:	00 23       	and	r16, r16
    10b0:	29 f4       	brne	.+10     	; 0x10bc <tat_set_clock_speed+0x2c>
	{
		hal_subregister_write( SR_CLKM_SHA_SEL, 1 );
    10b2:	83 e0       	ldi	r24, 0x03	; 3
    10b4:	68 e0       	ldi	r22, 0x08	; 8
    10b6:	43 e0       	ldi	r20, 0x03	; 3
    10b8:	21 e0       	ldi	r18, 0x01	; 1
    10ba:	04 c0       	rjmp	.+8      	; 0x10c4 <tat_set_clock_speed+0x34>
	} 
	else
	{
		hal_subregister_write( SR_CLKM_SHA_SEL, 0 );
    10bc:	83 e0       	ldi	r24, 0x03	; 3
    10be:	68 e0       	ldi	r22, 0x08	; 8
    10c0:	43 e0       	ldi	r20, 0x03	; 3
    10c2:	20 e0       	ldi	r18, 0x00	; 0
    10c4:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	} 

	hal_subregister_write( SR_CLKM_CTRL, clock_speed );
    10c8:	83 e0       	ldi	r24, 0x03	; 3
    10ca:	67 e0       	ldi	r22, 0x07	; 7
    10cc:	40 e0       	ldi	r20, 0x00	; 0
    10ce:	21 2f       	mov	r18, r17
    10d0:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    10d4:	80 e4       	ldi	r24, 0x40	; 64

	return TAT_SUCCESS;
}
    10d6:	1f 91       	pop	r17
    10d8:	0f 91       	pop	r16
    10da:	08 95       	ret

000010dc <tat_batmon_configure>:
 *  \retval TAT_INVALID_ARGUMENT The voltage_threshold parameter is out of 
 *                               bounds (Not within [0 - 15]).
 *  \ingroup tat
 */
tat_status_t tat_batmon_configure( bool range, uint8_t voltage_threshold )
{
    10dc:	1f 93       	push	r17
    10de:	16 2f       	mov	r17, r22
     
	/*Check function parameters and state.*/
	if (voltage_threshold > BATTERY_MONITOR_HIGHEST_VOLTAGE) 
    10e0:	60 31       	cpi	r22, 0x10	; 16
    10e2:	10 f0       	brcs	.+4      	; 0x10e8 <tat_batmon_configure+0xc>
    10e4:	82 e4       	ldi	r24, 0x42	; 66
    10e6:	18 c0       	rjmp	.+48     	; 0x1118 <tat_batmon_configure+0x3c>
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
    10e8:	1c 9b       	sbis	0x03, 4	; 3
    10ea:	02 c0       	rjmp	.+4      	; 0x10f0 <tat_batmon_configure+0x14>
    10ec:	84 e4       	ldi	r24, 0x44	; 68
    10ee:	14 c0       	rjmp	.+40     	; 0x1118 <tat_batmon_configure+0x3c>
	{ 
		return TAT_WRONG_STATE; 
	}

	/*Write new voltage range and voltage level.*/
	if (range == true) 
    10f0:	88 23       	and	r24, r24
    10f2:	29 f0       	breq	.+10     	; 0x10fe <tat_batmon_configure+0x22>
	{
		hal_subregister_write( SR_BATMON_HR, BATTERY_MONITOR_HIGH_VOLTAGE );
    10f4:	81 e1       	ldi	r24, 0x11	; 17
    10f6:	60 e1       	ldi	r22, 0x10	; 16
    10f8:	44 e0       	ldi	r20, 0x04	; 4
    10fa:	21 e0       	ldi	r18, 0x01	; 1
    10fc:	04 c0       	rjmp	.+8      	; 0x1106 <tat_batmon_configure+0x2a>
	} 
	else 
	{
		hal_subregister_write( SR_BATMON_HR, BATTERY_MONITOR_LOW_VOLTAGE );
    10fe:	81 e1       	ldi	r24, 0x11	; 17
    1100:	60 e1       	ldi	r22, 0x10	; 16
    1102:	44 e0       	ldi	r20, 0x04	; 4
    1104:	20 e0       	ldi	r18, 0x00	; 0
    1106:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	} // end: if (range == true) ...

	hal_subregister_write( SR_BATMON_VTH, voltage_threshold );
    110a:	81 e1       	ldi	r24, 0x11	; 17
    110c:	6f e0       	ldi	r22, 0x0F	; 15
    110e:	40 e0       	ldi	r20, 0x00	; 0
    1110:	21 2f       	mov	r18, r17
    1112:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    1116:	80 e4       	ldi	r24, 0x40	; 64

	return TAT_SUCCESS;
}
    1118:	1f 91       	pop	r17
    111a:	08 95       	ret

0000111c <tat_set_cca_mode>:
 *                               of bounds.
 *
 *  \ingroup tat
 */
tat_status_t tat_set_cca_mode( uint8_t mode, uint8_t ed_threshold )
{
    111c:	1f 93       	push	r17
    111e:	28 2f       	mov	r18, r24
    1120:	16 2f       	mov	r17, r22

	/*Check function parameters and state.*/
	if ((mode != CCA_ED) && (mode != CCA_CARRIER_SENSE) && 
    1122:	83 30       	cpi	r24, 0x03	; 3
    1124:	98 f4       	brcc	.+38     	; 0x114c <tat_set_cca_mode+0x30>
	{
		return TAT_INVALID_ARGUMENT;
	} 

	//Ensure that the ED threshold is within bounds.
	if (ed_threshold > RF212_MAX_ED_THRESHOLD) 
    1126:	60 31       	cpi	r22, 0x10	; 16
    1128:	88 f4       	brcc	.+34     	; 0x114c <tat_set_cca_mode+0x30>
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
    112a:	1c 9b       	sbis	0x03, 4	; 3
    112c:	02 c0       	rjmp	.+4      	; 0x1132 <tat_set_cca_mode+0x16>
    112e:	84 e4       	ldi	r24, 0x44	; 68
    1130:	0e c0       	rjmp	.+28     	; 0x114e <tat_set_cca_mode+0x32>
	{
		return TAT_WRONG_STATE; 
	} 

	/*Change cca mode and ed threshold.*/
	hal_subregister_write( SR_CCA_MODE, mode );
    1132:	88 e0       	ldi	r24, 0x08	; 8
    1134:	60 e6       	ldi	r22, 0x60	; 96
    1136:	45 e0       	ldi	r20, 0x05	; 5
    1138:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write( SR_CCA_ED_THRES, ed_threshold );
    113c:	89 e0       	ldi	r24, 0x09	; 9
    113e:	6f e0       	ldi	r22, 0x0F	; 15
    1140:	40 e0       	ldi	r20, 0x00	; 0
    1142:	21 2f       	mov	r18, r17
    1144:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    1148:	80 e4       	ldi	r24, 0x40	; 64
    114a:	01 c0       	rjmp	.+2      	; 0x114e <tat_set_cca_mode+0x32>

	return TAT_SUCCESS;
    114c:	82 e4       	ldi	r24, 0x42	; 66
}
    114e:	1f 91       	pop	r17
    1150:	08 95       	ret

00001152 <tat_configure_csma>:
 *                          SLEEP state.
 *
 *  \ingroup tat
 */
tat_status_t tat_configure_csma( uint8_t seed0, uint8_t be_csma_seed1 )
{
    1152:	0f 93       	push	r16
    1154:	1f 93       	push	r17
    1156:	08 2f       	mov	r16, r24
    1158:	16 2f       	mov	r17, r22
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
    115a:	1c 9b       	sbis	0x03, 4	; 3
    115c:	02 c0       	rjmp	.+4      	; 0x1162 <tat_configure_csma+0x10>
    115e:	84 e4       	ldi	r24, 0x44	; 68
    1160:	2a c0       	rjmp	.+84     	; 0x11b6 <tat_configure_csma+0x64>
	/*Extract parameters, and configure the CSMA-CA algorithm.*/
	uint8_t back_off_exponent = ( be_csma_seed1 & 0xC0 ) >> 6;
	uint8_t csma_retries      = ( be_csma_seed1 & 0x38 ) >> 3;
	uint8_t seed1             = ( be_csma_seed1 & 0x07 );
	        
	hal_subregister_write( SR_MAX_FRAME_RETRIES, 0 ); //AT86RF230 rev A errata.
    1162:	8c e2       	ldi	r24, 0x2C	; 44
    1164:	60 ef       	ldi	r22, 0xF0	; 240
    1166:	44 e0       	ldi	r20, 0x04	; 4
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write( SR_MAX_CSMA_RETRIES, csma_retries );
    116e:	21 2f       	mov	r18, r17
    1170:	30 e0       	ldi	r19, 0x00	; 0
    1172:	28 73       	andi	r18, 0x38	; 56
    1174:	30 70       	andi	r19, 0x00	; 0
    1176:	83 e0       	ldi	r24, 0x03	; 3
    1178:	35 95       	asr	r19
    117a:	27 95       	ror	r18
    117c:	8a 95       	dec	r24
    117e:	e1 f7       	brne	.-8      	; 0x1178 <tat_configure_csma+0x26>
    1180:	8c e2       	ldi	r24, 0x2C	; 44
    1182:	6e e0       	ldi	r22, 0x0E	; 14
    1184:	41 e0       	ldi	r20, 0x01	; 1
    1186:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write( SR_MIN_BE, back_off_exponent );
    118a:	21 2f       	mov	r18, r17
    118c:	22 95       	swap	r18
    118e:	26 95       	lsr	r18
    1190:	26 95       	lsr	r18
    1192:	23 70       	andi	r18, 0x03	; 3
    1194:	8f e2       	ldi	r24, 0x2F	; 47
    1196:	6f e0       	ldi	r22, 0x0F	; 15
    1198:	40 e0       	ldi	r20, 0x00	; 0
    119a:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_register_write( RG_CSMA_SEED_0, seed0 );
    119e:	8d e2       	ldi	r24, 0x2D	; 45
    11a0:	60 2f       	mov	r22, r16
    11a2:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_subregister_write( SR_CSMA_SEED_1, seed1 );
    11a6:	17 70       	andi	r17, 0x07	; 7
    11a8:	8e e2       	ldi	r24, 0x2E	; 46
    11aa:	67 e0       	ldi	r22, 0x07	; 7
    11ac:	40 e0       	ldi	r20, 0x00	; 0
    11ae:	21 2f       	mov	r18, r17
    11b0:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    11b4:	80 e4       	ldi	r24, 0x40	; 64
	        
	return TAT_SUCCESS;
}
    11b6:	1f 91       	pop	r17
    11b8:	0f 91       	pop	r16
    11ba:	08 95       	ret

000011bc <tat_set_extended_address>:
 *  \param  new_extended_address Extended address to be used by the address filter. 
 *
 *  \ingroup tat
 */
__x void tat_set_extended_address( uint8_t *extended_address )
{    
    11bc:	af 92       	push	r10
    11be:	bf 92       	push	r11
    11c0:	cf 92       	push	r12
    11c2:	df 92       	push	r13
    11c4:	ef 92       	push	r14
    11c6:	ff 92       	push	r15
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	8c 01       	movw	r16, r24
	hal_register_write( RG_IEEE_ADDR_7, *extended_address++ );
    11ce:	7c 01       	movw	r14, r24
    11d0:	08 94       	sec
    11d2:	e1 1c       	adc	r14, r1
    11d4:	f1 1c       	adc	r15, r1
    11d6:	8b e2       	ldi	r24, 0x2B	; 43
    11d8:	f8 01       	movw	r30, r16
    11da:	60 81       	ld	r22, Z
    11dc:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_6, *extended_address++ );
    11e0:	67 01       	movw	r12, r14
    11e2:	08 94       	sec
    11e4:	c1 1c       	adc	r12, r1
    11e6:	d1 1c       	adc	r13, r1
    11e8:	8a e2       	ldi	r24, 0x2A	; 42
    11ea:	f8 01       	movw	r30, r16
    11ec:	61 81       	ldd	r22, Z+1	; 0x01
    11ee:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_5, *extended_address++ );
    11f2:	56 01       	movw	r10, r12
    11f4:	08 94       	sec
    11f6:	a1 1c       	adc	r10, r1
    11f8:	b1 1c       	adc	r11, r1
    11fa:	89 e2       	ldi	r24, 0x29	; 41
    11fc:	f7 01       	movw	r30, r14
    11fe:	61 81       	ldd	r22, Z+1	; 0x01
    1200:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_4, *extended_address++ );
    1204:	75 01       	movw	r14, r10
    1206:	08 94       	sec
    1208:	e1 1c       	adc	r14, r1
    120a:	f1 1c       	adc	r15, r1
    120c:	88 e2       	ldi	r24, 0x28	; 40
    120e:	f6 01       	movw	r30, r12
    1210:	61 81       	ldd	r22, Z+1	; 0x01
    1212:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_3, *extended_address++ );
    1216:	87 01       	movw	r16, r14
    1218:	0f 5f       	subi	r16, 0xFF	; 255
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	87 e2       	ldi	r24, 0x27	; 39
    121e:	f5 01       	movw	r30, r10
    1220:	61 81       	ldd	r22, Z+1	; 0x01
    1222:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_2, *extended_address++ );
    1226:	86 e2       	ldi	r24, 0x26	; 38
    1228:	f7 01       	movw	r30, r14
    122a:	61 81       	ldd	r22, Z+1	; 0x01
    122c:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_1, *extended_address++ );
    1230:	85 e2       	ldi	r24, 0x25	; 37
    1232:	f8 01       	movw	r30, r16
    1234:	61 81       	ldd	r22, Z+1	; 0x01
    1236:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_register_write( RG_IEEE_ADDR_0, *extended_address++ );
    123a:	84 e2       	ldi	r24, 0x24	; 36
	hal_register_write( RG_IEEE_ADDR_7, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_6, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_5, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_4, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_3, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_2, *extended_address++ );
    123c:	0f 5f       	subi	r16, 0xFF	; 255
    123e:	1f 4f       	sbci	r17, 0xFF	; 255
	hal_register_write( RG_IEEE_ADDR_1, *extended_address++ );
	hal_register_write( RG_IEEE_ADDR_0, *extended_address++ );
    1240:	f8 01       	movw	r30, r16
    1242:	61 81       	ldd	r22, Z+1	; 0x01
    1244:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
}
    1248:	1f 91       	pop	r17
    124a:	0f 91       	pop	r16
    124c:	ff 90       	pop	r15
    124e:	ef 90       	pop	r14
    1250:	df 90       	pop	r13
    1252:	cf 90       	pop	r12
    1254:	bf 90       	pop	r11
    1256:	af 90       	pop	r10
    1258:	08 95       	ret

0000125a <tat_set_short_address>:
 *  \param  new_short_address Short address to be used by the address filter. 
 *
 *  \ingroup tat
 */
void tat_set_short_address( uint16_t new_short_address )
{
    125a:	1f 93       	push	r17
    125c:	68 2f       	mov	r22, r24
    125e:	19 2f       	mov	r17, r25
    
	uint8_t short_address_byte = new_short_address & 0xFF; // Extract short_address_7_0.
	hal_register_write( RG_SHORT_ADDR_0, short_address_byte );
    1260:	80 e2       	ldi	r24, 0x20	; 32
    1262:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>

	short_address_byte = (new_short_address >> 8*1) & 0xFF; // Extract short_address_15_8.
	hal_register_write( RG_SHORT_ADDR_1, short_address_byte );
    1266:	81 e2       	ldi	r24, 0x21	; 33
    1268:	61 2f       	mov	r22, r17
    126a:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
}
    126e:	1f 91       	pop	r17
    1270:	08 95       	ret

00001272 <tat_set_pan_id>:
 *  \param  new_pan_id Desired PANID. Can be any value from 0x0000 to 0xFFFF 
 *
 *  \ingroup tat
 */
void tat_set_pan_id( uint16_t new_pan_id )
{    
    1272:	1f 93       	push	r17
    1274:	68 2f       	mov	r22, r24
    1276:	19 2f       	mov	r17, r25
	uint8_t pan_byte = new_pan_id & 0xFF; // Extract new_pan_id_7_0.
	hal_register_write( RG_PAN_ID_0, pan_byte );
    1278:	82 e2       	ldi	r24, 0x22	; 34
    127a:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>

	pan_byte = (new_pan_id >> 8*1) & 0xFF;  // Extract new_pan_id_15_8.
	hal_register_write( RG_PAN_ID_1, pan_byte );    
    127e:	83 e2       	ldi	r24, 0x23	; 35
    1280:	61 2f       	mov	r22, r17
    1282:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
}
    1286:	1f 91       	pop	r17
    1288:	08 95       	ret

0000128a <trx_config>:
void trx_config(void)//R212 Modify
{
//	uint16_t rand_value;

	/* Set pin driver strength */
	hal_subregister_write(SR_PAD_IO_CLKM, PAD_CLKM_2_MA);
    128a:	83 e0       	ldi	r24, 0x03	; 3
    128c:	60 e3       	ldi	r22, 0x30	; 48
    128e:	44 e0       	ldi	r20, 0x04	; 4
    1290:	20 e0       	ldi	r18, 0x00	; 0
    1292:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	tat_set_clock_speed( true, CLKM_1MHZ);
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	61 e0       	ldi	r22, 0x01	; 1
    129a:	0e 94 48 08 	call	0x1090	; 0x1090 <tat_set_clock_speed>

	/*
	* Since the TAL currently supports MAC-2003 only, frames with version number
	* indicating MAC-2006 are not acknowledged.
	*/
	hal_subregister_write(SR_AACK_FVN_MODE, FRAME_VERSION_0);
    129e:	8e e2       	ldi	r24, 0x2E	; 46
    12a0:	60 ec       	ldi	r22, 0xC0	; 192
    12a2:	46 e0       	ldi	r20, 0x06	; 6
    12a4:	20 e0       	ldi	r18, 0x00	; 0
    12a6:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write(SR_AACK_SET_PD, PD_ACK_BIT_SET_ENABLE); /* ACKs for data requests, indicate pending data */
    12aa:	8e e2       	ldi	r24, 0x2E	; 46
    12ac:	60 e2       	ldi	r22, 0x20	; 32
    12ae:	45 e0       	ldi	r20, 0x05	; 5
    12b0:	21 e0       	ldi	r18, 0x01	; 1
    12b2:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write(SR_RX_SAFE_MODE, RX_SAFE_MODE_ENABLE);    /* Enable buffer protection mode */
    12b6:	8c e0       	ldi	r24, 0x0C	; 12
    12b8:	60 e8       	ldi	r22, 0x80	; 128
    12ba:	47 e0       	ldi	r20, 0x07	; 7
    12bc:	21 e0       	ldi	r18, 0x01	; 1
    12be:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write(SR_IRQ_MASK_MODE, IRQ_MASK_MODE_ON); /* Enable poll mode */
    12c2:	84 e0       	ldi	r24, 0x04	; 4
    12c4:	62 e0       	ldi	r22, 0x02	; 2
    12c6:	41 e0       	ldi	r20, 0x01	; 1
    12c8:	21 e0       	ldi	r18, 0x01	; 1
    12ca:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_register_write(RG_IRQ_MASK, TRX_IRQ_TRX_END);    /* The TRX_END interrupt of the transceiver is enabled. */
    12ce:	8e e0       	ldi	r24, 0x0E	; 14
    12d0:	68 e0       	ldi	r22, 0x08	; 8
    12d2:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_subregister_write(SR_TX_AUTO_CRC_ON, TX_AUTO_CRC_ENABLE); /* Enable auto CRC calculation */
    12d6:	84 e0       	ldi	r24, 0x04	; 4
    12d8:	60 e2       	ldi	r22, 0x20	; 32
    12da:	45 e0       	ldi	r20, 0x05	; 5
    12dc:	21 e0       	ldi	r18, 0x01	; 1
    12de:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write(SR_IRQ_2_EXT_EN, TIMESTAMPING_ENABLE);   /* Enable timestamping feature */
    12e2:	84 e0       	ldi	r24, 0x04	; 4
    12e4:	60 e4       	ldi	r22, 0x40	; 64
    12e6:	46 e0       	ldi	r20, 0x06	; 6
    12e8:	21 e0       	ldi	r18, 0x01	; 1
    12ea:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
#ifdef ANTENNA_DIVERSITY
	hal_subregister_write(SR_IRQ_2_EXT_EN, 1); /* Enable antenna diversity. */
#endif
}
    12ee:	08 95       	ret

000012f0 <tat_set_tx_power_level>:
 *                          device is sleeping.
 *
 *  \ingroup tat
 */
tat_status_t tat_set_tx_power_level( wpan_oqpsk_txpower_t power_level ,bool PA_BOOST)//R212 Modify
{
    12f0:	1f 93       	push	r17
    12f2:	98 2f       	mov	r25, r24
    12f4:	16 2f       	mov	r17, r22
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
    12f6:	1c 9b       	sbis	0x03, 4	; 3
    12f8:	02 c0       	rjmp	.+4      	; 0x12fe <tat_set_tx_power_level+0xe>
    12fa:	84 e4       	ldi	r24, 0x44	; 68
    12fc:	0b c0       	rjmp	.+22     	; 0x1314 <tat_set_tx_power_level+0x24>
	{
		return TAT_WRONG_STATE; 
	}

	/*Set new power level*/
	hal_register_write( RG_PHY_TX_PWR, power_level );
    12fe:	85 e0       	ldi	r24, 0x05	; 5
    1300:	69 2f       	mov	r22, r25
    1302:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	hal_subregister_write(SR_PA_BOOST, (uint8_t) PA_BOOST);
    1306:	85 e0       	ldi	r24, 0x05	; 5
    1308:	60 e8       	ldi	r22, 0x80	; 128
    130a:	47 e0       	ldi	r20, 0x07	; 7
    130c:	21 2f       	mov	r18, r17
    130e:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    1312:	80 e4       	ldi	r24, 0x40	; 64
	return TAT_SUCCESS;
}
    1314:	1f 91       	pop	r17
    1316:	08 95       	ret

00001318 <tat_get_extended_address>:
 *  \return Extended Address, any 64-bit value.
 *
 *  \ingroup tat
 */
__x void tat_get_extended_address( uint8_t *extended_address )
{    
    1318:	ef 92       	push	r14
    131a:	ff 92       	push	r15
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	7c 01       	movw	r14, r24
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_7 ); // Read ieee_address_63_56.
    1322:	8b e2       	ldi	r24, 0x2B	; 43
    1324:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1328:	f7 01       	movw	r30, r14
    132a:	81 93       	st	Z+, r24
    132c:	8f 01       	movw	r16, r30
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_6 ); // Read ieee_address_55_48.
    132e:	8a e2       	ldi	r24, 0x2A	; 42
    1330:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1334:	f7 01       	movw	r30, r14
    1336:	81 83       	std	Z+1, r24	; 0x01
    1338:	78 01       	movw	r14, r16
    133a:	08 94       	sec
    133c:	e1 1c       	adc	r14, r1
    133e:	f1 1c       	adc	r15, r1
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_5 ); // Read ieee_address_47_40.
    1340:	89 e2       	ldi	r24, 0x29	; 41
    1342:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1346:	f8 01       	movw	r30, r16
    1348:	81 83       	std	Z+1, r24	; 0x01
    134a:	87 01       	movw	r16, r14
    134c:	0f 5f       	subi	r16, 0xFF	; 255
    134e:	1f 4f       	sbci	r17, 0xFF	; 255
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_4 ); // Read ieee_address_39_32.
    1350:	88 e2       	ldi	r24, 0x28	; 40
    1352:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1356:	f7 01       	movw	r30, r14
    1358:	81 83       	std	Z+1, r24	; 0x01
    135a:	78 01       	movw	r14, r16
    135c:	08 94       	sec
    135e:	e1 1c       	adc	r14, r1
    1360:	f1 1c       	adc	r15, r1
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_3 ); // Read ieee_address_31_24.
    1362:	87 e2       	ldi	r24, 0x27	; 39
    1364:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1368:	f8 01       	movw	r30, r16
    136a:	81 83       	std	Z+1, r24	; 0x01
    136c:	87 01       	movw	r16, r14
    136e:	0f 5f       	subi	r16, 0xFF	; 255
    1370:	1f 4f       	sbci	r17, 0xFF	; 255
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_2 ); // Read ieee_address_23_16.
    1372:	86 e2       	ldi	r24, 0x26	; 38
    1374:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1378:	f7 01       	movw	r30, r14
    137a:	81 83       	std	Z+1, r24	; 0x01
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_1 ); // Read ieee_address_15_8.
    137c:	85 e2       	ldi	r24, 0x25	; 37
    137e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1382:	f8 01       	movw	r30, r16
    1384:	81 83       	std	Z+1, r24	; 0x01
	*extended_address   = hal_register_read( RG_IEEE_ADDR_0 ); // Read ieee_address_7_0.
    1386:	84 e2       	ldi	r24, 0x24	; 36
    1388:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_7 ); // Read ieee_address_63_56.
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_6 ); // Read ieee_address_55_48.
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_5 ); // Read ieee_address_47_40.
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_4 ); // Read ieee_address_39_32.
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_3 ); // Read ieee_address_31_24.
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_2 ); // Read ieee_address_23_16.
    138c:	0f 5f       	subi	r16, 0xFF	; 255
    138e:	1f 4f       	sbci	r17, 0xFF	; 255
	*extended_address++ = hal_register_read( RG_IEEE_ADDR_1 ); // Read ieee_address_15_8.
	*extended_address   = hal_register_read( RG_IEEE_ADDR_0 ); // Read ieee_address_7_0.
    1390:	f8 01       	movw	r30, r16
    1392:	81 83       	std	Z+1, r24	; 0x01
}
    1394:	1f 91       	pop	r17
    1396:	0f 91       	pop	r16
    1398:	ff 90       	pop	r15
    139a:	ef 90       	pop	r14
    139c:	08 95       	ret

0000139e <tat_get_short_address>:
 *  \retval Any value from 0x0000 to 0xFFFF
 *
 *  \ingroup tat
 */
uint16_t tat_get_short_address( void )
{
    139e:	1f 93       	push	r17

	uint8_t short_address_15_8 = hal_register_read( RG_SHORT_ADDR_1 ); // Read short_address_15_8.
    13a0:	81 e2       	ldi	r24, 0x21	; 33
    13a2:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    13a6:	18 2f       	mov	r17, r24
	uint8_t short_address_7_0  = hal_register_read( RG_SHORT_ADDR_0 ); // Read short_address_7_0.
    13a8:	80 e2       	ldi	r24, 0x20	; 32
    13aa:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    13ae:	51 2f       	mov	r21, r17
    13b0:	40 e0       	ldi	r20, 0x00	; 0
    13b2:	28 2f       	mov	r18, r24
    13b4:	30 e0       	ldi	r19, 0x00	; 0
    13b6:	24 2b       	or	r18, r20
    13b8:	35 2b       	or	r19, r21

	uint16_t short_address = ((uint16_t)(short_address_15_8 << 8)) | short_address_7_0;

	return short_address;
}
    13ba:	c9 01       	movw	r24, r18
    13bc:	1f 91       	pop	r17
    13be:	08 95       	ret

000013c0 <tat_get_pan_id>:
 *  \retval Any value from 0 to 0xFFFF.
 *
 *  \ingroup tat
 */
uint16_t tat_get_pan_id( void )
{    
    13c0:	1f 93       	push	r17
    uint8_t pan_id_15_8 = hal_register_read( RG_PAN_ID_1 ); // Read pan_id_15_8.
    13c2:	83 e2       	ldi	r24, 0x23	; 35
    13c4:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    13c8:	18 2f       	mov	r17, r24
    uint8_t pan_id_7_0 = hal_register_read( RG_PAN_ID_0 ); // Read pan_id_7_0.
    13ca:	82 e2       	ldi	r24, 0x22	; 34
    13cc:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    13d0:	51 2f       	mov	r21, r17
    13d2:	40 e0       	ldi	r20, 0x00	; 0
    13d4:	28 2f       	mov	r18, r24
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	24 2b       	or	r18, r20
    13da:	35 2b       	or	r19, r21
    
    uint16_t pan_id = ((uint16_t)(pan_id_15_8 << 8)) | pan_id_7_0;
    
    return pan_id;
}
    13dc:	c9 01       	movw	r24, r18
    13de:	1f 91       	pop	r17
    13e0:	08 95       	ret

000013e2 <tat_do_cca>:
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	6f e1       	ldi	r22, 0x1F	; 31
    13e6:	40 e0       	ldi	r20, 0x00	; 0
    13e8:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
 */
tat_status_t tat_do_cca( void )
{

	/*Check state. CCA measurement only possible form PLL_ON state.*/
	if (tat_get_trx_state( ) != PLL_ON) 
    13ec:	89 30       	cpi	r24, 0x09	; 9
    13ee:	11 f0       	breq	.+4      	; 0x13f4 <tat_do_cca+0x12>
    13f0:	84 e4       	ldi	r24, 0x44	; 68
    13f2:	08 95       	ret
	{ 
		return TAT_WRONG_STATE; 
	}

	/*Ensure that it is possible to enter RX_ON*/
	if (set_trx_state( RX_ON ) != TAT_SUCCESS) 
    13f4:	86 e0       	ldi	r24, 0x06	; 6
    13f6:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    13fa:	80 34       	cpi	r24, 0x40	; 64
    13fc:	a9 f4       	brne	.+42     	; 0x1428 <tat_do_cca+0x46>
	{
		return TAT_TIMED_OUT; 
	}

	//The CCA is initiated by writing 1 to the CCA_REQUEST subregister.
	hal_subregister_write( SR_CCA_REQUEST, TAT_START_CCA );
    13fe:	88 e0       	ldi	r24, 0x08	; 8
    1400:	60 e8       	ldi	r22, 0x80	; 128
    1402:	47 e0       	ldi	r20, 0x07	; 7
    1404:	21 e0       	ldi	r18, 0x01	; 1
    1406:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    140a:	82 e0       	ldi	r24, 0x02	; 2
    140c:	91 e0       	ldi	r25, 0x01	; 1
    140e:	01 97       	sbiw	r24, 0x01	; 1
    1410:	f1 f7       	brne	.-4      	; 0x140e <tat_do_cca+0x2c>

	//The CCA is measured over 128 us + 12 us computation time.
	delay_us( TIME_CCA );

	uint8_t status = hal_register_read( RG_TRX_STATUS ); //Read cca status.
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
	tat_status_t cca_status = TAT_CCA_BUSY; //Return variable.

	//Check if the algorithm finished -> CCA_DONE == 1.
	if ((status & TAT_CCA_DONE_MASK) != TAT_CCA_DONE_MASK)
    1418:	87 ff       	sbrs	r24, 7
    141a:	06 c0       	rjmp	.+12     	; 0x1428 <tat_do_cca+0x46>
	} 
	else 
	{

	//CCA done, but check if the channel is busy or not.
		if ((status & TAT_CCA_IDLE_MASK) != TAT_CCA_IDLE_MASK) 
    141c:	86 fd       	sbrc	r24, 6
    141e:	02 c0       	rjmp	.+4      	; 0x1424 <tat_do_cca+0x42>
    1420:	88 e4       	ldi	r24, 0x48	; 72
    1422:	08 95       	ret
    1424:	87 e4       	ldi	r24, 0x47	; 71
    1426:	08 95       	ret
    1428:	83 e4       	ldi	r24, 0x43	; 67
			cca_status = TAT_CCA_IDLE;
		} // end: if ((status & TAT_CCA_IDLE_MASK) ...
	} // end: if ((status & TAT_CCA_DONE_MASK) ...

	return cca_status;
}
    142a:	08 95       	ret

0000142c <tat_do_ed_scan>:
 *  \retval TAT_WRONG_STATE The energy detection can only be done if the radio
 *                          transceiver's state is RX_ON or BUSY_RX.
 *  \ingroup tat
 */
tat_status_t tat_do_ed_scan( uint8_t *ed_level )
{
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	ec 01       	movw	r28, r24
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	6f e1       	ldi	r22, 0x1F	; 31
    1436:	40 e0       	ldi	r20, 0x00	; 0
    1438:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
{

	uint8_t current_state = tat_get_trx_state( );

	/*Check state. Only possible to do ed measurement from RX_ON or BUSY_RX.*/
	if ((current_state != RX_ON ) && (current_state != BUSY_RX)) 
    143c:	86 30       	cpi	r24, 0x06	; 6
    143e:	21 f0       	breq	.+8      	; 0x1448 <tat_do_ed_scan+0x1c>
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	11 f0       	breq	.+4      	; 0x1448 <tat_do_ed_scan+0x1c>
    1444:	84 e4       	ldi	r24, 0x44	; 68
    1446:	0d c0       	rjmp	.+26     	; 0x1462 <tat_do_ed_scan+0x36>
		return TAT_WRONG_STATE;
	}

	/*Do ED measurement.*/    
	//Initiate the measurement by writing to the PHY_ED_LEVEL register.
	hal_register_write( RG_PHY_ED_LEVEL, 0 );
    1448:	87 e0       	ldi	r24, 0x07	; 7
    144a:	60 e0       	ldi	r22, 0x00	; 0
    144c:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
    1450:	82 e0       	ldi	r24, 0x02	; 2
    1452:	91 e0       	ldi	r25, 0x01	; 1
    1454:	01 97       	sbiw	r24, 0x01	; 1
    1456:	f1 f7       	brne	.-4      	; 0x1454 <tat_do_ed_scan+0x28>
	delay_us( TIME_ED_MEASUREMENT ); //Wait 128 us + 12 us computation time.
	*ed_level = hal_register_read( RG_PHY_ED_LEVEL ); //Write ED level to pointer.
    1458:	87 e0       	ldi	r24, 0x07	; 7
    145a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    145e:	88 83       	st	Y, r24
    1460:	80 e4       	ldi	r24, 0x40	; 64

	return TAT_SUCCESS;
}
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	08 95       	ret

00001468 <tat_set_modulation_datarate>:
	hal_subregister_write(SR_PA_BOOST, (uint8_t) PA_BOOST);
	return TAT_SUCCESS;
}

retval_t tat_set_modulation_datarate(rf212_modulation_datarate_t mode)
{
    1468:	1f 93       	push	r17
    146a:	18 2f       	mov	r17, r24
	uint8_t tmp;
	tmp = hal_register_read(RG_TRX_CTRL_2);
    146c:	8c e0       	ldi	r24, 0x0C	; 12
    146e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
	tmp &= 0xC0;
    1472:	68 2f       	mov	r22, r24
    1474:	60 7c       	andi	r22, 0xC0	; 192
	tmp |= mode;
	hal_register_write(RG_TRX_CTRL_2, tmp);
    1476:	61 2b       	or	r22, r17
    1478:	8c e0       	ldi	r24, 0x0C	; 12
    147a:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
	
	if((mode== BPSK_20) || (mode==BPSK_40))
    147e:	11 23       	and	r17, r17
    1480:	11 f0       	breq	.+4      	; 0x1486 <tat_set_modulation_datarate+0x1e>
    1482:	14 30       	cpi	r17, 0x04	; 4
    1484:	59 f4       	brne	.+22     	; 0x149c <tat_set_modulation_datarate+0x34>
	{
		hal_subregister_write(SR_GC_TX_OFFS, BPSK_TX_OFFSET);
    1486:	86 e1       	ldi	r24, 0x16	; 22
    1488:	63 e0       	ldi	r22, 0x03	; 3
    148a:	40 e0       	ldi	r20, 0x00	; 0
    148c:	23 e0       	ldi	r18, 0x03	; 3
    148e:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
                // Reduced ACK timing
                hal_subregister_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_12_SYMBOLS);
    1492:	87 e1       	ldi	r24, 0x17	; 23
    1494:	64 e0       	ldi	r22, 0x04	; 4
    1496:	42 e0       	ldi	r20, 0x02	; 2
    1498:	20 e0       	ldi	r18, 0x00	; 0
    149a:	0a c0       	rjmp	.+20     	; 0x14b0 <tat_set_modulation_datarate+0x48>
	}
	else
	{
		hal_subregister_write(SR_GC_TX_OFFS, OQPSK_TX_OFFSET);
    149c:	86 e1       	ldi	r24, 0x16	; 22
    149e:	63 e0       	ldi	r22, 0x03	; 3
    14a0:	40 e0       	ldi	r20, 0x00	; 0
    14a2:	22 e0       	ldi	r18, 0x02	; 2
    14a4:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
                // Reduced ACK timing
                hal_subregister_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_2_SYMBOLS);
    14a8:	87 e1       	ldi	r24, 0x17	; 23
    14aa:	64 e0       	ldi	r22, 0x04	; 4
    14ac:	42 e0       	ldi	r20, 0x02	; 2
    14ae:	21 e0       	ldi	r18, 0x01	; 1
    14b0:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	}
	
	return SUCCESS;
}
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	1f 91       	pop	r17
    14b8:	08 95       	ret

000014ba <tat_get_tx_power_level>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_tx_power_level( void )//R212 Modify
{
	return hal_register_read( RG_PHY_TX_PWR);
    14ba:	85 e0       	ldi	r24, 0x05	; 5
    14bc:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
}
    14c0:	08 95       	ret

000014c2 <tat_get_operating_channel>:
 *
 *  \ingroup tat
 */
uint8_t tat_get_operating_channel( void )//R212 Modify
{
	return hal_register_read( RG_CC_CTRL_0);
    14c2:	83 e1       	ldi	r24, 0x13	; 19
    14c4:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
}
    14c8:	08 95       	ret

000014ca <tat_set_operating_channel>:
 *  \retval TAT_TIMED_OUT The PLL did not lock within the specified time.
 *
 *  \ingroup tat
 */
tat_status_t tat_set_operating_channel( wpan_channel_t channel )//R212 Modify
{
    14ca:	1f 93       	push	r17
    14cc:	18 2f       	mov	r17, r24
	//when CC_BAND= 1, then Fc= 769+0.1*CC_NUMBER(MHz)
	hal_subregister_write(SR_CC_BAND, RF212_WPAN_MODEL);
    14ce:	84 e1       	ldi	r24, 0x14	; 20
    14d0:	67 e0       	ldi	r22, 0x07	; 7
    14d2:	40 e0       	ldi	r20, 0x00	; 0
    14d4:	21 e0       	ldi	r18, 0x01	; 1
    14d6:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	
	/*Do function parameter and state check.*/
	if ((channel < RF212_MIN_CHANNEL) || (channel > RF212_MAX_CHANNEL)) 
    14da:	81 2f       	mov	r24, r17
    14dc:	8e 56       	subi	r24, 0x6E	; 110
    14de:	8d 33       	cpi	r24, 0x3D	; 61
    14e0:	10 f0       	brcs	.+4      	; 0x14e6 <tat_set_operating_channel+0x1c>
    14e2:	82 e4       	ldi	r24, 0x42	; 66
    14e4:	22 c0       	rjmp	.+68     	; 0x152a <tat_set_operating_channel+0x60>
    
	bool sleeping = false;

	//The radio transceiver will be at SLEEP or one of the *_NOCLK states only if
	//the SLP_TR pin is high.
	if (hal_get_slptr( ) != 0) 
    14e6:	1c 9b       	sbis	0x03, 4	; 3
    14e8:	02 c0       	rjmp	.+4      	; 0x14ee <tat_set_operating_channel+0x24>
    14ea:	84 e4       	ldi	r24, 0x44	; 68
    14ec:	1e c0       	rjmp	.+60     	; 0x152a <tat_set_operating_channel+0x60>
 *
 *  \ingroup tat
 */
uint8_t tat_get_operating_channel( void )//R212 Modify
{
	return hal_register_read( RG_CC_CTRL_0);
    14ee:	83 e1       	ldi	r24, 0x13	; 19
    14f0:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>

	if (is_sleeping( ) == true) 
	{
		return TAT_WRONG_STATE; 
	}
	if (tat_get_operating_channel( ) == channel) 
    14f4:	81 17       	cp	r24, r17
    14f6:	c1 f0       	breq	.+48     	; 0x1528 <tat_set_operating_channel+0x5e>
	{
		return TAT_SUCCESS; 
	}

	/*Set new operating channel.*/        
	hal_register_write(RG_CC_CTRL_0, channel);
    14f8:	83 e1       	ldi	r24, 0x13	; 19
    14fa:	61 2f       	mov	r22, r17
    14fc:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	6f e1       	ldi	r22, 0x1F	; 31
    1504:	40 e0       	ldi	r20, 0x00	; 0
    1506:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>

	//Read current state and wait for the PLL_LOCK interrupt if the
	//radio transceiver is in either RX_ON or PLL_ON.
	uint8_t trx_state = tat_get_trx_state( );

	if ((trx_state == RX_ON) || (trx_state == PLL_ON)) 
    150a:	86 30       	cpi	r24, 0x06	; 6
    150c:	11 f0       	breq	.+4      	; 0x1512 <tat_set_operating_channel+0x48>
    150e:	89 30       	cpi	r24, 0x09	; 9
    1510:	21 f4       	brne	.+8      	; 0x151a <tat_set_operating_channel+0x50>
    1512:	84 e1       	ldi	r24, 0x14	; 20
    1514:	91 e0       	ldi	r25, 0x01	; 1
    1516:	01 97       	sbiw	r24, 0x01	; 1
    1518:	f1 f7       	brne	.-4      	; 0x1516 <tat_set_operating_channel+0x4c>
 *
 *  \ingroup tat
 */
uint8_t tat_get_operating_channel( void )//R212 Modify
{
	return hal_register_read( RG_CC_CTRL_0);
    151a:	83 e1       	ldi	r24, 0x13	; 19
    151c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
	}

	tat_status_t channel_set_status = TAT_TIMED_OUT;

	//Check that the channel was set properly.
	if (tat_get_operating_channel( ) == channel) 
    1520:	81 17       	cp	r24, r17
    1522:	11 f0       	breq	.+4      	; 0x1528 <tat_set_operating_channel+0x5e>
    1524:	83 e4       	ldi	r24, 0x43	; 67
    1526:	01 c0       	rjmp	.+2      	; 0x152a <tat_set_operating_channel+0x60>
    1528:	80 e4       	ldi	r24, 0x40	; 64
	{
		channel_set_status = TAT_SUCCESS;
	}

	return channel_set_status;
}
    152a:	1f 91       	pop	r17
    152c:	08 95       	ret

0000152e <tat_init>:
 *                          enter TRX_OFF state within the specified time.
 *
 *  \ingroup tat
 */
tat_status_t tat_init( void )//R212 Modify
{    
    152e:	0f 93       	push	r16
    1530:	1f 93       	push	r17
    1532:	0c ea       	ldi	r16, 0xAC	; 172
    1534:	13 e0       	ldi	r17, 0x03	; 3
    1536:	c8 01       	movw	r24, r16
    1538:	01 97       	sbiw	r24, 0x01	; 1
    153a:	f1 f7       	brne	.-4      	; 0x1538 <tat_init+0xa>

	delay_us( TIME_TO_ENTER_P_ON );

	//Initialize Hardware Abstraction Layer.

	trx_reset( ); //Do HW reset of radio transeiver.
    153c:	0e 94 b1 06 	call	0xd62	; 0xd62 <trx_reset>

	//Force transition to TRX_OFF.
	hal_subregister_write( SR_TRX_CMD, CMD_FORCE_TRX_OFF );
    1540:	82 e0       	ldi	r24, 0x02	; 2
    1542:	6f e1       	ldi	r22, 0x1F	; 31
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	23 e0       	ldi	r18, 0x03	; 3
    1548:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
    154c:	c8 01       	movw	r24, r16
    154e:	01 97       	sbiw	r24, 0x01	; 1
    1550:	f1 f7       	brne	.-4      	; 0x154e <tat_init+0x20>
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	6f e1       	ldi	r22, 0x1F	; 31
    1556:	40 e0       	ldi	r20, 0x00	; 0
    1558:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>

	//Force transition to TRX_OFF.
	hal_subregister_write( SR_TRX_CMD, CMD_FORCE_TRX_OFF );
	delay_us( TIME_P_ON_TO_TRX_OFF ); //Wait for the transition to be complete.

	if (tat_get_trx_state( ) != TRX_OFF) 
    155c:	88 30       	cpi	r24, 0x08	; 8
    155e:	11 f0       	breq	.+4      	; 0x1564 <tat_init+0x36>
    1560:	83 e4       	ldi	r24, 0x43	; 67
    1562:	18 c0       	rjmp	.+48     	; 0x1594 <tat_init+0x66>
	} 
	else 
	{

	//Read Version Number
		chip_info = hal_register_read( RG_PART_NUM );
    1564:	8c e1       	ldi	r24, 0x1C	; 28
    1566:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    156a:	80 93 4a 0d 	sts	0x0D4A, r24

		if (chip_info != AT86RF212_PART_NUM ) 
    156e:	87 30       	cpi	r24, 0x07	; 7
    1570:	81 f4       	brne	.+32     	; 0x1592 <tat_init+0x64>
		{
			init_status = TAT_UNSUPPORTED_DEVICE;
		} 
		else
		{
			if(hal_register_read(RG_VERSION_NUM)!= AT86RF212_VERSION_NUM)
    1572:	8d e1       	ldi	r24, 0x1D	; 29
    1574:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1578:	81 30       	cpi	r24, 0x01	; 1
    157a:	59 f4       	brne	.+22     	; 0x1592 <tat_init+0x64>
			{
				init_status = TAT_UNSUPPORTED_DEVICE;
			}
			else
			{
				if (hal_register_read( RG_MAN_ID_0 ) != SUPPORTED_MANUFACTURER_ID) 
    157c:	8e e1       	ldi	r24, 0x1E	; 30
    157e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    1582:	8f 31       	cpi	r24, 0x1F	; 31
    1584:	31 f4       	brne	.+12     	; 0x1592 <tat_init+0x64>
				{
					init_status = TAT_UNSUPPORTED_DEVICE;
				} 
				else 
				{
					hal_register_write( RG_IRQ_MASK, RF212_SUPPORTED_INTERRUPT_MASK );
    1586:	8e e0       	ldi	r24, 0x0E	; 14
    1588:	6f ef       	ldi	r22, 0xFF	; 255
    158a:	0e 94 17 03 	call	0x62e	; 0x62e <hal_register_write>
    158e:	80 e4       	ldi	r24, 0x40	; 64
    1590:	01 c0       	rjmp	.+2      	; 0x1594 <tat_init+0x66>
    1592:	81 e4       	ldi	r24, 0x41	; 65
			}
		} // end: if ((version_number != RF230_REVA ) ...
	} // end: if (tat_get_trx_state( ) ...

	return init_status;
}
    1594:	1f 91       	pop	r17
    1596:	0f 91       	pop	r16
    1598:	08 95       	ret

0000159a <tat_calibrate_pll>:
 *   
 *  \ingroup tat
 */
uint8_t tat_get_trx_state( void )
{
	return hal_subregister_read( SR_TRX_STATUS );
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	6f e1       	ldi	r22, 0x1F	; 31
    159e:	40 e0       	ldi	r20, 0x00	; 0
    15a0:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
 */
tat_status_t tat_calibrate_pll( void )
{
    
    /*Check current state. Only possible to calibrate PLL from PLL_ON state*/
	if (tat_get_trx_state( ) != PLL_ON) 
    15a4:	89 30       	cpi	r24, 0x09	; 9
    15a6:	11 f0       	breq	.+4      	; 0x15ac <tat_calibrate_pll+0x12>
    15a8:	84 e4       	ldi	r24, 0x44	; 68
    15aa:	08 95       	ret
	{
		return TAT_WRONG_STATE; 
	}

	//Initiate the DCU and CF calibration loops.
	hal_subregister_write( SR_PLL_DCU_START, 1 );
    15ac:	8b e1       	ldi	r24, 0x1B	; 27
    15ae:	60 e8       	ldi	r22, 0x80	; 128
    15b0:	47 e0       	ldi	r20, 0x07	; 7
    15b2:	21 e0       	ldi	r18, 0x01	; 1
    15b4:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>
	hal_subregister_write( SR_PLL_CF_START, 1 );
    15b8:	8a e1       	ldi	r24, 0x1A	; 26
    15ba:	60 e8       	ldi	r22, 0x80	; 128
    15bc:	47 e0       	ldi	r20, 0x07	; 7
    15be:	21 e0       	ldi	r18, 0x01	; 1
    15c0:	0e 94 45 03 	call	0x68a	; 0x68a <hal_subregister_write>

	//Wait maximum 150 us for the PLL to lock.
	hal_clear_pll_lock_flag( );
    15c4:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <hal_clear_pll_lock_flag>
    15c8:	84 e1       	ldi	r24, 0x14	; 20
    15ca:	91 e0       	ldi	r25, 0x01	; 1
    15cc:	01 97       	sbiw	r24, 0x01	; 1
    15ce:	f1 f7       	brne	.-4      	; 0x15cc <tat_calibrate_pll+0x32>
	delay_us( TIME_PLL_LOCK );

	tat_status_t pll_calibration_status = TAT_TIMED_OUT;

	if (hal_get_pll_lock_flag( ) > 0) 
    15d0:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <hal_get_pll_lock_flag>
    15d4:	88 23       	and	r24, r24
    15d6:	81 f0       	breq	.+32     	; 0x15f8 <tat_calibrate_pll+0x5e>
	{
		if (hal_subregister_read( SR_PLL_DCU_START ) == PLL_DCU_CALIBRATION_DONE)
    15d8:	8b e1       	ldi	r24, 0x1B	; 27
    15da:	60 e8       	ldi	r22, 0x80	; 128
    15dc:	47 e0       	ldi	r20, 0x07	; 7
    15de:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
    15e2:	88 23       	and	r24, r24
    15e4:	49 f4       	brne	.+18     	; 0x15f8 <tat_calibrate_pll+0x5e>
		{
			if (hal_subregister_read( SR_PLL_CF_START ) == PLL_CF_CALIBRATION_DONE) 
    15e6:	8a e1       	ldi	r24, 0x1A	; 26
    15e8:	60 e8       	ldi	r22, 0x80	; 128
    15ea:	47 e0       	ldi	r20, 0x07	; 7
    15ec:	0e 94 32 03 	call	0x664	; 0x664 <hal_subregister_read>
    15f0:	88 23       	and	r24, r24
    15f2:	11 f4       	brne	.+4      	; 0x15f8 <tat_calibrate_pll+0x5e>
    15f4:	80 e4       	ldi	r24, 0x40	; 64
    15f6:	08 95       	ret
    15f8:	83 e4       	ldi	r24, 0x43	; 67
				pll_calibration_status = TAT_SUCCESS;    
			} // end: if (hal_subregister_read( SR_PLL_CF_START ) ...
		} // end: if (hal_subregister_read( SR_PLL_DCU_START ) ...
	} // end: if ((hal_get_pll_lock_flag( ) ...
	return pll_calibration_status;
}
    15fa:	08 95       	ret

000015fc <rx_pool_init>:
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    15fc:	83 e5       	ldi	r24, 0x53	; 83
    15fe:	9e e0       	ldi	r25, 0x0E	; 14
    1600:	90 93 ac 10 	sts	0x10AC, r25
    1604:	80 93 ab 10 	sts	0x10AB, r24
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    1608:	27 e9       	ldi	r18, 0x97	; 151
    160a:	30 e1       	ldi	r19, 0x10	; 16
    160c:	30 93 ae 10 	sts	0x10AE, r19
    1610:	20 93 ad 10 	sts	0x10AD, r18
    rx_pool_head = rx_pool_start;
    1614:	90 93 b0 10 	sts	0x10B0, r25
    1618:	80 93 af 10 	sts	0x10AF, r24
	rx_pool_tail = rx_pool_end;
    161c:	30 93 b2 10 	sts	0x10B2, r19
    1620:	20 93 b1 10 	sts	0x10B1, r18
	rx_pool_items_free = RX_POOL_SIZE;
    1624:	8e e1       	ldi	r24, 0x1E	; 30
    1626:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    162a:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    162e:	10 92 51 0e 	sts	0x0E51, r1
}
    1632:	08 95       	ret

00001634 <addSendData>:
void download()
{
	comPrintString("\r\n>>yangjieshahuhu!");
}
void addSendData(uint16_t dAddr,uint8_t data[])
{
    1634:	db 01       	movw	r26, r22
	dataSendBuffer[dataSendBufferHead].dAddr[0]=dAddr&0xFF;
    1636:	20 91 58 0d 	lds	r18, 0x0D58
    163a:	30 91 59 0d 	lds	r19, 0x0D59
    163e:	f9 01       	movw	r30, r18
    1640:	43 e0       	ldi	r20, 0x03	; 3
    1642:	ee 0f       	add	r30, r30
    1644:	ff 1f       	adc	r31, r31
    1646:	4a 95       	dec	r20
    1648:	e1 f7       	brne	.-8      	; 0x1642 <addSendData+0xe>
    164a:	e2 1b       	sub	r30, r18
    164c:	f3 0b       	sbc	r31, r19
    164e:	e0 5a       	subi	r30, 0xA0	; 160
    1650:	f2 4f       	sbci	r31, 0xF2	; 242
    1652:	80 83       	st	Z, r24
	dataSendBuffer[dataSendBufferHead].dAddr[1]=(dAddr>>8)&0xFF;
    1654:	91 83       	std	Z+1, r25	; 0x01
	dataSendBuffer[dataSendBufferHead].data[0]=data[0];
    1656:	8c 91       	ld	r24, X
    1658:	82 83       	std	Z+2, r24	; 0x02
	dataSendBuffer[dataSendBufferHead].data[1]=data[1];
    165a:	11 96       	adiw	r26, 0x01	; 1
    165c:	8c 91       	ld	r24, X
    165e:	11 97       	sbiw	r26, 0x01	; 1
    1660:	83 83       	std	Z+3, r24	; 0x03
	dataSendBuffer[dataSendBufferHead].data[2]=data[2];
    1662:	12 96       	adiw	r26, 0x02	; 2
    1664:	8c 91       	ld	r24, X
    1666:	12 97       	sbiw	r26, 0x02	; 2
    1668:	84 83       	std	Z+4, r24	; 0x04
	dataSendBuffer[dataSendBufferHead].data[3]=data[3];
    166a:	13 96       	adiw	r26, 0x03	; 3
    166c:	8c 91       	ld	r24, X
    166e:	13 97       	sbiw	r26, 0x03	; 3
    1670:	85 83       	std	Z+5, r24	; 0x05
	dataSendBuffer[dataSendBufferHead].data[4]=data[4];
    1672:	14 96       	adiw	r26, 0x04	; 4
    1674:	8c 91       	ld	r24, X
    1676:	86 83       	std	Z+6, r24	; 0x06
	dataSendBufferHead++;
    1678:	2f 5f       	subi	r18, 0xFF	; 255
    167a:	3f 4f       	sbci	r19, 0xFF	; 255
    167c:	30 93 59 0d 	sts	0x0D59, r19
    1680:	20 93 58 0d 	sts	0x0D58, r18
}
    1684:	08 95       	ret

00001686 <receiveDatamaintain>:
            }
		}	   
	}  
}
void receiveDatamaintain()
{
    1686:	df 92       	push	r13
    1688:	ef 92       	push	r14
    168a:	ff 92       	push	r15
    168c:	0f 93       	push	r16
    168e:	1f 93       	push	r17
    1690:	cf 93       	push	r28
    1692:	df 93       	push	r29
	while(rx_pool_network_maintain_buf_head!=0)
    {
		rx_pool_network_maintain_buf_head--;
		if(rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[3]== PanIdL && rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[4]==PanIdH
    1694:	54 e1       	ldi	r21, 0x14	; 20
    1696:	e5 2e       	mov	r14, r21
    1698:	f1 2c       	mov	r15, r1
				attri==0;
				comPrintString("\r\n>>I am not the biggest~~~");
			}
			if(((rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[7]+rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[8]*256)==sAddr-1)&&sAddr!=0x0000)
			{
				NetWorkFlag=1;
    169a:	dd 24       	eor	r13, r13
    169c:	d3 94       	inc	r13
    169e:	5e c0       	rjmp	.+188    	; 0x175c <receiveDatamaintain+0xd6>
		}	   
	}  
}
void receiveDatamaintain()
{
	while(rx_pool_network_maintain_buf_head!=0)
    16a0:	21 50       	subi	r18, 0x01	; 1
    {
		rx_pool_network_maintain_buf_head--;
		if(rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[3]== PanIdL && rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[4]==PanIdH
    16a2:	82 2f       	mov	r24, r18
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	8e 9d       	mul	r24, r14
    16a8:	f0 01       	movw	r30, r0
    16aa:	8f 9d       	mul	r24, r15
    16ac:	f0 0d       	add	r31, r0
    16ae:	9e 9d       	mul	r25, r14
    16b0:	f0 0d       	add	r31, r0
    16b2:	11 24       	eor	r1, r1
    16b4:	ed 54       	subi	r30, 0x4D	; 77
    16b6:	ff 4e       	sbci	r31, 0xEF	; 239
    16b8:	83 81       	ldd	r24, Z+3	; 0x03
    16ba:	8c 3c       	cpi	r24, 0xCC	; 204
    16bc:	09 f0       	breq	.+2      	; 0x16c0 <receiveDatamaintain+0x3a>
    16be:	50 c0       	rjmp	.+160    	; 0x1760 <receiveDatamaintain+0xda>
    16c0:	84 81       	ldd	r24, Z+4	; 0x04
    16c2:	8e 3e       	cpi	r24, 0xEE	; 238
    16c4:	09 f0       	breq	.+2      	; 0x16c8 <receiveDatamaintain+0x42>
    16c6:	4c c0       	rjmp	.+152    	; 0x1760 <receiveDatamaintain+0xda>
    16c8:	81 85       	ldd	r24, Z+9	; 0x09
    16ca:	8f 3f       	cpi	r24, 0xFF	; 255
    16cc:	09 f0       	breq	.+2      	; 0x16d0 <receiveDatamaintain+0x4a>
    16ce:	48 c0       	rjmp	.+144    	; 0x1760 <receiveDatamaintain+0xda>
    16d0:	82 85       	ldd	r24, Z+10	; 0x0a
    16d2:	8f 3f       	cpi	r24, 0xFF	; 255
    16d4:	09 f0       	breq	.+2      	; 0x16d8 <receiveDatamaintain+0x52>
    16d6:	44 c0       	rjmp	.+136    	; 0x1760 <receiveDatamaintain+0xda>
    16d8:	83 85       	ldd	r24, Z+11	; 0x0b
    16da:	88 23       	and	r24, r24
    16dc:	09 f0       	breq	.+2      	; 0x16e0 <receiveDatamaintain+0x5a>
    16de:	40 c0       	rjmp	.+128    	; 0x1760 <receiveDatamaintain+0xda>
    16e0:	20 93 56 0d 	sts	0x0D56, r18
		&&rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[9]== 0xFF &&rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[10]==0xFF &&
		rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[11]==SCMD_SADDR_BROADCAST )//收到短地址广播	
		{	
			if((rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[7]+rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[8]*256)<sAddr
    16e4:	10 85       	ldd	r17, Z+8	; 0x08
    16e6:	00 e0       	ldi	r16, 0x00	; 0
    16e8:	87 81       	ldd	r24, Z+7	; 0x07
    16ea:	a8 01       	movw	r20, r16
    16ec:	48 0f       	add	r20, r24
    16ee:	51 1d       	adc	r21, r1
    16f0:	20 91 fc 0b 	lds	r18, 0x0BFC
    16f4:	30 91 fd 0b 	lds	r19, 0x0BFD
    16f8:	42 17       	cp	r20, r18
    16fa:	53 07       	cpc	r21, r19
    16fc:	28 f4       	brcc	.+10     	; 0x1708 <receiveDatamaintain+0x82>
    16fe:	84 85       	ldd	r24, Z+12	; 0x0c
    1700:	81 30       	cpi	r24, 0x01	; 1
    1702:	11 f4       	brne	.+4      	; 0x1708 <receiveDatamaintain+0x82>
			&&rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[12]==1)
			{ 
				GotoStartFlag=1; 
    1704:	80 93 54 0d 	sts	0x0D54, r24
			}
			if(((rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[7]+rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[8]*256)==sAddr+1))
    1708:	2f 5f       	subi	r18, 0xFF	; 255
    170a:	3f 4f       	sbci	r19, 0xFF	; 255
    170c:	42 17       	cp	r20, r18
    170e:	53 07       	cpc	r21, r19
    1710:	31 f4       	brne	.+12     	; 0x171e <receiveDatamaintain+0x98>
			{
				MaxNodeFlag=0;
    1712:	10 92 8d 13 	sts	0x138D, r1
				attri==0;
				comPrintString("\r\n>>I am not the biggest~~~");
    1716:	82 e1       	ldi	r24, 0x12	; 18
    1718:	92 e0       	ldi	r25, 0x02	; 2
    171a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			}
			if(((rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[7]+rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[8]*256)==sAddr-1)&&sAddr!=0x0000)
    171e:	80 91 56 0d 	lds	r24, 0x0D56
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	40 91 fc 0b 	lds	r20, 0x0BFC
    1728:	50 91 fd 0b 	lds	r21, 0x0BFD
    172c:	8e 9d       	mul	r24, r14
    172e:	f0 01       	movw	r30, r0
    1730:	8f 9d       	mul	r24, r15
    1732:	f0 0d       	add	r31, r0
    1734:	9e 9d       	mul	r25, r14
    1736:	f0 0d       	add	r31, r0
    1738:	11 24       	eor	r1, r1
    173a:	ed 54       	subi	r30, 0x4D	; 77
    173c:	ff 4e       	sbci	r31, 0xEF	; 239
    173e:	d0 85       	ldd	r29, Z+8	; 0x08
    1740:	c0 e0       	ldi	r28, 0x00	; 0
    1742:	87 81       	ldd	r24, Z+7	; 0x07
    1744:	9e 01       	movw	r18, r28
    1746:	28 0f       	add	r18, r24
    1748:	31 1d       	adc	r19, r1
    174a:	ca 01       	movw	r24, r20
    174c:	01 97       	sbiw	r24, 0x01	; 1
    174e:	28 17       	cp	r18, r24
    1750:	39 07       	cpc	r19, r25
    1752:	21 f4       	brne	.+8      	; 0x175c <receiveDatamaintain+0xd6>
    1754:	45 2b       	or	r20, r21
    1756:	11 f0       	breq	.+4      	; 0x175c <receiveDatamaintain+0xd6>
			{
				NetWorkFlag=1;
    1758:	d0 92 55 0d 	sts	0x0D55, r13
    175c:	20 91 56 0d 	lds	r18, 0x0D56
		}	   
	}  
}
void receiveDatamaintain()
{
	while(rx_pool_network_maintain_buf_head!=0)
    1760:	22 23       	and	r18, r18
    1762:	09 f0       	breq	.+2      	; 0x1766 <receiveDatamaintain+0xe0>
    1764:	9d cf       	rjmp	.-198    	; 0x16a0 <receiveDatamaintain+0x1a>
    1766:	10 92 56 0d 	sts	0x0D56, r1
			{
				NetWorkFlag=1;
			}
		}		
	}		
}
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	1f 91       	pop	r17
    1770:	0f 91       	pop	r16
    1772:	ff 90       	pop	r15
    1774:	ef 90       	pop	r14
    1776:	df 90       	pop	r13
    1778:	08 95       	ret

0000177a <setShortAddress>:
	}
    BusyTxSending=0;
}
void setShortAddress(uint16_t newShortAddress)
{
	tat_set_short_address(newShortAddress);
    177a:	0e 94 2d 09 	call	0x125a	; 0x125a <tat_set_short_address>
	sAddr=tat_get_short_address();
    177e:	0e 94 cf 09 	call	0x139e	; 0x139e <tat_get_short_address>
    1782:	90 93 fd 0b 	sts	0x0BFD, r25
    1786:	80 93 fc 0b 	sts	0x0BFC, r24
}
    178a:	08 95       	ret

0000178c <SendConfirm>:
	dataSendBuffer[dataSendBufferHead].data[3]=data[3];
	dataSendBuffer[dataSendBufferHead].data[4]=data[4];
	dataSendBufferHead++;
}
void SendConfirm(uint16_t DetAddr,uint8_t Confirm,uint8_t rssi)
{
    178c:	cf 93       	push	r28
    178e:	df 93       	push	r29
	int i;
	tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
    1790:	21 e6       	ldi	r18, 0x61	; 97
    1792:	20 93 d0 0d 	sts	0x0DD0, r18
    tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
    1796:	28 e8       	ldi	r18, 0x88	; 136
    1798:	20 93 d1 0d 	sts	0x0DD1, r18
    tx_frame[2]= 0; //封包序列号
    179c:	10 92 d2 0d 	sts	0x0DD2, r1
    tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
    17a0:	2c ec       	ldi	r18, 0xCC	; 204
    17a2:	20 93 d3 0d 	sts	0x0DD3, r18
    tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
    17a6:	2e ee       	ldi	r18, 0xEE	; 238
    17a8:	20 93 d4 0d 	sts	0x0DD4, r18
    tx_frame[5] = DetAddr; //目标短地址低8位.
    17ac:	80 93 d5 0d 	sts	0x0DD5, r24
    tx_frame[6] = (DetAddr)>>8 & 0xFF; //目标短地址高8位
    17b0:	90 93 d6 0d 	sts	0x0DD6, r25
    tx_frame[7] = sAddr& 0xFF; //发送源短地址低8位
    17b4:	80 91 fc 0b 	lds	r24, 0x0BFC
    17b8:	90 91 fd 0b 	lds	r25, 0x0BFD
    17bc:	80 93 d7 0d 	sts	0x0DD7, r24
    tx_frame[8] = (sAddr>>8)& 0xFF; //发送源短地址高8位
    17c0:	90 93 d8 0d 	sts	0x0DD8, r25
    tx_frame[9]=0xFF;
    17c4:	8f ef       	ldi	r24, 0xFF	; 255
    17c6:	80 93 d9 0d 	sts	0x0DD9, r24
	tx_frame[10]=0xFF;
    17ca:	80 93 da 0d 	sts	0x0DDA, r24
	tx_frame[11]=Confirm;
    17ce:	60 93 db 0d 	sts	0x0DDB, r22
    tx_frame[12]=rssi;
    17d2:	40 93 dc 0d 	sts	0x0DDC, r20
	if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
    17d6:	89 e0       	ldi	r24, 0x09	; 9
    17d8:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    17dc:	80 34       	cpi	r24, 0x40	; 64
    17de:	11 f5       	brne	.+68     	; 0x1824 <SendConfirm+0x98>
    {
     	rx_flag = false;
    17e0:	10 92 52 0e 	sts	0x0E52, r1
	  if (tat_send_data( 15, tx_frame) == TAT_SUCCESS) 
    17e4:	8f e0       	ldi	r24, 0x0F	; 15
    17e6:	60 ed       	ldi	r22, 0xD0	; 208
    17e8:	7d e0       	ldi	r23, 0x0D	; 13
    17ea:	0e 94 20 07 	call	0xe40	; 0xe40 <tat_send_data>
    17ee:	80 34       	cpi	r24, 0x40	; 64
    17f0:	b1 f4       	brne	.+44     	; 0x181e <SendConfirm+0x92>
	  {	   
	     comPrintString("\r\n<<");
    17f2:	8e e2       	ldi	r24, 0x2E	; 46
    17f4:	92 e0       	ldi	r25, 0x02	; 2
    17f6:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    17fa:	c0 ed       	ldi	r28, 0xD0	; 208
    17fc:	dd e0       	ldi	r29, 0x0D	; 13
		 for(i=0;i<=12;i++)
		 {
				com_send_hex(tx_frame[i]);
    17fe:	89 91       	ld	r24, Y+
    1800:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
			comPrintString(" ");
    1804:	83 e3       	ldi	r24, 0x33	; 51
    1806:	92 e0       	ldi	r25, 0x02	; 2
    1808:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    {
     	rx_flag = false;
	  if (tat_send_data( 15, tx_frame) == TAT_SUCCESS) 
	  {	   
	     comPrintString("\r\n<<");
		 for(i=0;i<=12;i++)
    180c:	8d e0       	ldi	r24, 0x0D	; 13
    180e:	cd 3d       	cpi	r28, 0xDD	; 221
    1810:	d8 07       	cpc	r29, r24
    1812:	a9 f7       	brne	.-22     	; 0x17fe <SendConfirm+0x72>
    1814:	80 e0       	ldi	r24, 0x00	; 0
    1816:	90 e9       	ldi	r25, 0x90	; 144
    1818:	01 97       	sbiw	r24, 0x01	; 1
    181a:	f1 f7       	brne	.-4      	; 0x1818 <SendConfirm+0x8c>
    181c:	07 c0       	rjmp	.+14     	; 0x182c <SendConfirm+0xa0>
			comPrintString(" ");
	 	 }
			delay_ms(20);
		 } 
		 else 
			comPrintString("\r\n!<Sent Failed");
    181e:	85 e3       	ldi	r24, 0x35	; 53
    1820:	92 e0       	ldi	r25, 0x02	; 2
    1822:	02 c0       	rjmp	.+4      	; 0x1828 <SendConfirm+0x9c>
    }
    else 
	   comPrintString("\r\n!!State Change Failed");
    1824:	85 e4       	ldi	r24, 0x45	; 69
    1826:	92 e0       	ldi	r25, 0x02	; 2
    1828:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    182c:	86 e1       	ldi	r24, 0x16	; 22
    182e:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    1832:	80 34       	cpi	r24, 0x40	; 64
    1834:	21 f0       	breq	.+8      	; 0x183e <SendConfirm+0xb2>
	   comPrintString("\r\n!!State Change Failed");
    1836:	85 e4       	ldi	r24, 0x45	; 69
    1838:	92 e0       	ldi	r25, 0x02	; 2
    183a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    rx_flag = true; // Set the flag back again. Only used to protec t
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	80 93 52 0e 	sts	0x0E52, r24
}
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	08 95       	ret

0000184a <SendWild>:
			}// end: if (rx_pool_head->crc == true) ...
		} // end: if (rx_pool_items_free == 0) ...
	} // end:  if (rx_flag == true) ...
}
void SendWild(uint16_t dAddr,uint8_t Wild)
{
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
	int i;
	tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
    184e:	21 e6       	ldi	r18, 0x61	; 97
    1850:	20 93 d0 0d 	sts	0x0DD0, r18
	tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
    1854:	28 e8       	ldi	r18, 0x88	; 136
    1856:	20 93 d1 0d 	sts	0x0DD1, r18
	tx_frame[2]= 0; //封包序列号
    185a:	10 92 d2 0d 	sts	0x0DD2, r1
    tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
    185e:	2c ec       	ldi	r18, 0xCC	; 204
    1860:	20 93 d3 0d 	sts	0x0DD3, r18
    tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
    1864:	2e ee       	ldi	r18, 0xEE	; 238
    1866:	20 93 d4 0d 	sts	0x0DD4, r18
	tx_frame[5] = dAddr& 0xFF; //目标短地址低8位.
    186a:	80 93 d5 0d 	sts	0x0DD5, r24
	tx_frame[6] = (dAddr>>8)& 0xFF& 0xFF; //目标短地址高8位
    186e:	90 93 d6 0d 	sts	0x0DD6, r25
	tx_frame[7] = sAddr& 0xFF; //发送源短地址低8位
    1872:	80 91 fc 0b 	lds	r24, 0x0BFC
    1876:	90 91 fd 0b 	lds	r25, 0x0BFD
    187a:	80 93 d7 0d 	sts	0x0DD7, r24
    tx_frame[8] = (sAddr>>8)& 0xFF; //发送源短地址高8位
    187e:	90 93 d8 0d 	sts	0x0DD8, r25
    tx_frame[9] =0xFF;		   
    1882:	8f ef       	ldi	r24, 0xFF	; 255
    1884:	80 93 d9 0d 	sts	0x0DD9, r24
    tx_frame[10]=0xFF;
    1888:	80 93 da 0d 	sts	0x0DDA, r24
	tx_frame[11]=Wild;
    188c:	60 93 db 0d 	sts	0x0DDB, r22
	tx_frame[12]=attri;
    1890:	80 91 4c 0d 	lds	r24, 0x0D4C
    1894:	80 93 dc 0d 	sts	0x0DDC, r24
	tx_frame[13]=Comparerssi;
    1898:	80 91 4d 0d 	lds	r24, 0x0D4D
    189c:	80 93 dd 0d 	sts	0x0DDD, r24
    18a0:	84 ef       	ldi	r24, 0xF4	; 244
    18a2:	91 e0       	ldi	r25, 0x01	; 1
    18a4:	28 eb       	ldi	r18, 0xB8	; 184
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	f9 01       	movw	r30, r18
    18aa:	31 97       	sbiw	r30, 0x01	; 1
    18ac:	f1 f7       	brne	.-4      	; 0x18aa <SendWild+0x60>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18b0:	d9 f7       	brne	.-10     	; 0x18a8 <SendWild+0x5e>
	delay_ms(50);
	if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
    18b2:	89 e0       	ldi	r24, 0x09	; 9
    18b4:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    18b8:	80 34       	cpi	r24, 0x40	; 64
    18ba:	11 f5       	brne	.+68     	; 0x1900 <SendWild+0xb6>
    {
      rx_flag = false;
    18bc:	10 92 52 0e 	sts	0x0E52, r1
	  if (tat_send_data( 16, tx_frame) == TAT_SUCCESS) 
    18c0:	80 e1       	ldi	r24, 0x10	; 16
    18c2:	60 ed       	ldi	r22, 0xD0	; 208
    18c4:	7d e0       	ldi	r23, 0x0D	; 13
    18c6:	0e 94 20 07 	call	0xe40	; 0xe40 <tat_send_data>
    18ca:	80 34       	cpi	r24, 0x40	; 64
    18cc:	b1 f4       	brne	.+44     	; 0x18fa <SendWild+0xb0>
	  {	   
		 comPrintString("\r\n<<Sendwild::::::::");
    18ce:	8d e5       	ldi	r24, 0x5D	; 93
    18d0:	92 e0       	ldi	r25, 0x02	; 2
    18d2:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    18d6:	c0 ed       	ldi	r28, 0xD0	; 208
    18d8:	dd e0       	ldi	r29, 0x0D	; 13
		 for(i=0;i<=13;i++)
		 {
			com_send_hex(tx_frame[i]);
    18da:	89 91       	ld	r24, Y+
    18dc:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
			comPrintString(" ");
    18e0:	83 e3       	ldi	r24, 0x33	; 51
    18e2:	92 e0       	ldi	r25, 0x02	; 2
    18e4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    {
      rx_flag = false;
	  if (tat_send_data( 16, tx_frame) == TAT_SUCCESS) 
	  {	   
		 comPrintString("\r\n<<Sendwild::::::::");
		 for(i=0;i<=13;i++)
    18e8:	8d e0       	ldi	r24, 0x0D	; 13
    18ea:	ce 3d       	cpi	r28, 0xDE	; 222
    18ec:	d8 07       	cpc	r29, r24
    18ee:	a9 f7       	brne	.-22     	; 0x18da <SendWild+0x90>
    18f0:	80 e0       	ldi	r24, 0x00	; 0
    18f2:	90 e9       	ldi	r25, 0x90	; 144
    18f4:	01 97       	sbiw	r24, 0x01	; 1
    18f6:	f1 f7       	brne	.-4      	; 0x18f4 <SendWild+0xaa>
    18f8:	07 c0       	rjmp	.+14     	; 0x1908 <SendWild+0xbe>
			comPrintString(" ");
	 	 }
			delay_ms(20);
		 } 
		 else 
			 comPrintString("\r\n!<Sent Failed");
    18fa:	85 e3       	ldi	r24, 0x35	; 53
    18fc:	92 e0       	ldi	r25, 0x02	; 2
    18fe:	02 c0       	rjmp	.+4      	; 0x1904 <SendWild+0xba>
    }
    else 
	   comPrintString("\r\n!!State Change Failed");
    1900:	85 e4       	ldi	r24, 0x45	; 69
    1902:	92 e0       	ldi	r25, 0x02	; 2
    1904:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    1908:	86 e1       	ldi	r24, 0x16	; 22
    190a:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    190e:	80 34       	cpi	r24, 0x40	; 64
    1910:	21 f0       	breq	.+8      	; 0x191a <SendWild+0xd0>
	   comPrintString("\r\n!!State Change Failed");
    1912:	85 e4       	ldi	r24, 0x45	; 69
    1914:	92 e0       	ldi	r25, 0x02	; 2
    1916:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    rx_flag = true; // Set the flag back again. Only used to protect			
    191a:	81 e0       	ldi	r24, 0x01	; 1
    191c:	80 93 52 0e 	sts	0x0E52, r24
}
    1920:	df 91       	pop	r29
    1922:	cf 91       	pop	r28
    1924:	08 95       	ret

00001926 <receiveData>:
    if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
	   comPrintString("\r\n!!State Change Failed");
    rx_flag = true; // Set the flag back again. Only used to protec t
}
void receiveData()
{
    1926:	2f 92       	push	r2
    1928:	3f 92       	push	r3
    192a:	4f 92       	push	r4
    192c:	5f 92       	push	r5
    192e:	6f 92       	push	r6
    1930:	7f 92       	push	r7
    1932:	8f 92       	push	r8
    1934:	9f 92       	push	r9
    1936:	af 92       	push	r10
    1938:	bf 92       	push	r11
    193a:	cf 92       	push	r12
    193c:	df 92       	push	r13
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	df 93       	push	r29
    1948:	cf 93       	push	r28
    194a:	cd b7       	in	r28, 0x3d	; 61
    194c:	de b7       	in	r29, 0x3e	; 62
    194e:	c5 52       	subi	r28, 0x25	; 37
    1950:	d2 40       	sbci	r29, 0x02	; 2
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	de bf       	out	0x3e, r29	; 62
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	cd bf       	out	0x3d, r28	; 61
    PrepReceiveNew t_buf[RX_POOL_SIZE];
	PrepReceiveNew h_buf[RX_POOL_SIZE];
    short int n_buf_head=0;
	short int t_buf_head=0;    
	short int h_buf_head=0;
	comPrintString("\r\n!!into times:");
    195c:	82 e7       	ldi	r24, 0x72	; 114
    195e:	92 e0       	ldi	r25, 0x02	; 2
    1960:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(j);
    1964:	80 91 5b 0d 	lds	r24, 0x0D5B
    1968:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~");
    196c:	82 e8       	ldi	r24, 0x82	; 130
    196e:	92 e0       	ldi	r25, 0x02	; 2
    1970:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	j++;
    1974:	80 91 5b 0d 	lds	r24, 0x0D5B
    1978:	90 91 5c 0d 	lds	r25, 0x0D5C
    197c:	01 96       	adiw	r24, 0x01	; 1
    197e:	90 93 5c 0d 	sts	0x0D5C, r25
    1982:	80 93 5b 0d 	sts	0x0D5B, r24
    1986:	88 24       	eor	r8, r8
    1988:	99 24       	eor	r9, r9
    198a:	aa 24       	eor	r10, r10
    198c:	bb 24       	eor	r11, r11
    198e:	66 24       	eor	r6, r6
    1990:	ee 24       	eor	r14, r14
    1992:	cd 5d       	subi	r28, 0xDD	; 221
    1994:	dd 4f       	sbci	r29, 0xFD	; 253
    1996:	18 82       	st	Y, r1
    1998:	c3 52       	subi	r28, 0x23	; 35
    199a:	d2 40       	sbci	r29, 0x02	; 2
    199c:	2c ef       	ldi	r18, 0xFC	; 252
    199e:	3f ef       	ldi	r19, 0xFF	; 255
    19a0:	cf 5d       	subi	r28, 0xDF	; 223
    19a2:	dd 4f       	sbci	r29, 0xFD	; 253
    19a4:	39 83       	std	Y+1, r19	; 0x01
    19a6:	28 83       	st	Y, r18
    19a8:	c1 52       	subi	r28, 0x21	; 33
    19aa:	d2 40       	sbci	r29, 0x02	; 2
    19ac:	c1 5e       	subi	r28, 0xE1	; 225
    19ae:	dd 4f       	sbci	r29, 0xFD	; 253
    19b0:	39 83       	std	Y+1, r19	; 0x01
    19b2:	28 83       	st	Y, r18
    19b4:	cf 51       	subi	r28, 0x1F	; 31
    19b6:	d2 40       	sbci	r29, 0x02	; 2
    19b8:	c3 5e       	subi	r28, 0xE3	; 227
    19ba:	dd 4f       	sbci	r29, 0xFD	; 253
    19bc:	39 83       	std	Y+1, r19	; 0x01
    19be:	28 83       	st	Y, r18
    19c0:	cd 51       	subi	r28, 0x1D	; 29
    19c2:	d2 40       	sbci	r29, 0x02	; 2
    19c4:	cc 24       	eor	r12, r12
    19c6:	dd 24       	eor	r13, r13
    19c8:	fa c3       	rjmp	.+2036   	; 0x21be <receiveData+0x898>
    while (rx_pool_items_used != 0) //查看接收池中是否有未处理的包
	{   
	    comPrintString("\r\n!!rx_pool_items_used::::::::::");
    19ca:	8e ea       	ldi	r24, 0xAE	; 174
    19cc:	92 e0       	ldi	r25, 0x02	; 2
    19ce:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_hex(rx_pool_items_used);
    19d2:	80 91 50 0e 	lds	r24, 0x0E50
    19d6:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	}
	return i;
}
void readRxPool(void)
{
	hal_set_data_led();//亮灯,表示收到信息
    19da:	2e 98       	cbi	0x05, 6	; 5
	if (rx_pool_tail == rx_pool_end) 
    19dc:	20 91 b1 10 	lds	r18, 0x10B1
    19e0:	30 91 b2 10 	lds	r19, 0x10B2
    19e4:	80 91 ad 10 	lds	r24, 0x10AD
    19e8:	90 91 ae 10 	lds	r25, 0x10AE
    19ec:	28 17       	cp	r18, r24
    19ee:	39 07       	cpc	r19, r25
    19f0:	49 f4       	brne	.+18     	; 0x1a04 <receiveData+0xde>
	{
		rx_pool_tail = rx_pool_start;
    19f2:	80 91 ab 10 	lds	r24, 0x10AB
    19f6:	90 91 ac 10 	lds	r25, 0x10AC
    19fa:	90 93 b2 10 	sts	0x10B2, r25
    19fe:	80 93 b1 10 	sts	0x10B1, r24
    1a02:	06 c0       	rjmp	.+12     	; 0x1a10 <receiveData+0xea>
	} 
	else 
	{
		++rx_pool_tail;
    1a04:	2c 5e       	subi	r18, 0xEC	; 236
    1a06:	3f 4f       	sbci	r19, 0xFF	; 255
    1a08:	30 93 b2 10 	sts	0x10B2, r19
    1a0c:	20 93 b1 10 	sts	0x10B1, r18
	} 
	cli( );
    1a10:	f8 94       	cli
	++rx_pool_items_free;
    1a12:	80 91 4f 0e 	lds	r24, 0x0E4F
    1a16:	8f 5f       	subi	r24, 0xFF	; 255
    1a18:	80 93 4f 0e 	sts	0x0E4F, r24
	--rx_pool_items_used;
    1a1c:	80 91 50 0e 	lds	r24, 0x0E50
    1a20:	81 50       	subi	r24, 0x01	; 1
    1a22:	80 93 50 0e 	sts	0x0E50, r24
	sei( );//接收池中数据出队
    1a26:	78 94       	sei
	hal_clear_data_led();//灭灯
    1a28:	2e 9a       	sbi	0x05, 6	; 5
	{   
	    comPrintString("\r\n!!rx_pool_items_used::::::::::");
		com_send_hex(rx_pool_items_used);
	    readRxPool();				
		//读取缓存区，接收到的数据会被储存在rx_pool_tail->data[]中
		comPrintString("\r\n>>Data Received::");
    1a2a:	8f ec       	ldi	r24, 0xCF	; 207
    1a2c:	92 e0       	ldi	r25, 0x02	; 2
    1a2e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    1a32:	00 e0       	ldi	r16, 0x00	; 0
    1a34:	10 e0       	ldi	r17, 0x00	; 0
		for(i=0;i<=15;i++)
		{
			com_send_hex(rx_pool_tail->data[i]);
    1a36:	e0 91 b1 10 	lds	r30, 0x10B1
    1a3a:	f0 91 b2 10 	lds	r31, 0x10B2
    1a3e:	e0 0f       	add	r30, r16
    1a40:	f1 1f       	adc	r31, r17
    1a42:	80 81       	ld	r24, Z
    1a44:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
			comPrintString(" ");
    1a48:	83 e3       	ldi	r24, 0x33	; 51
    1a4a:	92 e0       	ldi	r25, 0x02	; 2
    1a4c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	    comPrintString("\r\n!!rx_pool_items_used::::::::::");
		com_send_hex(rx_pool_items_used);
	    readRxPool();				
		//读取缓存区，接收到的数据会被储存在rx_pool_tail->data[]中
		comPrintString("\r\n>>Data Received::");
		for(i=0;i<=15;i++)
    1a50:	0f 5f       	subi	r16, 0xFF	; 255
    1a52:	1f 4f       	sbci	r17, 0xFF	; 255
    1a54:	00 31       	cpi	r16, 0x10	; 16
    1a56:	11 05       	cpc	r17, r1
    1a58:	71 f7       	brne	.-36     	; 0x1a36 <receiveData+0x110>
		{
			com_send_hex(rx_pool_tail->data[i]);
			comPrintString(" ");
		}
	    if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_SADDR_BROADCAST_NEW_CONFIRM
    1a5a:	a0 91 b1 10 	lds	r26, 0x10B1
    1a5e:	b0 91 b2 10 	lds	r27, 0x10B2
    1a62:	13 96       	adiw	r26, 0x03	; 3
    1a64:	8c 91       	ld	r24, X
    1a66:	13 97       	sbiw	r26, 0x03	; 3
    1a68:	8c 3c       	cpi	r24, 0xCC	; 204
    1a6a:	09 f0       	breq	.+2      	; 0x1a6e <receiveData+0x148>
    1a6c:	29 c2       	rjmp	.+1106   	; 0x1ec0 <receiveData+0x59a>
    1a6e:	14 96       	adiw	r26, 0x04	; 4
    1a70:	8c 91       	ld	r24, X
    1a72:	14 97       	sbiw	r26, 0x04	; 4
    1a74:	8e 3e       	cpi	r24, 0xEE	; 238
    1a76:	09 f0       	breq	.+2      	; 0x1a7a <receiveData+0x154>
    1a78:	23 c2       	rjmp	.+1094   	; 0x1ec0 <receiveData+0x59a>
    1a7a:	19 96       	adiw	r26, 0x09	; 9
    1a7c:	4c 91       	ld	r20, X
    1a7e:	19 97       	sbiw	r26, 0x09	; 9
    1a80:	4f 3f       	cpi	r20, 0xFF	; 255
    1a82:	09 f0       	breq	.+2      	; 0x1a86 <receiveData+0x160>
    1a84:	4e c1       	rjmp	.+668    	; 0x1d22 <receiveData+0x3fc>
    1a86:	1a 96       	adiw	r26, 0x0a	; 10
    1a88:	8c 91       	ld	r24, X
    1a8a:	1a 97       	sbiw	r26, 0x0a	; 10
    1a8c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a8e:	09 f0       	breq	.+2      	; 0x1a92 <receiveData+0x16c>
    1a90:	50 c0       	rjmp	.+160    	; 0x1b32 <receiveData+0x20c>
    1a92:	1b 96       	adiw	r26, 0x0b	; 11
    1a94:	8c 91       	ld	r24, X
    1a96:	1b 97       	sbiw	r26, 0x0b	; 11
    1a98:	86 30       	cpi	r24, 0x06	; 6
    1a9a:	09 f0       	breq	.+2      	; 0x1a9e <receiveData+0x178>
    1a9c:	4a c0       	rjmp	.+148    	; 0x1b32 <receiveData+0x20c>
    1a9e:	1c 96       	adiw	r26, 0x0c	; 12
    1aa0:	9c 91       	ld	r25, X
    1aa2:	1c 97       	sbiw	r26, 0x0c	; 12
    1aa4:	80 91 4d 0d 	lds	r24, 0x0D4D
    1aa8:	98 17       	cp	r25, r24
    1aaa:	09 f0       	breq	.+2      	; 0x1aae <receiveData+0x188>
    1aac:	42 c0       	rjmp	.+132    	; 0x1b32 <receiveData+0x20c>
		&&rx_pool_tail->data[12]==Comparerssi)//收到SCMD_SADDR_BROADCAST_NEW_CONFIRM反馈
		{
		    if(NewNodeFlag==1)
    1aae:	80 91 4b 0d 	lds	r24, 0x0D4B
    1ab2:	88 23       	and	r24, r24
    1ab4:	09 f4       	brne	.+2      	; 0x1ab8 <receiveData+0x192>
    1ab6:	04 c2       	rjmp	.+1032   	; 0x1ec0 <receiveData+0x59a>
			{	
				comPrintString("\r\n>>Short Address APPLING has been Confirmed...");
    1ab8:	83 ee       	ldi	r24, 0xE3	; 227
    1aba:	92 e0       	ldi	r25, 0x02	; 2
    1abc:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    1ac0:	00 e0       	ldi	r16, 0x00	; 0
    1ac2:	10 e0       	ldi	r17, 0x00	; 0
    1ac4:	12 c0       	rjmp	.+36     	; 0x1aea <receiveData+0x1c4>
    1ac6:	e8 eb       	ldi	r30, 0xB8	; 184
    1ac8:	f0 e0       	ldi	r31, 0x00	; 0
    1aca:	31 97       	sbiw	r30, 0x01	; 1
    1acc:	f1 f7       	brne	.-4      	; 0x1aca <receiveData+0x1a4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ace:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ad0:	d1 f7       	brne	.-12     	; 0x1ac6 <receiveData+0x1a0>
				for(i=0;i<Broad_Cover_Times;i++)//连续发送Broad_Cover_Times个TPU的短地址占用广播
				{
					delay_ms(TPU);
					SendWild(sAddr,SCMD_SADDR_BROADCAST);
    1ad2:	80 91 fc 0b 	lds	r24, 0x0BFC
    1ad6:	90 91 fd 0b 	lds	r25, 0x0BFD
    1ada:	60 e0       	ldi	r22, 0x00	; 0
    1adc:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		&&rx_pool_tail->data[12]==Comparerssi)//收到SCMD_SADDR_BROADCAST_NEW_CONFIRM反馈
		{
		    if(NewNodeFlag==1)
			{	
				comPrintString("\r\n>>Short Address APPLING has been Confirmed...");
				for(i=0;i<Broad_Cover_Times;i++)//连续发送Broad_Cover_Times个TPU的短地址占用广播
    1ae0:	0f 5f       	subi	r16, 0xFF	; 255
    1ae2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae4:	04 31       	cpi	r16, 0x14	; 20
    1ae6:	11 05       	cpc	r17, r1
    1ae8:	19 f0       	breq	.+6      	; 0x1af0 <receiveData+0x1ca>
    1aea:	88 eb       	ldi	r24, 0xB8	; 184
    1aec:	9b e0       	ldi	r25, 0x0B	; 11
    1aee:	eb cf       	rjmp	.-42     	; 0x1ac6 <receiveData+0x1a0>
				{
					delay_ms(TPU);
					SendWild(sAddr,SCMD_SADDR_BROADCAST);
				}
			    cli();
    1af0:	f8 94       	cli
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    1af2:	83 e5       	ldi	r24, 0x53	; 83
    1af4:	9e e0       	ldi	r25, 0x0E	; 14
    1af6:	90 93 ac 10 	sts	0x10AC, r25
    1afa:	80 93 ab 10 	sts	0x10AB, r24
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    1afe:	e7 e9       	ldi	r30, 0x97	; 151
    1b00:	f0 e1       	ldi	r31, 0x10	; 16
    1b02:	f0 93 ae 10 	sts	0x10AE, r31
    1b06:	e0 93 ad 10 	sts	0x10AD, r30
    rx_pool_head = rx_pool_start;
    1b0a:	90 93 b0 10 	sts	0x10B0, r25
    1b0e:	80 93 af 10 	sts	0x10AF, r24
	rx_pool_tail = rx_pool_end;
    1b12:	f0 93 b2 10 	sts	0x10B2, r31
    1b16:	e0 93 b1 10 	sts	0x10B1, r30
	rx_pool_items_free = RX_POOL_SIZE;
    1b1a:	8e e1       	ldi	r24, 0x1E	; 30
    1b1c:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    1b20:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    1b24:	10 92 51 0e 	sts	0x0E51, r1
					delay_ms(TPU);
					SendWild(sAddr,SCMD_SADDR_BROADCAST);
				}
			    cli();
				rx_pool_init( );
				sei();
    1b28:	78 94       	sei
	            NewConfirmFlag=1;
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	80 93 51 0d 	sts	0x0D51, r24
    1b30:	c7 c1       	rjmp	.+910    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_TAIL_FIRST_COME
    1b32:	1a 96       	adiw	r26, 0x0a	; 10
    1b34:	8c 91       	ld	r24, X
    1b36:	1a 97       	sbiw	r26, 0x0a	; 10
    1b38:	8f 3f       	cpi	r24, 0xFF	; 255
    1b3a:	31 f5       	brne	.+76     	; 0x1b88 <receiveData+0x262>
    1b3c:	1b 96       	adiw	r26, 0x0b	; 11
    1b3e:	8c 91       	ld	r24, X
    1b40:	1b 97       	sbiw	r26, 0x0b	; 11
    1b42:	80 31       	cpi	r24, 0x10	; 16
    1b44:	09 f5       	brne	.+66     	; 0x1b88 <receiveData+0x262>
    1b46:	17 96       	adiw	r26, 0x07	; 7
    1b48:	8c 91       	ld	r24, X
    1b4a:	17 97       	sbiw	r26, 0x07	; 7
    1b4c:	90 e0       	ldi	r25, 0x00	; 0
    1b4e:	20 91 fc 0b 	lds	r18, 0x0BFC
    1b52:	30 91 fd 0b 	lds	r19, 0x0BFD
    1b56:	82 17       	cp	r24, r18
    1b58:	93 07       	cpc	r25, r19
    1b5a:	b1 f4       	brne	.+44     	; 0x1b88 <receiveData+0x262>
    1b5c:	18 96       	adiw	r26, 0x08	; 8
    1b5e:	8c 91       	ld	r24, X
    1b60:	18 97       	sbiw	r26, 0x08	; 8
    1b62:	88 23       	and	r24, r24
    1b64:	89 f4       	brne	.+34     	; 0x1b88 <receiveData+0x262>
		&&rx_pool_tail->data[7]==sAddr&0xFF && rx_pool_tail->data[8]==(sAddr>>8)&0xFF)//收到SCMD_TAIL_FIRST_COME
		{
		 	if(NewNodeFlag==1)
    1b66:	80 91 4b 0d 	lds	r24, 0x0D4B
    1b6a:	88 23       	and	r24, r24
    1b6c:	09 f4       	brne	.+2      	; 0x1b70 <receiveData+0x24a>
    1b6e:	a8 c1       	rjmp	.+848    	; 0x1ec0 <receiveData+0x59a>
			{
				comPrintString("\r\n>>SCMD_TAIL_FIRST_COME has been received...");
    1b70:	83 e1       	ldi	r24, 0x13	; 19
    1b72:	93 e0       	ldi	r25, 0x03	; 3
    1b74:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				comPrintString("\r\n>>I have to goto start.....");
    1b78:	81 e4       	ldi	r24, 0x41	; 65
    1b7a:	93 e0       	ldi	r25, 0x03	; 3
    1b7c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			    FirstTailFlag=1;
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	80 93 4e 0d 	sts	0x0D4E, r24
    1b86:	9c c1       	rjmp	.+824    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_HEAD_FIRST_COME
    1b88:	1a 96       	adiw	r26, 0x0a	; 10
    1b8a:	8c 91       	ld	r24, X
    1b8c:	1a 97       	sbiw	r26, 0x0a	; 10
    1b8e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b90:	31 f5       	brne	.+76     	; 0x1bde <receiveData+0x2b8>
    1b92:	1b 96       	adiw	r26, 0x0b	; 11
    1b94:	8c 91       	ld	r24, X
    1b96:	1b 97       	sbiw	r26, 0x0b	; 11
    1b98:	81 31       	cpi	r24, 0x11	; 17
    1b9a:	09 f5       	brne	.+66     	; 0x1bde <receiveData+0x2b8>
    1b9c:	17 96       	adiw	r26, 0x07	; 7
    1b9e:	8c 91       	ld	r24, X
    1ba0:	17 97       	sbiw	r26, 0x07	; 7
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	20 91 fc 0b 	lds	r18, 0x0BFC
    1ba8:	30 91 fd 0b 	lds	r19, 0x0BFD
    1bac:	82 17       	cp	r24, r18
    1bae:	93 07       	cpc	r25, r19
    1bb0:	b1 f4       	brne	.+44     	; 0x1bde <receiveData+0x2b8>
    1bb2:	18 96       	adiw	r26, 0x08	; 8
    1bb4:	8c 91       	ld	r24, X
    1bb6:	18 97       	sbiw	r26, 0x08	; 8
    1bb8:	88 23       	and	r24, r24
    1bba:	89 f4       	brne	.+34     	; 0x1bde <receiveData+0x2b8>
		&&rx_pool_tail->data[7]==sAddr&0xFF && rx_pool_tail->data[8]==(sAddr>>8)&0xFF)//收到SCMD_HEAD_FIRST_COME
		{
		 	if(NewNodeFlag==1)
    1bbc:	80 91 4b 0d 	lds	r24, 0x0D4B
    1bc0:	88 23       	and	r24, r24
    1bc2:	09 f4       	brne	.+2      	; 0x1bc6 <receiveData+0x2a0>
    1bc4:	7d c1       	rjmp	.+762    	; 0x1ec0 <receiveData+0x59a>
			{
				comPrintString("\r\n>>SCMD_HEAD_FIRST_COME has been received...");
    1bc6:	8f e5       	ldi	r24, 0x5F	; 95
    1bc8:	93 e0       	ldi	r25, 0x03	; 3
    1bca:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				comPrintString("\r\n>>I have to goto start.....");
    1bce:	81 e4       	ldi	r24, 0x41	; 65
    1bd0:	93 e0       	ldi	r25, 0x03	; 3
    1bd2:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			    FirstHeadFlag=1;
    1bd6:	81 e0       	ldi	r24, 0x01	; 1
    1bd8:	80 93 52 0d 	sts	0x0D52, r24
    1bdc:	71 c1       	rjmp	.+738    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_MED_FIRST_COME
    1bde:	1a 96       	adiw	r26, 0x0a	; 10
    1be0:	8c 91       	ld	r24, X
    1be2:	1a 97       	sbiw	r26, 0x0a	; 10
    1be4:	8f 3f       	cpi	r24, 0xFF	; 255
    1be6:	31 f5       	brne	.+76     	; 0x1c34 <receiveData+0x30e>
    1be8:	1b 96       	adiw	r26, 0x0b	; 11
    1bea:	8c 91       	ld	r24, X
    1bec:	1b 97       	sbiw	r26, 0x0b	; 11
    1bee:	82 31       	cpi	r24, 0x12	; 18
    1bf0:	09 f5       	brne	.+66     	; 0x1c34 <receiveData+0x30e>
    1bf2:	17 96       	adiw	r26, 0x07	; 7
    1bf4:	8c 91       	ld	r24, X
    1bf6:	17 97       	sbiw	r26, 0x07	; 7
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	20 91 fc 0b 	lds	r18, 0x0BFC
    1bfe:	30 91 fd 0b 	lds	r19, 0x0BFD
    1c02:	82 17       	cp	r24, r18
    1c04:	93 07       	cpc	r25, r19
    1c06:	b1 f4       	brne	.+44     	; 0x1c34 <receiveData+0x30e>
    1c08:	18 96       	adiw	r26, 0x08	; 8
    1c0a:	8c 91       	ld	r24, X
    1c0c:	18 97       	sbiw	r26, 0x08	; 8
    1c0e:	88 23       	and	r24, r24
    1c10:	89 f4       	brne	.+34     	; 0x1c34 <receiveData+0x30e>
		&&rx_pool_tail->data[7]==sAddr&0xFF && rx_pool_tail->data[8]==(sAddr>>8)&0xFF)//收到SCMD_MED_FIRST_COME
		{
		 	if(NewNodeFlag==1)
    1c12:	80 91 4b 0d 	lds	r24, 0x0D4B
    1c16:	88 23       	and	r24, r24
    1c18:	09 f4       	brne	.+2      	; 0x1c1c <receiveData+0x2f6>
    1c1a:	52 c1       	rjmp	.+676    	; 0x1ec0 <receiveData+0x59a>
			{
				comPrintString("\r\n>>SCMD_MED_FIRST_COME has been received...");
    1c1c:	8d e8       	ldi	r24, 0x8D	; 141
    1c1e:	93 e0       	ldi	r25, 0x03	; 3
    1c20:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				comPrintString("\r\n>>I have to goto start.....");
    1c24:	81 e4       	ldi	r24, 0x41	; 65
    1c26:	93 e0       	ldi	r25, 0x03	; 3
    1c28:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			    FirstMedFlag=1;
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	80 93 50 0d 	sts	0x0D50, r24
    1c32:	46 c1       	rjmp	.+652    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_TAIL_OCCUPY_CONFIRM
    1c34:	1a 96       	adiw	r26, 0x0a	; 10
    1c36:	8c 91       	ld	r24, X
    1c38:	1a 97       	sbiw	r26, 0x0a	; 10
    1c3a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3c:	d9 f4       	brne	.+54     	; 0x1c74 <receiveData+0x34e>
    1c3e:	1b 96       	adiw	r26, 0x0b	; 11
    1c40:	8c 91       	ld	r24, X
    1c42:	1b 97       	sbiw	r26, 0x0b	; 11
    1c44:	87 30       	cpi	r24, 0x07	; 7
    1c46:	b1 f4       	brne	.+44     	; 0x1c74 <receiveData+0x34e>
    1c48:	1c 96       	adiw	r26, 0x0c	; 12
    1c4a:	9c 91       	ld	r25, X
    1c4c:	1c 97       	sbiw	r26, 0x0c	; 12
    1c4e:	80 91 4d 0d 	lds	r24, 0x0D4D
    1c52:	98 17       	cp	r25, r24
    1c54:	79 f4       	brne	.+30     	; 0x1c74 <receiveData+0x34e>
		&&rx_pool_tail->data[12]==Comparerssi)//收到SCMD_TAIL_OCCUPY_CONFIRM反馈
		{
		 	if(NewNodeFlag==1)
    1c56:	80 91 4b 0d 	lds	r24, 0x0D4B
    1c5a:	88 23       	and	r24, r24
    1c5c:	09 f4       	brne	.+2      	; 0x1c60 <receiveData+0x33a>
    1c5e:	30 c1       	rjmp	.+608    	; 0x1ec0 <receiveData+0x59a>
			{	
				comPrintString("\r\n>>Tail  APPLING has been Confirmed...");
    1c60:	8a eb       	ldi	r24, 0xBA	; 186
    1c62:	93 e0       	ldi	r25, 0x03	; 3
    1c64:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				TailConfirmFlag=1;
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	80 93 4f 0d 	sts	0x0D4F, r24
				attri=1;
    1c6e:	80 93 4c 0d 	sts	0x0D4C, r24
    1c72:	26 c1       	rjmp	.+588    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_HEAD_OCCUPY_CONFIRM
    1c74:	1a 96       	adiw	r26, 0x0a	; 10
    1c76:	8c 91       	ld	r24, X
    1c78:	1a 97       	sbiw	r26, 0x0a	; 10
    1c7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c7c:	c9 f4       	brne	.+50     	; 0x1cb0 <receiveData+0x38a>
    1c7e:	1b 96       	adiw	r26, 0x0b	; 11
    1c80:	8c 91       	ld	r24, X
    1c82:	1b 97       	sbiw	r26, 0x0b	; 11
    1c84:	89 30       	cpi	r24, 0x09	; 9
    1c86:	a1 f4       	brne	.+40     	; 0x1cb0 <receiveData+0x38a>
    1c88:	1c 96       	adiw	r26, 0x0c	; 12
    1c8a:	9c 91       	ld	r25, X
    1c8c:	1c 97       	sbiw	r26, 0x0c	; 12
    1c8e:	80 91 4d 0d 	lds	r24, 0x0D4D
    1c92:	98 17       	cp	r25, r24
    1c94:	69 f4       	brne	.+26     	; 0x1cb0 <receiveData+0x38a>
		&&rx_pool_tail->data[12]==Comparerssi)//收到SCMD_HEAD_OCCUPY_CONFIRM反馈
		{
		 	if(NewNodeFlag==1)
    1c96:	80 91 4b 0d 	lds	r24, 0x0D4B
    1c9a:	88 23       	and	r24, r24
    1c9c:	09 f4       	brne	.+2      	; 0x1ca0 <receiveData+0x37a>
    1c9e:	10 c1       	rjmp	.+544    	; 0x1ec0 <receiveData+0x59a>
			{	
				comPrintString("\r\n>>Head  APPLING has been Confirmed...");
    1ca0:	82 ee       	ldi	r24, 0xE2	; 226
    1ca2:	93 e0       	ldi	r25, 0x03	; 3
    1ca4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				HeadConfirmFlag=1;
    1ca8:	81 e0       	ldi	r24, 0x01	; 1
    1caa:	80 93 53 0d 	sts	0x0D53, r24
    1cae:	08 c1       	rjmp	.+528    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF 
    1cb0:	1a 96       	adiw	r26, 0x0a	; 10
    1cb2:	8c 91       	ld	r24, X
    1cb4:	1a 97       	sbiw	r26, 0x0a	; 10
    1cb6:	8f 3f       	cpi	r24, 0xFF	; 255
    1cb8:	b1 f5       	brne	.+108    	; 0x1d26 <receiveData+0x400>
    1cba:	1b 96       	adiw	r26, 0x0b	; 11
    1cbc:	8c 91       	ld	r24, X
    1cbe:	1b 97       	sbiw	r26, 0x0b	; 11
    1cc0:	88 30       	cpi	r24, 0x08	; 8
    1cc2:	89 f5       	brne	.+98     	; 0x1d26 <receiveData+0x400>
    1cc4:	80 91 fc 0b 	lds	r24, 0x0BFC
    1cc8:	90 91 fd 0b 	lds	r25, 0x0BFD
    1ccc:	89 2b       	or	r24, r25
    1cce:	59 f5       	brne	.+86     	; 0x1d26 <receiveData+0x400>
		&& rx_pool_tail->data[10]==0xFF &&rx_pool_tail->data[11]==SCMD_HEAD_OCCUPY&&sAddr==0x00)//收到头节点占用广播
		{  
		 	if(NewNodeFlag==0)
    1cd0:	80 91 4b 0d 	lds	r24, 0x0D4B
    1cd4:	88 23       	and	r24, r24
    1cd6:	09 f0       	breq	.+2      	; 0x1cda <receiveData+0x3b4>
    1cd8:	f3 c0       	rjmp	.+486    	; 0x1ec0 <receiveData+0x59a>
			{  	   
			   comPrintString("\r\n>>HEAD OCCUPY Prep Callback Received...");
    1cda:	8a e0       	ldi	r24, 0x0A	; 10
    1cdc:	94 e0       	ldi	r25, 0x04	; 4
    1cde:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			   h_buf[h_buf_head].rAddr[0]=rx_pool_tail->data[7];
    1ce2:	a0 91 b1 10 	lds	r26, 0x10B1
    1ce6:	b0 91 b2 10 	lds	r27, 0x10B2
    1cea:	f5 01       	movw	r30, r10
    1cec:	ee 0f       	add	r30, r30
    1cee:	ff 1f       	adc	r31, r31
    1cf0:	ea 0d       	add	r30, r10
    1cf2:	fb 1d       	adc	r31, r11
    1cf4:	ee 0f       	add	r30, r30
    1cf6:	ff 1f       	adc	r31, r31
    1cf8:	29 e6       	ldi	r18, 0x69	; 105
    1cfa:	31 e0       	ldi	r19, 0x01	; 1
    1cfc:	2c 0f       	add	r18, r28
    1cfe:	3d 1f       	adc	r19, r29
    1d00:	e2 0f       	add	r30, r18
    1d02:	f3 1f       	adc	r31, r19
    1d04:	17 96       	adiw	r26, 0x07	; 7
    1d06:	8c 91       	ld	r24, X
    1d08:	17 97       	sbiw	r26, 0x07	; 7
    1d0a:	80 83       	st	Z, r24
			   h_buf[h_buf_head].rAddr[1]=rx_pool_tail->data[8];
    1d0c:	18 96       	adiw	r26, 0x08	; 8
    1d0e:	8c 91       	ld	r24, X
    1d10:	18 97       	sbiw	r26, 0x08	; 8
    1d12:	81 83       	std	Z+1, r24	; 0x01
	           h_buf[h_buf_head].rssi=rx_pool_tail->data[13];
    1d14:	1d 96       	adiw	r26, 0x0d	; 13
    1d16:	8c 91       	ld	r24, X
    1d18:	82 83       	std	Z+2, r24	; 0x02
			   h_buf_head++;
    1d1a:	08 94       	sec
    1d1c:	a1 1c       	adc	r10, r1
    1d1e:	b1 1c       	adc	r11, r1
    1d20:	cf c0       	rjmp	.+414    	; 0x1ec0 <receiveData+0x59a>
           }
	    } 
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF 
    1d22:	4f 3f       	cpi	r20, 0xFF	; 255
    1d24:	99 f5       	brne	.+102    	; 0x1d8c <receiveData+0x466>
    1d26:	1a 96       	adiw	r26, 0x0a	; 10
    1d28:	8c 91       	ld	r24, X
    1d2a:	1a 97       	sbiw	r26, 0x0a	; 10
    1d2c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d2e:	71 f5       	brne	.+92     	; 0x1d8c <receiveData+0x466>
    1d30:	1b 96       	adiw	r26, 0x0b	; 11
    1d32:	8c 91       	ld	r24, X
    1d34:	1b 97       	sbiw	r26, 0x0b	; 11
    1d36:	85 30       	cpi	r24, 0x05	; 5
    1d38:	49 f5       	brne	.+82     	; 0x1d8c <receiveData+0x466>
		&& rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_SADDR_BROADCAST_NEW)//收到SCMD_SADDR_BROADCAST_NEW ,立刻反馈CONFIRM
		{
			if(NewNodeFlag==0)	   
    1d3a:	80 91 4b 0d 	lds	r24, 0x0D4B
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <receiveData+0x41e>
    1d42:	be c0       	rjmp	.+380    	; 0x1ec0 <receiveData+0x59a>
			{   
			   comPrintString("\r\n>>Prep new appling Received...");
    1d44:	84 e3       	ldi	r24, 0x34	; 52
    1d46:	94 e0       	ldi	r25, 0x04	; 4
    1d48:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			   n_buf[n_buf_head].rAddr[0]=rx_pool_tail->data[7];
    1d4c:	a0 91 b1 10 	lds	r26, 0x10B1
    1d50:	b0 91 b2 10 	lds	r27, 0x10B2
    1d54:	f6 01       	movw	r30, r12
    1d56:	ee 0f       	add	r30, r30
    1d58:	ff 1f       	adc	r31, r31
    1d5a:	ec 0d       	add	r30, r12
    1d5c:	fd 1d       	adc	r31, r13
    1d5e:	ee 0f       	add	r30, r30
    1d60:	ff 1f       	adc	r31, r31
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	90 e0       	ldi	r25, 0x00	; 0
    1d66:	8c 0f       	add	r24, r28
    1d68:	9d 1f       	adc	r25, r29
    1d6a:	e8 0f       	add	r30, r24
    1d6c:	f9 1f       	adc	r31, r25
    1d6e:	17 96       	adiw	r26, 0x07	; 7
    1d70:	8c 91       	ld	r24, X
    1d72:	17 97       	sbiw	r26, 0x07	; 7
    1d74:	80 83       	st	Z, r24
			   n_buf[n_buf_head].rAddr[1]=rx_pool_tail->data[8];
    1d76:	18 96       	adiw	r26, 0x08	; 8
    1d78:	8c 91       	ld	r24, X
    1d7a:	18 97       	sbiw	r26, 0x08	; 8
    1d7c:	81 83       	std	Z+1, r24	; 0x01
	           n_buf[n_buf_head].rssi=rx_pool_tail->data[13];
    1d7e:	1d 96       	adiw	r26, 0x0d	; 13
    1d80:	8c 91       	ld	r24, X
    1d82:	82 83       	std	Z+2, r24	; 0x02
			   n_buf_head++;
    1d84:	08 94       	sec
    1d86:	c1 1c       	adc	r12, r1
    1d88:	d1 1c       	adc	r13, r1
    1d8a:	9a c0       	rjmp	.+308    	; 0x1ec0 <receiveData+0x59a>
            }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&attri==0x01 && 
    1d8c:	80 91 4c 0d 	lds	r24, 0x0D4C
    1d90:	81 30       	cpi	r24, 0x01	; 1
    1d92:	89 f5       	brne	.+98     	; 0x1df6 <receiveData+0x4d0>
    1d94:	4f 3f       	cpi	r20, 0xFF	; 255
    1d96:	79 f5       	brne	.+94     	; 0x1df6 <receiveData+0x4d0>
    1d98:	1a 96       	adiw	r26, 0x0a	; 10
    1d9a:	8c 91       	ld	r24, X
    1d9c:	1a 97       	sbiw	r26, 0x0a	; 10
    1d9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1da0:	69 f5       	brne	.+90     	; 0x1dfc <receiveData+0x4d6>
    1da2:	1b 96       	adiw	r26, 0x0b	; 11
    1da4:	8c 91       	ld	r24, X
    1da6:	1b 97       	sbiw	r26, 0x0b	; 11
    1da8:	83 30       	cpi	r24, 0x03	; 3
    1daa:	41 f5       	brne	.+80     	; 0x1dfc <receiveData+0x4d6>
				rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && 
				rx_pool_tail->data[11]==SCMD_TAIL_OCCUPY)//收到尾节点占用广播
		{
			if(NewNodeFlag==0) 	 
    1dac:	80 91 4b 0d 	lds	r24, 0x0D4B
    1db0:	88 23       	and	r24, r24
    1db2:	09 f0       	breq	.+2      	; 0x1db6 <receiveData+0x490>
    1db4:	85 c0       	rjmp	.+266    	; 0x1ec0 <receiveData+0x59a>
			{	 
				t_buf[t_buf_head].rAddr[0]=rx_pool_tail->data[7];
    1db6:	f4 01       	movw	r30, r8
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	e8 0d       	add	r30, r8
    1dbe:	f9 1d       	adc	r31, r9
    1dc0:	ee 0f       	add	r30, r30
    1dc2:	ff 1f       	adc	r31, r31
    1dc4:	25 eb       	ldi	r18, 0xB5	; 181
    1dc6:	30 e0       	ldi	r19, 0x00	; 0
    1dc8:	2c 0f       	add	r18, r28
    1dca:	3d 1f       	adc	r19, r29
    1dcc:	e2 0f       	add	r30, r18
    1dce:	f3 1f       	adc	r31, r19
    1dd0:	17 96       	adiw	r26, 0x07	; 7
    1dd2:	8c 91       	ld	r24, X
    1dd4:	17 97       	sbiw	r26, 0x07	; 7
    1dd6:	80 83       	st	Z, r24
			    t_buf[t_buf_head].rAddr[1]=rx_pool_tail->data[8];
    1dd8:	18 96       	adiw	r26, 0x08	; 8
    1dda:	8c 91       	ld	r24, X
    1ddc:	18 97       	sbiw	r26, 0x08	; 8
    1dde:	81 83       	std	Z+1, r24	; 0x01
				t_buf[t_buf_head].rssi=rx_pool_tail->data[13];
    1de0:	1d 96       	adiw	r26, 0x0d	; 13
    1de2:	8c 91       	ld	r24, X
    1de4:	82 83       	std	Z+2, r24	; 0x02
			    t_buf_head++;
    1de6:	08 94       	sec
    1de8:	81 1c       	adc	r8, r1
    1dea:	91 1c       	adc	r9, r1
				comPrintString("\r\n>>Route tail Broadcast Recognized...");
    1dec:	85 e5       	ldi	r24, 0x55	; 85
    1dee:	94 e0       	ldi	r25, 0x04	; 4
    1df0:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    1df4:	65 c0       	rjmp	.+202    	; 0x1ec0 <receiveData+0x59a>
           }
		}
		else if(rx_pool_tail->data[3]== PanIdL && rx_pool_tail->data[4]==PanIdH&&rx_pool_tail->data[9]== 0xFF &&
    1df6:	4f 3f       	cpi	r20, 0xFF	; 255
    1df8:	09 f0       	breq	.+2      	; 0x1dfc <receiveData+0x4d6>
    1dfa:	62 c0       	rjmp	.+196    	; 0x1ec0 <receiveData+0x59a>
    1dfc:	1a 96       	adiw	r26, 0x0a	; 10
    1dfe:	8c 91       	ld	r24, X
    1e00:	1a 97       	sbiw	r26, 0x0a	; 10
    1e02:	8f 3f       	cpi	r24, 0xFF	; 255
    1e04:	09 f0       	breq	.+2      	; 0x1e08 <receiveData+0x4e2>
    1e06:	5c c0       	rjmp	.+184    	; 0x1ec0 <receiveData+0x59a>
    1e08:	1b 96       	adiw	r26, 0x0b	; 11
    1e0a:	8c 91       	ld	r24, X
    1e0c:	1b 97       	sbiw	r26, 0x0b	; 11
    1e0e:	88 23       	and	r24, r24
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <receiveData+0x4ee>
    1e12:	56 c0       	rjmp	.+172    	; 0x1ec0 <receiveData+0x59a>
		 rx_pool_tail->data[10]==0xFF &&rx_pool_tail->data[11]==SCMD_SADDR_BROADCAST )//收到短地址点占用广播
		{
			if(NewNodeFlag==0)
    1e14:	80 91 4b 0d 	lds	r24, 0x0D4B
    1e18:	88 23       	and	r24, r24
    1e1a:	09 f0       	breq	.+2      	; 0x1e1e <receiveData+0x4f8>
    1e1c:	51 c0       	rjmp	.+162    	; 0x1ec0 <receiveData+0x59a>
			{	
				if(rx_pool_tail->data[7]==sAddr&0xFF && rx_pool_tail->data[8]==(sAddr>>8)&0xFF )	
    1e1e:	17 96       	adiw	r26, 0x07	; 7
    1e20:	8c 91       	ld	r24, X
    1e22:	17 97       	sbiw	r26, 0x07	; 7
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	20 91 fc 0b 	lds	r18, 0x0BFC
    1e2a:	30 91 fd 0b 	lds	r19, 0x0BFD
    1e2e:	82 17       	cp	r24, r18
    1e30:	93 07       	cpc	r25, r19
    1e32:	09 f0       	breq	.+2      	; 0x1e36 <receiveData+0x510>
    1e34:	45 c0       	rjmp	.+138    	; 0x1ec0 <receiveData+0x59a>
    1e36:	18 96       	adiw	r26, 0x08	; 8
    1e38:	8c 91       	ld	r24, X
    1e3a:	88 23       	and	r24, r24
    1e3c:	09 f0       	breq	.+2      	; 0x1e40 <receiveData+0x51a>
    1e3e:	40 c0       	rjmp	.+128    	; 0x1ec0 <receiveData+0x59a>
				{	
					comPrintString("\r\n>>Short Address Broadcast Recognized...");
    1e40:	8c e7       	ldi	r24, 0x7C	; 124
    1e42:	94 e0       	ldi	r25, 0x04	; 4
    1e44:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					setShortAddress(sAddr+1);
    1e48:	80 91 fc 0b 	lds	r24, 0x0BFC
    1e4c:	90 91 fd 0b 	lds	r25, 0x0BFD
    1e50:	01 96       	adiw	r24, 0x01	; 1
    1e52:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
    1e56:	00 e0       	ldi	r16, 0x00	; 0
    1e58:	10 e0       	ldi	r17, 0x00	; 0
    1e5a:	12 c0       	rjmp	.+36     	; 0x1e80 <receiveData+0x55a>
    1e5c:	e8 eb       	ldi	r30, 0xB8	; 184
    1e5e:	f0 e0       	ldi	r31, 0x00	; 0
    1e60:	31 97       	sbiw	r30, 0x01	; 1
    1e62:	f1 f7       	brne	.-4      	; 0x1e60 <receiveData+0x53a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e64:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e66:	d1 f7       	brne	.-12     	; 0x1e5c <receiveData+0x536>
					for(i=0;i<20;i++)//连续发送20个TPU的短地址占用广播
					{
						delay_ms(TPU);
						SendWild(sAddr,SCMD_SADDR_BROADCAST);
    1e68:	80 91 fc 0b 	lds	r24, 0x0BFC
    1e6c:	90 91 fd 0b 	lds	r25, 0x0BFD
    1e70:	60 e0       	ldi	r22, 0x00	; 0
    1e72:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			{	
				if(rx_pool_tail->data[7]==sAddr&0xFF && rx_pool_tail->data[8]==(sAddr>>8)&0xFF )	
				{	
					comPrintString("\r\n>>Short Address Broadcast Recognized...");
					setShortAddress(sAddr+1);
					for(i=0;i<20;i++)//连续发送20个TPU的短地址占用广播
    1e76:	0f 5f       	subi	r16, 0xFF	; 255
    1e78:	1f 4f       	sbci	r17, 0xFF	; 255
    1e7a:	04 31       	cpi	r16, 0x14	; 20
    1e7c:	11 05       	cpc	r17, r1
    1e7e:	19 f0       	breq	.+6      	; 0x1e86 <receiveData+0x560>
    1e80:	88 eb       	ldi	r24, 0xB8	; 184
    1e82:	9b e0       	ldi	r25, 0x0B	; 11
    1e84:	eb cf       	rjmp	.-42     	; 0x1e5c <receiveData+0x536>
					{
						delay_ms(TPU);
						SendWild(sAddr,SCMD_SADDR_BROADCAST);
					}
					cli();
    1e86:	f8 94       	cli
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    1e88:	83 e5       	ldi	r24, 0x53	; 83
    1e8a:	9e e0       	ldi	r25, 0x0E	; 14
    1e8c:	90 93 ac 10 	sts	0x10AC, r25
    1e90:	80 93 ab 10 	sts	0x10AB, r24
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    1e94:	e7 e9       	ldi	r30, 0x97	; 151
    1e96:	f0 e1       	ldi	r31, 0x10	; 16
    1e98:	f0 93 ae 10 	sts	0x10AE, r31
    1e9c:	e0 93 ad 10 	sts	0x10AD, r30
    rx_pool_head = rx_pool_start;
    1ea0:	90 93 b0 10 	sts	0x10B0, r25
    1ea4:	80 93 af 10 	sts	0x10AF, r24
	rx_pool_tail = rx_pool_end;
    1ea8:	f0 93 b2 10 	sts	0x10B2, r31
    1eac:	e0 93 b1 10 	sts	0x10B1, r30
	rx_pool_items_free = RX_POOL_SIZE;
    1eb0:	8e e1       	ldi	r24, 0x1E	; 30
    1eb2:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    1eb6:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    1eba:	10 92 51 0e 	sts	0x0E51, r1
						delay_ms(TPU);
						SendWild(sAddr,SCMD_SADDR_BROADCAST);
					}
					cli();
					rx_pool_init( );
					sei();
    1ebe:	78 94       	sei
                }
            }
		}		
		if(rx_pool_items_used == 0 &&FirstTailFlag==1&&TailConfirmFlag==1)
    1ec0:	80 91 50 0e 	lds	r24, 0x0E50
    1ec4:	88 23       	and	r24, r24
    1ec6:	51 f4       	brne	.+20     	; 0x1edc <receiveData+0x5b6>
    1ec8:	80 91 4e 0d 	lds	r24, 0x0D4E
    1ecc:	88 23       	and	r24, r24
    1ece:	31 f0       	breq	.+12     	; 0x1edc <receiveData+0x5b6>
    1ed0:	80 91 4f 0d 	lds	r24, 0x0D4F
    1ed4:	88 23       	and	r24, r24
    1ed6:	11 f0       	breq	.+4      	; 0x1edc <receiveData+0x5b6>
		{
			FirstTailFlag=0;
    1ed8:	10 92 4e 0d 	sts	0x0D4E, r1
		}
		if(rx_pool_items_used == 0 &&FirstHeadFlag==1&&HeadConfirmFlag==1)
    1edc:	80 91 50 0e 	lds	r24, 0x0E50
    1ee0:	88 23       	and	r24, r24
    1ee2:	51 f4       	brne	.+20     	; 0x1ef8 <receiveData+0x5d2>
    1ee4:	80 91 52 0d 	lds	r24, 0x0D52
    1ee8:	88 23       	and	r24, r24
    1eea:	31 f0       	breq	.+12     	; 0x1ef8 <receiveData+0x5d2>
    1eec:	80 91 53 0d 	lds	r24, 0x0D53
    1ef0:	88 23       	and	r24, r24
    1ef2:	11 f0       	breq	.+4      	; 0x1ef8 <receiveData+0x5d2>
		{
			FirstHeadFlag=0;
    1ef4:	10 92 52 0d 	sts	0x0D52, r1
		}
		if(rx_pool_items_used == 0 &&FirstMedFlag==1&&NewConfirmFlag==1)
    1ef8:	80 91 50 0e 	lds	r24, 0x0E50
    1efc:	88 23       	and	r24, r24
    1efe:	51 f4       	brne	.+20     	; 0x1f14 <receiveData+0x5ee>
    1f00:	80 91 50 0d 	lds	r24, 0x0D50
    1f04:	88 23       	and	r24, r24
    1f06:	31 f0       	breq	.+12     	; 0x1f14 <receiveData+0x5ee>
    1f08:	80 91 51 0d 	lds	r24, 0x0D51
    1f0c:	88 23       	and	r24, r24
    1f0e:	11 f0       	breq	.+4      	; 0x1f14 <receiveData+0x5ee>
		{
			FirstMedFlag=0;
    1f10:	10 92 50 0d 	sts	0x0D50, r1
		}
	    if(rx_pool_items_used == 0 && n_buf_head>0)//当接收池空了时，处理收到的SCMD_SADDR_BROADCAST_NEW
    1f14:	80 91 50 0e 	lds	r24, 0x0E50
    1f18:	88 23       	and	r24, r24
    1f1a:	09 f0       	breq	.+2      	; 0x1f1e <receiveData+0x5f8>
    1f1c:	62 c0       	rjmp	.+196    	; 0x1fe2 <receiveData+0x6bc>
    1f1e:	c1 14       	cp	r12, r1
    1f20:	d1 04       	cpc	r13, r1
    1f22:	09 f4       	brne	.+2      	; 0x1f26 <receiveData+0x600>
    1f24:	5e c0       	rjmp	.+188    	; 0x1fe2 <receiveData+0x6bc>
		{
			if(NewNodeFlag==0) 	
    1f26:	80 91 4b 0d 	lds	r24, 0x0D4B
    1f2a:	88 23       	and	r24, r24
    1f2c:	09 f0       	breq	.+2      	; 0x1f30 <receiveData+0x60a>
    1f2e:	59 c0       	rjmp	.+178    	; 0x1fe2 <receiveData+0x6bc>
    1f30:	c6 01       	movw	r24, r12
    1f32:	01 97       	sbiw	r24, 0x01	; 1
    1f34:	8c 01       	movw	r16, r24
    1f36:	00 0f       	add	r16, r16
    1f38:	11 1f       	adc	r17, r17
    1f3a:	08 0f       	add	r16, r24
    1f3c:	19 1f       	adc	r17, r25
    1f3e:	00 0f       	add	r16, r16
    1f40:	11 1f       	adc	r17, r17
    1f42:	21 e0       	ldi	r18, 0x01	; 1
    1f44:	30 e0       	ldi	r19, 0x00	; 0
    1f46:	2c 0f       	add	r18, r28
    1f48:	3d 1f       	adc	r19, r29
    1f4a:	02 0f       	add	r16, r18
    1f4c:	13 1f       	adc	r17, r19
			{	
				while(n_buf_head>0)
				{
					n_buf_head--;
    1f4e:	08 94       	sec
    1f50:	c1 08       	sbc	r12, r1
    1f52:	d1 08       	sbc	r13, r1
					comPrintString("\r\n<<Sending New Prep confirm11111...");
    1f54:	86 ea       	ldi	r24, 0xA6	; 166
    1f56:	94 e0       	ldi	r25, 0x04	; 4
    1f58:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					if(n_buf[n_buf_head].rssi>Nrssi)
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	72 80       	ldd	r7, Z+2	; 0x02
    1f60:	e7 14       	cp	r14, r7
    1f62:	10 f0       	brcs	.+4      	; 0x1f68 <receiveData+0x642>
    1f64:	7e 2c       	mov	r7, r14
    1f66:	11 c0       	rjmp	.+34     	; 0x1f8a <receiveData+0x664>
					{	
						comPrintString("\r\n<<Sending New Prep confirm22222...");
    1f68:	8b ec       	ldi	r24, 0xCB	; 203
    1f6a:	94 e0       	ldi	r25, 0x04	; 4
    1f6c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						NewrAddr=n_buf[n_buf_head].rAddr[0]+n_buf[n_buf_head].rAddr[1]*256;
    1f70:	f8 01       	movw	r30, r16
    1f72:	51 80       	ldd	r5, Z+1	; 0x01
    1f74:	44 24       	eor	r4, r4
    1f76:	80 81       	ld	r24, Z
    1f78:	92 01       	movw	r18, r4
    1f7a:	28 0f       	add	r18, r24
    1f7c:	31 1d       	adc	r19, r1
    1f7e:	cf 5d       	subi	r28, 0xDF	; 223
    1f80:	dd 4f       	sbci	r29, 0xFD	; 253
    1f82:	39 83       	std	Y+1, r19	; 0x01
    1f84:	28 83       	st	Y, r18
    1f86:	c1 52       	subi	r28, 0x21	; 33
    1f88:	d2 40       	sbci	r29, 0x02	; 2
    1f8a:	06 50       	subi	r16, 0x06	; 6
    1f8c:	10 40       	sbci	r17, 0x00	; 0
		}
	    if(rx_pool_items_used == 0 && n_buf_head>0)//当接收池空了时，处理收到的SCMD_SADDR_BROADCAST_NEW
		{
			if(NewNodeFlag==0) 	
			{	
				while(n_buf_head>0)
    1f8e:	c1 14       	cp	r12, r1
    1f90:	d1 04       	cpc	r13, r1
    1f92:	11 f0       	breq	.+4      	; 0x1f98 <receiveData+0x672>
    1f94:	e7 2c       	mov	r14, r7
    1f96:	db cf       	rjmp	.-74     	; 0x1f4e <receiveData+0x628>
						comPrintString("\r\n<<Sending New Prep confirm22222...");
						NewrAddr=n_buf[n_buf_head].rAddr[0]+n_buf[n_buf_head].rAddr[1]*256;
						Nrssi=n_buf[n_buf_head].rssi;
	                }
			    }
	            if(NewrAddr==(sAddr+1))
    1f98:	80 91 fc 0b 	lds	r24, 0x0BFC
    1f9c:	90 91 fd 0b 	lds	r25, 0x0BFD
    1fa0:	01 96       	adiw	r24, 0x01	; 1
    1fa2:	cf 5d       	subi	r28, 0xDF	; 223
    1fa4:	dd 4f       	sbci	r29, 0xFD	; 253
    1fa6:	e8 81       	ld	r30, Y
    1fa8:	f9 81       	ldd	r31, Y+1	; 0x01
    1faa:	c1 52       	subi	r28, 0x21	; 33
    1fac:	d2 40       	sbci	r29, 0x02	; 2
    1fae:	e8 17       	cp	r30, r24
    1fb0:	f9 07       	cpc	r31, r25
    1fb2:	c1 f4       	brne	.+48     	; 0x1fe4 <receiveData+0x6be>
				{
					comPrintString("\r\n<<Sending New Prep confirm33333...");
    1fb4:	80 ef       	ldi	r24, 0xF0	; 240
    1fb6:	94 e0       	ldi	r25, 0x04	; 4
    1fb8:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				    SendConfirm(NewrAddr,SCMD_SADDR_BROADCAST_NEW_CONFIRM,Nrssi);
    1fbc:	cf 5d       	subi	r28, 0xDF	; 223
    1fbe:	dd 4f       	sbci	r29, 0xFD	; 253
    1fc0:	88 81       	ld	r24, Y
    1fc2:	99 81       	ldd	r25, Y+1	; 0x01
    1fc4:	c1 52       	subi	r28, 0x21	; 33
    1fc6:	d2 40       	sbci	r29, 0x02	; 2
    1fc8:	66 e0       	ldi	r22, 0x06	; 6
    1fca:	47 2d       	mov	r20, r7
    1fcc:	0e 94 c6 0b 	call	0x178c	; 0x178c <SendConfirm>
    1fd0:	80 e6       	ldi	r24, 0x60	; 96
    1fd2:	9a ee       	ldi	r25, 0xEA	; 234
    1fd4:	e8 eb       	ldi	r30, 0xB8	; 184
    1fd6:	f0 e0       	ldi	r31, 0x00	; 0
    1fd8:	31 97       	sbiw	r30, 0x01	; 1
    1fda:	f1 f7       	brne	.-4      	; 0x1fd8 <receiveData+0x6b2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fdc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fde:	d1 f7       	brne	.-12     	; 0x1fd4 <receiveData+0x6ae>
    1fe0:	01 c0       	rjmp	.+2      	; 0x1fe4 <receiveData+0x6be>
    1fe2:	7e 2c       	mov	r7, r14
					delay_ms(Broad_Cover_Times*TPU);
				}
			}			
		}
		if(rx_pool_items_used == 0 && t_buf_head>0)//当池子空了处理收到的SCMD_TAIL_OCCUPY
    1fe4:	80 91 50 0e 	lds	r24, 0x0E50
    1fe8:	88 23       	and	r24, r24
    1fea:	09 f0       	breq	.+2      	; 0x1fee <receiveData+0x6c8>
    1fec:	68 c0       	rjmp	.+208    	; 0x20be <receiveData+0x798>
    1fee:	81 14       	cp	r8, r1
    1ff0:	91 04       	cpc	r9, r1
    1ff2:	09 f4       	brne	.+2      	; 0x1ff6 <receiveData+0x6d0>
    1ff4:	64 c0       	rjmp	.+200    	; 0x20be <receiveData+0x798>
		{
			if(NewNodeFlag==0)	
    1ff6:	80 91 4b 0d 	lds	r24, 0x0D4B
    1ffa:	88 23       	and	r24, r24
    1ffc:	09 f0       	breq	.+2      	; 0x2000 <receiveData+0x6da>
    1ffe:	5f c0       	rjmp	.+190    	; 0x20be <receiveData+0x798>
			{	
				comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~~~");
    2000:	85 e1       	ldi	r24, 0x15	; 21
    2002:	95 e0       	ldi	r25, 0x05	; 5
    2004:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				comPrintString("\r\n!!into used==0!!!!!!!!!!!!!!!!!!!!");
    2008:	83 e4       	ldi	r24, 0x43	; 67
    200a:	95 e0       	ldi	r25, 0x05	; 5
    200c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    2010:	c4 01       	movw	r24, r8
    2012:	01 97       	sbiw	r24, 0x01	; 1
    2014:	8c 01       	movw	r16, r24
    2016:	00 0f       	add	r16, r16
    2018:	11 1f       	adc	r17, r17
    201a:	08 0f       	add	r16, r24
    201c:	19 1f       	adc	r17, r25
    201e:	00 0f       	add	r16, r16
    2020:	11 1f       	adc	r17, r17
    2022:	25 eb       	ldi	r18, 0xB5	; 181
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	2c 0f       	add	r18, r28
    2028:	3d 1f       	adc	r19, r29
    202a:	02 0f       	add	r16, r18
    202c:	13 1f       	adc	r17, r19
				while(t_buf_head>0)
				{
					t_buf_head--;
    202e:	08 94       	sec
    2030:	81 08       	sbc	r8, r1
    2032:	91 08       	sbc	r9, r1
					comPrintString("\r\n<<Sending Tail Prep confirm00001...");
    2034:	88 e6       	ldi	r24, 0x68	; 104
    2036:	95 e0       	ldi	r25, 0x05	; 5
    2038:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					if(t_buf[t_buf_head].rssi>Trssi)
    203c:	f8 01       	movw	r30, r16
    203e:	e2 80       	ldd	r14, Z+2	; 0x02
    2040:	6e 14       	cp	r6, r14
    2042:	10 f0       	brcs	.+4      	; 0x2048 <receiveData+0x722>
    2044:	e6 2c       	mov	r14, r6
    2046:	11 c0       	rjmp	.+34     	; 0x206a <receiveData+0x744>
					{	
						comPrintString("\r\n<<Sending Tail Prep confirm22222...");
    2048:	8e e8       	ldi	r24, 0x8E	; 142
    204a:	95 e0       	ldi	r25, 0x05	; 5
    204c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						TailrAddr=t_buf[t_buf_head].rAddr[0]+t_buf[t_buf_head].rAddr[1]*256;
    2050:	f8 01       	movw	r30, r16
    2052:	31 80       	ldd	r3, Z+1	; 0x01
    2054:	22 24       	eor	r2, r2
    2056:	80 81       	ld	r24, Z
    2058:	91 01       	movw	r18, r2
    205a:	28 0f       	add	r18, r24
    205c:	31 1d       	adc	r19, r1
    205e:	c1 5e       	subi	r28, 0xE1	; 225
    2060:	dd 4f       	sbci	r29, 0xFD	; 253
    2062:	39 83       	std	Y+1, r19	; 0x01
    2064:	28 83       	st	Y, r18
    2066:	cf 51       	subi	r28, 0x1F	; 31
    2068:	d2 40       	sbci	r29, 0x02	; 2
    206a:	06 50       	subi	r16, 0x06	; 6
    206c:	10 40       	sbci	r17, 0x00	; 0
		{
			if(NewNodeFlag==0)	
			{	
				comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~~~");
				comPrintString("\r\n!!into used==0!!!!!!!!!!!!!!!!!!!!");
				while(t_buf_head>0)
    206e:	81 14       	cp	r8, r1
    2070:	91 04       	cpc	r9, r1
    2072:	11 f0       	breq	.+4      	; 0x2078 <receiveData+0x752>
    2074:	6e 2c       	mov	r6, r14
    2076:	db cf       	rjmp	.-74     	; 0x202e <receiveData+0x708>
						comPrintString("\r\n<<Sending Tail Prep confirm22222...");
						TailrAddr=t_buf[t_buf_head].rAddr[0]+t_buf[t_buf_head].rAddr[1]*256;
						Trssi=t_buf[t_buf_head].rssi;
	                }
				 }
	             comPrintString("\r\n<<Sending Tail Prep confirm11111...");
    2078:	84 eb       	ldi	r24, 0xB4	; 180
    207a:	95 e0       	ldi	r25, 0x05	; 5
    207c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				 if(TailrAddr==(sAddr+1))        
    2080:	80 91 fc 0b 	lds	r24, 0x0BFC
    2084:	90 91 fd 0b 	lds	r25, 0x0BFD
    2088:	01 96       	adiw	r24, 0x01	; 1
    208a:	c1 5e       	subi	r28, 0xE1	; 225
    208c:	dd 4f       	sbci	r29, 0xFD	; 253
    208e:	e8 81       	ld	r30, Y
    2090:	f9 81       	ldd	r31, Y+1	; 0x01
    2092:	cf 51       	subi	r28, 0x1F	; 31
    2094:	d2 40       	sbci	r29, 0x02	; 2
    2096:	e8 17       	cp	r30, r24
    2098:	f9 07       	cpc	r31, r25
    209a:	91 f4       	brne	.+36     	; 0x20c0 <receiveData+0x79a>
				 {
					comPrintString("\r\n<<Sending Tail Prep confirm33333...");
    209c:	8a ed       	ldi	r24, 0xDA	; 218
    209e:	95 e0       	ldi	r25, 0x05	; 5
    20a0:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					SendConfirm(TailrAddr,SCMD_TAIL_OCCUPY_CONFIRM,Trssi);
    20a4:	c1 5e       	subi	r28, 0xE1	; 225
    20a6:	dd 4f       	sbci	r29, 0xFD	; 253
    20a8:	88 81       	ld	r24, Y
    20aa:	99 81       	ldd	r25, Y+1	; 0x01
    20ac:	cf 51       	subi	r28, 0x1F	; 31
    20ae:	d2 40       	sbci	r29, 0x02	; 2
    20b0:	67 e0       	ldi	r22, 0x07	; 7
    20b2:	4e 2d       	mov	r20, r14
    20b4:	0e 94 c6 0b 	call	0x178c	; 0x178c <SendConfirm>
					attri=0x00;
    20b8:	10 92 4c 0d 	sts	0x0D4C, r1
    20bc:	01 c0       	rjmp	.+2      	; 0x20c0 <receiveData+0x79a>
    20be:	e6 2c       	mov	r14, r6
				 }
			}	 		
		}
		if(rx_pool_items_used == 0 && h_buf_head>0)//当池子空了处理收到的SCMD_TAIL_OCCUPY
    20c0:	80 91 50 0e 	lds	r24, 0x0E50
    20c4:	88 23       	and	r24, r24
    20c6:	09 f0       	breq	.+2      	; 0x20ca <receiveData+0x7a4>
    20c8:	6e c0       	rjmp	.+220    	; 0x21a6 <receiveData+0x880>
    20ca:	a1 14       	cp	r10, r1
    20cc:	b1 04       	cpc	r11, r1
    20ce:	09 f4       	brne	.+2      	; 0x20d2 <receiveData+0x7ac>
    20d0:	6a c0       	rjmp	.+212    	; 0x21a6 <receiveData+0x880>
		{   
			if(NewNodeFlag==0) 	
    20d2:	80 91 4b 0d 	lds	r24, 0x0D4B
    20d6:	88 23       	and	r24, r24
    20d8:	09 f0       	breq	.+2      	; 0x20dc <receiveData+0x7b6>
    20da:	65 c0       	rjmp	.+202    	; 0x21a6 <receiveData+0x880>
    20dc:	c5 01       	movw	r24, r10
    20de:	01 97       	sbiw	r24, 0x01	; 1
    20e0:	8c 01       	movw	r16, r24
    20e2:	00 0f       	add	r16, r16
    20e4:	11 1f       	adc	r17, r17
    20e6:	08 0f       	add	r16, r24
    20e8:	19 1f       	adc	r17, r25
    20ea:	00 0f       	add	r16, r16
    20ec:	11 1f       	adc	r17, r17
    20ee:	29 e6       	ldi	r18, 0x69	; 105
    20f0:	31 e0       	ldi	r19, 0x01	; 1
    20f2:	2c 0f       	add	r18, r28
    20f4:	3d 1f       	adc	r19, r29
    20f6:	02 0f       	add	r16, r18
    20f8:	13 1f       	adc	r17, r19
			{	
			    while(h_buf_head>0)
				{
					h_buf_head--;
    20fa:	08 94       	sec
    20fc:	a1 08       	sbc	r10, r1
    20fe:	b1 08       	sbc	r11, r1
					comPrintString("\r\n<<Sending Head prep confirm00001...");
    2100:	80 e0       	ldi	r24, 0x00	; 0
    2102:	96 e0       	ldi	r25, 0x06	; 6
    2104:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					if(h_buf[h_buf_head].rssi>Hrssi)
    2108:	f8 01       	movw	r30, r16
    210a:	f2 80       	ldd	r15, Z+2	; 0x02
    210c:	cd 5d       	subi	r28, 0xDD	; 221
    210e:	dd 4f       	sbci	r29, 0xFD	; 253
    2110:	f8 81       	ld	r31, Y
    2112:	c3 52       	subi	r28, 0x23	; 35
    2114:	d2 40       	sbci	r29, 0x02	; 2
    2116:	ff 15       	cp	r31, r15
    2118:	10 f0       	brcs	.+4      	; 0x211e <receiveData+0x7f8>
    211a:	ff 2e       	mov	r15, r31
    211c:	1c c0       	rjmp	.+56     	; 0x2156 <receiveData+0x830>
					{	
						HeadrAddr=h_buf[h_buf_head].rAddr[0]+h_buf[h_buf_head].rAddr[1]*256;
    211e:	f8 01       	movw	r30, r16
    2120:	f1 81       	ldd	r31, Z+1	; 0x01
    2122:	cb 5d       	subi	r28, 0xDB	; 219
    2124:	dd 4f       	sbci	r29, 0xFD	; 253
    2126:	f8 83       	st	Y, r31
    2128:	c5 52       	subi	r28, 0x25	; 37
    212a:	d2 40       	sbci	r29, 0x02	; 2
    212c:	cc 5d       	subi	r28, 0xDC	; 220
    212e:	dd 4f       	sbci	r29, 0xFD	; 253
    2130:	18 82       	st	Y, r1
    2132:	c4 52       	subi	r28, 0x24	; 36
    2134:	d2 40       	sbci	r29, 0x02	; 2
    2136:	f8 01       	movw	r30, r16
    2138:	80 81       	ld	r24, Z
    213a:	cc 5d       	subi	r28, 0xDC	; 220
    213c:	dd 4f       	sbci	r29, 0xFD	; 253
    213e:	28 81       	ld	r18, Y
    2140:	39 81       	ldd	r19, Y+1	; 0x01
    2142:	c4 52       	subi	r28, 0x24	; 36
    2144:	d2 40       	sbci	r29, 0x02	; 2
    2146:	28 0f       	add	r18, r24
    2148:	31 1d       	adc	r19, r1
    214a:	c3 5e       	subi	r28, 0xE3	; 227
    214c:	dd 4f       	sbci	r29, 0xFD	; 253
    214e:	39 83       	std	Y+1, r19	; 0x01
    2150:	28 83       	st	Y, r18
    2152:	cd 51       	subi	r28, 0x1D	; 29
    2154:	d2 40       	sbci	r29, 0x02	; 2
    2156:	06 50       	subi	r16, 0x06	; 6
    2158:	10 40       	sbci	r17, 0x00	; 0
		}
		if(rx_pool_items_used == 0 && h_buf_head>0)//当池子空了处理收到的SCMD_TAIL_OCCUPY
		{   
			if(NewNodeFlag==0) 	
			{	
			    while(h_buf_head>0)
    215a:	a1 14       	cp	r10, r1
    215c:	b1 04       	cpc	r11, r1
    215e:	31 f0       	breq	.+12     	; 0x216c <receiveData+0x846>
    2160:	cd 5d       	subi	r28, 0xDD	; 221
    2162:	dd 4f       	sbci	r29, 0xFD	; 253
    2164:	f8 82       	st	Y, r15
    2166:	c3 52       	subi	r28, 0x23	; 35
    2168:	d2 40       	sbci	r29, 0x02	; 2
    216a:	c7 cf       	rjmp	.-114    	; 0x20fa <receiveData+0x7d4>
					{	
						HeadrAddr=h_buf[h_buf_head].rAddr[0]+h_buf[h_buf_head].rAddr[1]*256;
						Hrssi=h_buf[h_buf_head].rssi;
	                }
				}
	            comPrintString("\r\n<<Sending Head Prep confirm11111...");
    216c:	86 e2       	ldi	r24, 0x26	; 38
    216e:	96 e0       	ldi	r25, 0x06	; 6
    2170:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				if(sAddr==0x0000)
    2174:	80 91 fc 0b 	lds	r24, 0x0BFC
    2178:	90 91 fd 0b 	lds	r25, 0x0BFD
    217c:	89 2b       	or	r24, r25
    217e:	c1 f4       	brne	.+48     	; 0x21b0 <receiveData+0x88a>
				{
					comPrintString("\r\n<<Sending Head Prep confirm33333...");
    2180:	8c e4       	ldi	r24, 0x4C	; 76
    2182:	96 e0       	ldi	r25, 0x06	; 6
    2184:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					SendConfirm(HeadrAddr,SCMD_HEAD_OCCUPY_CONFIRM,Hrssi);
    2188:	c3 5e       	subi	r28, 0xE3	; 227
    218a:	dd 4f       	sbci	r29, 0xFD	; 253
    218c:	88 81       	ld	r24, Y
    218e:	cd 51       	subi	r28, 0x1D	; 29
    2190:	d2 40       	sbci	r29, 0x02	; 2
    2192:	c2 5e       	subi	r28, 0xE2	; 226
    2194:	dd 4f       	sbci	r29, 0xFD	; 253
    2196:	98 81       	ld	r25, Y
    2198:	ce 51       	subi	r28, 0x1E	; 30
    219a:	d2 40       	sbci	r29, 0x02	; 2
    219c:	69 e0       	ldi	r22, 0x09	; 9
    219e:	4f 2d       	mov	r20, r15
    21a0:	0e 94 c6 0b 	call	0x178c	; 0x178c <SendConfirm>
    21a4:	05 c0       	rjmp	.+10     	; 0x21b0 <receiveData+0x88a>
    21a6:	cd 5d       	subi	r28, 0xDD	; 221
    21a8:	dd 4f       	sbci	r29, 0xFD	; 253
    21aa:	f8 80       	ld	r15, Y
    21ac:	c3 52       	subi	r28, 0x23	; 35
    21ae:	d2 40       	sbci	r29, 0x02	; 2
    21b0:	6e 2c       	mov	r6, r14
    21b2:	e7 2c       	mov	r14, r7
    21b4:	cd 5d       	subi	r28, 0xDD	; 221
    21b6:	dd 4f       	sbci	r29, 0xFD	; 253
    21b8:	f8 82       	st	Y, r15
    21ba:	c3 52       	subi	r28, 0x23	; 35
    21bc:	d2 40       	sbci	r29, 0x02	; 2
	short int h_buf_head=0;
	comPrintString("\r\n!!into times:");
	com_send_hex(j);
	comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~");
	j++;
    while (rx_pool_items_used != 0) //查看接收池中是否有未处理的包
    21be:	80 91 50 0e 	lds	r24, 0x0E50
    21c2:	88 23       	and	r24, r24
    21c4:	09 f0       	breq	.+2      	; 0x21c8 <receiveData+0x8a2>
    21c6:	01 cc       	rjmp	.-2046   	; 0x19ca <receiveData+0xa4>
				}
			}				
		}
	}  

	if (rx_pool_overflow_flag == true) //检查接收池是否溢出
    21c8:	80 91 51 0e 	lds	r24, 0x0E51
    21cc:	88 23       	and	r24, r24
    21ce:	09 f1       	breq	.+66     	; 0x2212 <__stack+0x13>
	{
		cli();
    21d0:	f8 94       	cli
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    21d2:	83 e5       	ldi	r24, 0x53	; 83
    21d4:	9e e0       	ldi	r25, 0x0E	; 14
    21d6:	90 93 ac 10 	sts	0x10AC, r25
    21da:	80 93 ab 10 	sts	0x10AB, r24
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    21de:	27 e9       	ldi	r18, 0x97	; 151
    21e0:	30 e1       	ldi	r19, 0x10	; 16
    21e2:	30 93 ae 10 	sts	0x10AE, r19
    21e6:	20 93 ad 10 	sts	0x10AD, r18
    rx_pool_head = rx_pool_start;
    21ea:	90 93 b0 10 	sts	0x10B0, r25
    21ee:	80 93 af 10 	sts	0x10AF, r24
	rx_pool_tail = rx_pool_end;
    21f2:	30 93 b2 10 	sts	0x10B2, r19
    21f6:	20 93 b1 10 	sts	0x10B1, r18
	rx_pool_items_free = RX_POOL_SIZE;
    21fa:	8e e1       	ldi	r24, 0x1E	; 30
    21fc:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    2200:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    2204:	10 92 51 0e 	sts	0x0E51, r1

	if (rx_pool_overflow_flag == true) //检查接收池是否溢出
	{
		cli();
		rx_pool_init( );
		comPrintString("\r\n!!RX Pool overflow.");
    2208:	82 e7       	ldi	r24, 0x72	; 114
    220a:	96 e0       	ldi	r25, 0x06	; 6
    220c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		sei();
    2210:	78 94       	sei
	}
}
    2212:	cb 5d       	subi	r28, 0xDB	; 219
    2214:	dd 4f       	sbci	r29, 0xFD	; 253
    2216:	0f b6       	in	r0, 0x3f	; 63
    2218:	f8 94       	cli
    221a:	de bf       	out	0x3e, r29	; 62
    221c:	0f be       	out	0x3f, r0	; 63
    221e:	cd bf       	out	0x3d, r28	; 61
    2220:	cf 91       	pop	r28
    2222:	df 91       	pop	r29
    2224:	1f 91       	pop	r17
    2226:	0f 91       	pop	r16
    2228:	ff 90       	pop	r15
    222a:	ef 90       	pop	r14
    222c:	df 90       	pop	r13
    222e:	cf 90       	pop	r12
    2230:	bf 90       	pop	r11
    2232:	af 90       	pop	r10
    2234:	9f 90       	pop	r9
    2236:	8f 90       	pop	r8
    2238:	7f 90       	pop	r7
    223a:	6f 90       	pop	r6
    223c:	5f 90       	pop	r5
    223e:	4f 90       	pop	r4
    2240:	3f 90       	pop	r3
    2242:	2f 90       	pop	r2
    2244:	08 95       	ret

00002246 <receiveDataPrep>:
void receiveDataPrep()
{
    2246:	2f 92       	push	r2
    2248:	3f 92       	push	r3
    224a:	4f 92       	push	r4
    224c:	5f 92       	push	r5
    224e:	6f 92       	push	r6
    2250:	7f 92       	push	r7
    2252:	8f 92       	push	r8
    2254:	9f 92       	push	r9
    2256:	af 92       	push	r10
    2258:	bf 92       	push	r11
    225a:	cf 92       	push	r12
    225c:	df 92       	push	r13
    225e:	ef 92       	push	r14
    2260:	ff 92       	push	r15
    2262:	0f 93       	push	r16
    2264:	1f 93       	push	r17
    2266:	df 93       	push	r29
    2268:	cf 93       	push	r28
    226a:	cd b7       	in	r28, 0x3d	; 61
    226c:	de b7       	in	r29, 0x3e	; 62
    226e:	aa 97       	sbiw	r28, 0x2a	; 42
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	f8 94       	cli
    2274:	de bf       	out	0x3e, r29	; 62
    2276:	0f be       	out	0x3f, r0	; 63
    2278:	cd bf       	out	0x3d, r28	; 61
	static int j=0;
	int i,k;
	uint16_t rAddr=0xFFFC;
    PrepReceive p_buf[RX_POOL_SIZE/2];
    short int p_buf_head=0;
    comPrintString("\r\n!!into Prep times:");
    227a:	88 e8       	ldi	r24, 0x88	; 136
    227c:	96 e0       	ldi	r25, 0x06	; 6
    227e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(j);
    2282:	80 91 5e 0d 	lds	r24, 0x0D5E
    2286:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~");
    228a:	82 e8       	ldi	r24, 0x82	; 130
    228c:	92 e0       	ldi	r25, 0x02	; 2
    228e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	j++;
    2292:	80 91 5e 0d 	lds	r24, 0x0D5E
    2296:	90 91 5f 0d 	lds	r25, 0x0D5F
    229a:	01 96       	adiw	r24, 0x01	; 1
    229c:	90 93 5f 0d 	sts	0x0D5F, r25
    22a0:	80 93 5e 0d 	sts	0x0D5E, r24
    22a4:	ee 24       	eor	r14, r14
    22a6:	ff 24       	eor	r15, r15
	    rx_pool_network_prep_buf_head--;				
		//读取缓存区，接收到的数据会被储存在rx_pool_tail->data[]中
		comPrintString("\r\n>>Data Received::");
		for(i=0;i<=15;i++)
		{
			com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[i]);
    22a8:	04 e1       	ldi	r16, 0x14	; 20
    22aa:	c0 2e       	mov	r12, r16
    22ac:	d1 2c       	mov	r13, r1
			   }
			   else
			   {
					comPrintString("\r\n<<Sending Data Downward...");
					rAddr=sAddr;
					while(p_buf_head>0)
    22ae:	9e 01       	movw	r18, r28
    22b0:	21 50       	subi	r18, 0x01	; 1
    22b2:	30 40       	sbci	r19, 0x00	; 0
    22b4:	3a a7       	std	Y+42, r19	; 0x2a
    22b6:	29 a7       	std	Y+41, r18	; 0x29
    22b8:	9c c3       	rjmp	.+1848   	; 0x29f2 <receiveDataPrep+0x7ac>
	com_send_hex(j);
	comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~");
	j++;
    while (rx_pool_network_prep_buf_head != 0) //查看接收池中是否有未处理的包
	{   
	    comPrintString("\r\n!!rx_pool_network_prep_buf_head used::::::::::");
    22ba:	8d e9       	ldi	r24, 0x9D	; 157
    22bc:	96 e0       	ldi	r25, 0x06	; 6
    22be:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_hex(rx_pool_network_prep_buf_head);
    22c2:	80 91 5d 0d 	lds	r24, 0x0D5D
    22c6:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	    rx_pool_network_prep_buf_head--;				
    22ca:	80 91 5d 0d 	lds	r24, 0x0D5D
    22ce:	81 50       	subi	r24, 0x01	; 1
    22d0:	80 93 5d 0d 	sts	0x0D5D, r24
		//读取缓存区，接收到的数据会被储存在rx_pool_tail->data[]中
		comPrintString("\r\n>>Data Received::");
    22d4:	8f ec       	ldi	r24, 0xCF	; 207
    22d6:	92 e0       	ldi	r25, 0x02	; 2
    22d8:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    22dc:	00 e0       	ldi	r16, 0x00	; 0
    22de:	10 e0       	ldi	r17, 0x00	; 0
		for(i=0;i<=15;i++)
		{
			com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[i]);
    22e0:	80 91 5d 0d 	lds	r24, 0x0D5D
    22e4:	90 e0       	ldi	r25, 0x00	; 0
    22e6:	8c 9d       	mul	r24, r12
    22e8:	f0 01       	movw	r30, r0
    22ea:	8d 9d       	mul	r24, r13
    22ec:	f0 0d       	add	r31, r0
    22ee:	9c 9d       	mul	r25, r12
    22f0:	f0 0d       	add	r31, r0
    22f2:	11 24       	eor	r1, r1
    22f4:	e0 0f       	add	r30, r16
    22f6:	f1 1f       	adc	r31, r17
    22f8:	ef 59       	subi	r30, 0x9F	; 159
    22fa:	fd 4e       	sbci	r31, 0xED	; 237
    22fc:	80 81       	ld	r24, Z
    22fe:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
			comPrintString(" ");
    2302:	83 e3       	ldi	r24, 0x33	; 51
    2304:	92 e0       	ldi	r25, 0x02	; 2
    2306:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	    comPrintString("\r\n!!rx_pool_network_prep_buf_head used::::::::::");
		com_send_hex(rx_pool_network_prep_buf_head);
	    rx_pool_network_prep_buf_head--;				
		//读取缓存区，接收到的数据会被储存在rx_pool_tail->data[]中
		comPrintString("\r\n>>Data Received::");
		for(i=0;i<=15;i++)
    230a:	0f 5f       	subi	r16, 0xFF	; 255
    230c:	1f 4f       	sbci	r17, 0xFF	; 255
    230e:	00 31       	cpi	r16, 0x10	; 16
    2310:	11 05       	cpc	r17, r1
    2312:	31 f7       	brne	.-52     	; 0x22e0 <receiveDataPrep+0x9a>
		{
			com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[i]);
			comPrintString(" ");
		}
	    if(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[3]== PanIdL && rx_pool_network_prep[rx_pool_network_prep_buf_head].data[4]==PanIdH&&
    2314:	80 91 5d 0d 	lds	r24, 0x0D5D
    2318:	68 2f       	mov	r22, r24
    231a:	70 e0       	ldi	r23, 0x00	; 0
    231c:	44 e1       	ldi	r20, 0x14	; 20
    231e:	50 e0       	ldi	r21, 0x00	; 0
    2320:	64 9f       	mul	r22, r20
    2322:	f0 01       	movw	r30, r0
    2324:	65 9f       	mul	r22, r21
    2326:	f0 0d       	add	r31, r0
    2328:	74 9f       	mul	r23, r20
    232a:	f0 0d       	add	r31, r0
    232c:	11 24       	eor	r1, r1
    232e:	ef 59       	subi	r30, 0x9F	; 159
    2330:	fd 4e       	sbci	r31, 0xED	; 237
    2332:	83 81       	ldd	r24, Z+3	; 0x03
    2334:	8c 3c       	cpi	r24, 0xCC	; 204
    2336:	09 f0       	breq	.+2      	; 0x233a <receiveDataPrep+0xf4>
    2338:	9d c0       	rjmp	.+314    	; 0x2474 <receiveDataPrep+0x22e>
    233a:	84 81       	ldd	r24, Z+4	; 0x04
    233c:	8e 3e       	cpi	r24, 0xEE	; 238
    233e:	09 f0       	breq	.+2      	; 0x2342 <receiveDataPrep+0xfc>
    2340:	99 c0       	rjmp	.+306    	; 0x2474 <receiveDataPrep+0x22e>
    2342:	81 85       	ldd	r24, Z+9	; 0x09
    2344:	8f 3f       	cpi	r24, 0xFF	; 255
    2346:	09 f0       	breq	.+2      	; 0x234a <receiveDataPrep+0x104>
    2348:	95 c0       	rjmp	.+298    	; 0x2474 <receiveDataPrep+0x22e>
    234a:	82 85       	ldd	r24, Z+10	; 0x0a
    234c:	8f 3f       	cpi	r24, 0xFF	; 255
    234e:	61 f5       	brne	.+88     	; 0x23a8 <receiveDataPrep+0x162>
    2350:	83 85       	ldd	r24, Z+11	; 0x0b
    2352:	84 30       	cpi	r24, 0x04	; 4
    2354:	49 f5       	brne	.+82     	; 0x23a8 <receiveDataPrep+0x162>
		rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]== 0xFF &&rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]==0xFF && 
		rx_pool_network_prep[rx_pool_network_prep_buf_head].data[11]==SCMD_PREP_RECEIVED)//收到Prep反馈，发送正常数据
		{
			if(NewNodeFlag==0)	   
    2356:	80 91 4b 0d 	lds	r24, 0x0D4B
    235a:	88 23       	and	r24, r24
    235c:	09 f0       	breq	.+2      	; 0x2360 <receiveDataPrep+0x11a>
    235e:	cf c1       	rjmp	.+926    	; 0x26fe <receiveDataPrep+0x4b8>
			{   
			   comPrintString("\r\n>>Prep Callback Received...");
    2360:	8e ec       	ldi	r24, 0xCE	; 206
    2362:	96 e0       	ldi	r25, 0x06	; 6
    2364:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			   p_buf[p_buf_head].rAddr[0]=rx_pool_network_prep[rx_pool_network_prep_buf_head].data[7];
    2368:	80 91 5d 0d 	lds	r24, 0x0D5D
    236c:	90 e0       	ldi	r25, 0x00	; 0
    236e:	d7 01       	movw	r26, r14
    2370:	aa 0f       	add	r26, r26
    2372:	bb 1f       	adc	r27, r27
    2374:	e1 e0       	ldi	r30, 0x01	; 1
    2376:	f0 e0       	ldi	r31, 0x00	; 0
    2378:	ec 0f       	add	r30, r28
    237a:	fd 1f       	adc	r31, r29
    237c:	ae 0f       	add	r26, r30
    237e:	bf 1f       	adc	r27, r31
    2380:	24 e1       	ldi	r18, 0x14	; 20
    2382:	30 e0       	ldi	r19, 0x00	; 0
    2384:	82 9f       	mul	r24, r18
    2386:	f0 01       	movw	r30, r0
    2388:	83 9f       	mul	r24, r19
    238a:	f0 0d       	add	r31, r0
    238c:	92 9f       	mul	r25, r18
    238e:	f0 0d       	add	r31, r0
    2390:	11 24       	eor	r1, r1
    2392:	ef 59       	subi	r30, 0x9F	; 159
    2394:	fd 4e       	sbci	r31, 0xED	; 237
    2396:	87 81       	ldd	r24, Z+7	; 0x07
    2398:	8c 93       	st	X, r24
			   p_buf[p_buf_head].rAddr[1]=rx_pool_network_prep[rx_pool_network_prep_buf_head].data[8];
    239a:	80 85       	ldd	r24, Z+8	; 0x08
    239c:	11 96       	adiw	r26, 0x01	; 1
    239e:	8c 93       	st	X, r24
			   p_buf_head++;
    23a0:	08 94       	sec
    23a2:	e1 1c       	adc	r14, r1
    23a4:	f1 1c       	adc	r15, r1
    23a6:	ab c1       	rjmp	.+854    	; 0x26fe <receiveDataPrep+0x4b8>
            }
	    } 
	    else if(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[3]== PanIdL && rx_pool_network_prep[rx_pool_network_prep_buf_head].data[4]==PanIdH&&
    23a8:	6c 9d       	mul	r22, r12
    23aa:	f0 01       	movw	r30, r0
    23ac:	6d 9d       	mul	r22, r13
    23ae:	f0 0d       	add	r31, r0
    23b0:	7c 9d       	mul	r23, r12
    23b2:	f0 0d       	add	r31, r0
    23b4:	11 24       	eor	r1, r1
    23b6:	ef 59       	subi	r30, 0x9F	; 159
    23b8:	fd 4e       	sbci	r31, 0xED	; 237
    23ba:	82 85       	ldd	r24, Z+10	; 0x0a
    23bc:	8f 3f       	cpi	r24, 0xFF	; 255
    23be:	09 f0       	breq	.+2      	; 0x23c2 <receiveDataPrep+0x17c>
    23c0:	59 c0       	rjmp	.+178    	; 0x2474 <receiveDataPrep+0x22e>
    23c2:	83 85       	ldd	r24, Z+11	; 0x0b
    23c4:	81 30       	cpi	r24, 0x01	; 1
    23c6:	09 f0       	breq	.+2      	; 0x23ca <receiveDataPrep+0x184>
    23c8:	55 c0       	rjmp	.+170    	; 0x2474 <receiveDataPrep+0x22e>
		rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]== 0xFF &&rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]==0xFF && 
		rx_pool_network_prep[rx_pool_network_prep_buf_head].data[11]==SCMD_PREP)//收到PREP,立刻反馈PrepReceived
		{
		   if(((rx_pool_network_prep[rx_pool_network_prep_buf_head].data[7]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[8]*256)<=sAddr)&&
    23ca:	30 85       	ldd	r19, Z+8	; 0x08
    23cc:	38 a3       	std	Y+32, r19	; 0x20
    23ce:	1f 8e       	std	Y+31, r1	; 0x1f
    23d0:	87 81       	ldd	r24, Z+7	; 0x07
    23d2:	4f 8d       	ldd	r20, Y+31	; 0x1f
    23d4:	58 a1       	ldd	r21, Y+32	; 0x20
    23d6:	48 0f       	add	r20, r24
    23d8:	51 1d       	adc	r21, r1
    23da:	20 91 fc 0b 	lds	r18, 0x0BFC
    23de:	30 91 fd 0b 	lds	r19, 0x0BFD
    23e2:	24 17       	cp	r18, r20
    23e4:	35 07       	cpc	r19, r21
    23e6:	58 f0       	brcs	.+22     	; 0x23fe <receiveDataPrep+0x1b8>
    23e8:	85 85       	ldd	r24, Z+13	; 0x0d
    23ea:	8a a3       	std	Y+34, r24	; 0x22
    23ec:	19 a2       	std	Y+33, r1	; 0x21
    23ee:	84 85       	ldd	r24, Z+12	; 0x0c
    23f0:	a9 a1       	ldd	r26, Y+33	; 0x21
    23f2:	ba a1       	ldd	r27, Y+34	; 0x22
    23f4:	a8 0f       	add	r26, r24
    23f6:	b1 1d       	adc	r27, r1
    23f8:	a2 17       	cp	r26, r18
    23fa:	b3 07       	cpc	r27, r19
    23fc:	c8 f4       	brcc	.+50     	; 0x2430 <receiveDataPrep+0x1ea>
    23fe:	42 17       	cp	r20, r18
    2400:	53 07       	cpc	r21, r19
    2402:	08 f4       	brcc	.+2      	; 0x2406 <receiveDataPrep+0x1c0>
    2404:	7c c1       	rjmp	.+760    	; 0x26fe <receiveDataPrep+0x4b8>
    2406:	6c 9d       	mul	r22, r12
    2408:	f0 01       	movw	r30, r0
    240a:	6d 9d       	mul	r22, r13
    240c:	f0 0d       	add	r31, r0
    240e:	7c 9d       	mul	r23, r12
    2410:	f0 0d       	add	r31, r0
    2412:	11 24       	eor	r1, r1
    2414:	ef 59       	subi	r30, 0x9F	; 159
    2416:	fd 4e       	sbci	r31, 0xED	; 237
    2418:	b5 85       	ldd	r27, Z+13	; 0x0d
    241a:	bc a3       	std	Y+36, r27	; 0x24
    241c:	1b a2       	std	Y+35, r1	; 0x23
    241e:	84 85       	ldd	r24, Z+12	; 0x0c
    2420:	eb a1       	ldd	r30, Y+35	; 0x23
    2422:	fc a1       	ldd	r31, Y+36	; 0x24
    2424:	e8 0f       	add	r30, r24
    2426:	f1 1d       	adc	r31, r1
    2428:	2e 17       	cp	r18, r30
    242a:	3f 07       	cpc	r19, r31
    242c:	08 f4       	brcc	.+2      	; 0x2430 <receiveDataPrep+0x1ea>
    242e:	67 c1       	rjmp	.+718    	; 0x26fe <receiveDataPrep+0x4b8>
		       (sAddr<=(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[12]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[13]*256))||
		      ((rx_pool_network_prep[rx_pool_network_prep_buf_head].data[7]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[8]*256)>=sAddr)&&
		       (sAddr>=(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[12]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[13]*256)))
		   {
				if(NewNodeFlag==0)   		
    2430:	80 91 4b 0d 	lds	r24, 0x0D4B
    2434:	88 23       	and	r24, r24
    2436:	09 f0       	breq	.+2      	; 0x243a <receiveDataPrep+0x1f4>
    2438:	62 c1       	rjmp	.+708    	; 0x26fe <receiveDataPrep+0x4b8>
				{	
				    comPrintString("\r\n>>Prep Received...");
    243a:	8c ee       	ldi	r24, 0xEC	; 236
    243c:	96 e0       	ldi	r25, 0x06	; 6
    243e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				    SendWild(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[7]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[8]*256,SCMD_PREP_RECEIVED);
    2442:	80 91 5d 0d 	lds	r24, 0x0D5D
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	8c 9d       	mul	r24, r12
    244a:	f0 01       	movw	r30, r0
    244c:	8d 9d       	mul	r24, r13
    244e:	f0 0d       	add	r31, r0
    2450:	9c 9d       	mul	r25, r12
    2452:	f0 0d       	add	r31, r0
    2454:	11 24       	eor	r1, r1
    2456:	ef 59       	subi	r30, 0x9F	; 159
    2458:	fd 4e       	sbci	r31, 0xED	; 237
    245a:	70 84       	ldd	r7, Z+8	; 0x08
    245c:	66 24       	eor	r6, r6
    245e:	87 81       	ldd	r24, Z+7	; 0x07
    2460:	93 01       	movw	r18, r6
    2462:	28 0f       	add	r18, r24
    2464:	31 1d       	adc	r19, r1
    2466:	c9 01       	movw	r24, r18
    2468:	64 e0       	ldi	r22, 0x04	; 4
    246a:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
				    sleep_flag=0;
    246e:	10 92 25 0c 	sts	0x0C25, r1
    2472:	45 c1       	rjmp	.+650    	; 0x26fe <receiveDataPrep+0x4b8>
			    }				
		   }
		}	
		else if(!(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]==0xFF && rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]==0xFF))//收到一般信息
    2474:	6c 9d       	mul	r22, r12
    2476:	f0 01       	movw	r30, r0
    2478:	6d 9d       	mul	r22, r13
    247a:	f0 0d       	add	r31, r0
    247c:	7c 9d       	mul	r23, r12
    247e:	f0 0d       	add	r31, r0
    2480:	11 24       	eor	r1, r1
    2482:	ef 59       	subi	r30, 0x9F	; 159
    2484:	fd 4e       	sbci	r31, 0xED	; 237
    2486:	81 85       	ldd	r24, Z+9	; 0x09
    2488:	8f 3f       	cpi	r24, 0xFF	; 255
    248a:	21 f4       	brne	.+8      	; 0x2494 <receiveDataPrep+0x24e>
    248c:	82 85       	ldd	r24, Z+10	; 0x0a
    248e:	8f 3f       	cpi	r24, 0xFF	; 255
    2490:	09 f4       	brne	.+2      	; 0x2494 <receiveDataPrep+0x24e>
    2492:	35 c1       	rjmp	.+618    	; 0x26fe <receiveDataPrep+0x4b8>
        {
			if(NewNodeFlag==0)
    2494:	80 91 4b 0d 	lds	r24, 0x0D4B
    2498:	88 23       	and	r24, r24
    249a:	09 f0       	breq	.+2      	; 0x249e <receiveDataPrep+0x258>
    249c:	30 c1       	rjmp	.+608    	; 0x26fe <receiveDataPrep+0x4b8>
			{	
				comPrintString("\r\n>>Data Package Received");
    249e:	81 e0       	ldi	r24, 0x01	; 1
    24a0:	97 e0       	ldi	r25, 0x07	; 7
    24a2:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				if(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[3]== PanIdL && rx_pool_network_prep[rx_pool_network_prep_buf_head].data[4]==PanIdH&&
    24a6:	80 91 5d 0d 	lds	r24, 0x0D5D
    24aa:	90 e0       	ldi	r25, 0x00	; 0
    24ac:	8c 9d       	mul	r24, r12
    24ae:	f0 01       	movw	r30, r0
    24b0:	8d 9d       	mul	r24, r13
    24b2:	f0 0d       	add	r31, r0
    24b4:	9c 9d       	mul	r25, r12
    24b6:	f0 0d       	add	r31, r0
    24b8:	11 24       	eor	r1, r1
    24ba:	ef 59       	subi	r30, 0x9F	; 159
    24bc:	fd 4e       	sbci	r31, 0xED	; 237
    24be:	83 81       	ldd	r24, Z+3	; 0x03
    24c0:	8c 3c       	cpi	r24, 0xCC	; 204
    24c2:	39 f5       	brne	.+78     	; 0x2512 <receiveDataPrep+0x2cc>
    24c4:	84 81       	ldd	r24, Z+4	; 0x04
    24c6:	8e 3e       	cpi	r24, 0xEE	; 238
    24c8:	21 f5       	brne	.+72     	; 0x2512 <receiveDataPrep+0x2cc>
    24ca:	01 85       	ldd	r16, Z+9	; 0x09
    24cc:	10 e0       	ldi	r17, 0x00	; 0
    24ce:	0e 94 cf 09 	call	0x139e	; 0x139e <tat_get_short_address>
    24d2:	08 17       	cp	r16, r24
    24d4:	19 07       	cpc	r17, r25
    24d6:	e9 f4       	brne	.+58     	; 0x2512 <receiveDataPrep+0x2cc>
    24d8:	80 91 5d 0d 	lds	r24, 0x0D5D
    24dc:	90 e0       	ldi	r25, 0x00	; 0
    24de:	8c 9d       	mul	r24, r12
    24e0:	f0 01       	movw	r30, r0
    24e2:	8d 9d       	mul	r24, r13
    24e4:	f0 0d       	add	r31, r0
    24e6:	9c 9d       	mul	r25, r12
    24e8:	f0 0d       	add	r31, r0
    24ea:	11 24       	eor	r1, r1
    24ec:	ef 59       	subi	r30, 0x9F	; 159
    24ee:	fd 4e       	sbci	r31, 0xED	; 237
    24f0:	02 85       	ldd	r16, Z+10	; 0x0a
    24f2:	10 e0       	ldi	r17, 0x00	; 0
    24f4:	0e 94 cf 09 	call	0x139e	; 0x139e <tat_get_short_address>
    24f8:	a9 2e       	mov	r10, r25
    24fa:	bb 24       	eor	r11, r11
    24fc:	0a 15       	cp	r16, r10
    24fe:	1b 05       	cpc	r17, r11
    2500:	41 f4       	brne	.+16     	; 0x2512 <receiveDataPrep+0x2cc>
				rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]==tat_get_short_address()&& rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]==(tat_get_short_address()>>8))
				{
				    comPrintString("within normal receive~~~");
    2502:	8b e1       	ldi	r24, 0x1B	; 27
    2504:	97 e0       	ldi	r25, 0x07	; 7
    2506:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	   comPrintString("\r\n!!State Change Failed");
    rx_flag = true; // Set the flag back again. Only used to protec t
}
void download()
{
	comPrintString("\r\n>>yangjieshahuhu!");
    250a:	84 e3       	ldi	r24, 0x34	; 52
    250c:	97 e0       	ldi	r25, 0x07	; 7
    250e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]==tat_get_short_address()&& rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]==(tat_get_short_address()>>8))
				{
				    comPrintString("within normal receive~~~");
					download();
				}		
				if(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[3]== PanIdL && rx_pool_network_prep[rx_pool_network_prep_buf_head].data[4]==PanIdH&&
    2512:	80 91 5d 0d 	lds	r24, 0x0D5D
    2516:	90 e0       	ldi	r25, 0x00	; 0
    2518:	8c 9d       	mul	r24, r12
    251a:	f0 01       	movw	r30, r0
    251c:	8d 9d       	mul	r24, r13
    251e:	f0 0d       	add	r31, r0
    2520:	9c 9d       	mul	r25, r12
    2522:	f0 0d       	add	r31, r0
    2524:	11 24       	eor	r1, r1
    2526:	ef 59       	subi	r30, 0x9F	; 159
    2528:	fd 4e       	sbci	r31, 0xED	; 237
    252a:	83 81       	ldd	r24, Z+3	; 0x03
    252c:	8c 3c       	cpi	r24, 0xCC	; 204
    252e:	09 f0       	breq	.+2      	; 0x2532 <receiveDataPrep+0x2ec>
    2530:	e6 c0       	rjmp	.+460    	; 0x26fe <receiveDataPrep+0x4b8>
    2532:	84 81       	ldd	r24, Z+4	; 0x04
    2534:	8e 3e       	cpi	r24, 0xEE	; 238
    2536:	09 f0       	breq	.+2      	; 0x253a <receiveDataPrep+0x2f4>
    2538:	e2 c0       	rjmp	.+452    	; 0x26fe <receiveDataPrep+0x4b8>
    253a:	01 85       	ldd	r16, Z+9	; 0x09
    253c:	10 e0       	ldi	r17, 0x00	; 0
    253e:	0e 94 cf 09 	call	0x139e	; 0x139e <tat_get_short_address>
    2542:	08 17       	cp	r16, r24
    2544:	19 07       	cpc	r17, r25
    2546:	b1 f4       	brne	.+44     	; 0x2574 <receiveDataPrep+0x32e>
    2548:	80 91 5d 0d 	lds	r24, 0x0D5D
    254c:	90 e0       	ldi	r25, 0x00	; 0
    254e:	8c 9d       	mul	r24, r12
    2550:	f0 01       	movw	r30, r0
    2552:	8d 9d       	mul	r24, r13
    2554:	f0 0d       	add	r31, r0
    2556:	9c 9d       	mul	r25, r12
    2558:	f0 0d       	add	r31, r0
    255a:	11 24       	eor	r1, r1
    255c:	ef 59       	subi	r30, 0x9F	; 159
    255e:	fd 4e       	sbci	r31, 0xED	; 237
    2560:	02 85       	ldd	r16, Z+10	; 0x0a
    2562:	10 e0       	ldi	r17, 0x00	; 0
    2564:	0e 94 cf 09 	call	0x139e	; 0x139e <tat_get_short_address>
    2568:	89 2e       	mov	r8, r25
    256a:	99 24       	eor	r9, r9
    256c:	08 15       	cp	r16, r8
    256e:	19 05       	cpc	r17, r9
    2570:	09 f4       	brne	.+2      	; 0x2574 <receiveDataPrep+0x32e>
    2572:	c5 c0       	rjmp	.+394    	; 0x26fe <receiveDataPrep+0x4b8>
				(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]!=tat_get_short_address()|| rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]!=(tat_get_short_address()>>8)))
				{
					if(BusyTxSending==0)
    2574:	80 91 57 0d 	lds	r24, 0x0D57
    2578:	88 23       	and	r24, r24
    257a:	09 f0       	breq	.+2      	; 0x257e <receiveDataPrep+0x338>
    257c:	46 c0       	rjmp	.+140    	; 0x260a <receiveDataPrep+0x3c4>
					{
						comPrintString("\r\n<<Transfroming data now is my sending data...");
    257e:	88 e4       	ldi	r24, 0x48	; 72
    2580:	97 e0       	ldi	r25, 0x07	; 7
    2582:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						addSendData(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]*256,&(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[11]));
    2586:	80 91 5d 0d 	lds	r24, 0x0D5D
    258a:	90 e0       	ldi	r25, 0x00	; 0
    258c:	8c 9d       	mul	r24, r12
    258e:	d0 01       	movw	r26, r0
    2590:	8d 9d       	mul	r24, r13
    2592:	b0 0d       	add	r27, r0
    2594:	9c 9d       	mul	r25, r12
    2596:	b0 0d       	add	r27, r0
    2598:	11 24       	eor	r1, r1
    259a:	ad 01       	movw	r20, r26
    259c:	4f 59       	subi	r20, 0x9F	; 159
    259e:	5d 4e       	sbci	r21, 0xED	; 237
    25a0:	fa 01       	movw	r30, r20
    25a2:	52 84       	ldd	r5, Z+10	; 0x0a
    25a4:	44 24       	eor	r4, r4
    25a6:	81 85       	ldd	r24, Z+9	; 0x09
    25a8:	92 01       	movw	r18, r4
    25aa:	28 0f       	add	r18, r24
    25ac:	31 1d       	adc	r19, r1
    25ae:	c9 01       	movw	r24, r18
    25b0:	bd 01       	movw	r22, r26
    25b2:	64 59       	subi	r22, 0x94	; 148
    25b4:	7d 4e       	sbci	r23, 0xED	; 237
{
	comPrintString("\r\n>>yangjieshahuhu!");
}
void addSendData(uint16_t dAddr,uint8_t data[])
{
	dataSendBuffer[dataSendBufferHead].dAddr[0]=dAddr&0xFF;
    25b6:	20 91 58 0d 	lds	r18, 0x0D58
    25ba:	30 91 59 0d 	lds	r19, 0x0D59
    25be:	f9 01       	movw	r30, r18
    25c0:	a3 e0       	ldi	r26, 0x03	; 3
    25c2:	ee 0f       	add	r30, r30
    25c4:	ff 1f       	adc	r31, r31
    25c6:	aa 95       	dec	r26
    25c8:	e1 f7       	brne	.-8      	; 0x25c2 <receiveDataPrep+0x37c>
    25ca:	e2 1b       	sub	r30, r18
    25cc:	f3 0b       	sbc	r31, r19
    25ce:	e0 5a       	subi	r30, 0xA0	; 160
    25d0:	f2 4f       	sbci	r31, 0xF2	; 242
    25d2:	80 83       	st	Z, r24
	dataSendBuffer[dataSendBufferHead].dAddr[1]=(dAddr>>8)&0xFF;
    25d4:	91 83       	std	Z+1, r25	; 0x01
	dataSendBuffer[dataSendBufferHead].data[0]=data[0];
    25d6:	da 01       	movw	r26, r20
    25d8:	1b 96       	adiw	r26, 0x0b	; 11
    25da:	8c 91       	ld	r24, X
    25dc:	82 83       	std	Z+2, r24	; 0x02
	dataSendBuffer[dataSendBufferHead].data[1]=data[1];
    25de:	db 01       	movw	r26, r22
    25e0:	11 96       	adiw	r26, 0x01	; 1
    25e2:	8c 91       	ld	r24, X
    25e4:	11 97       	sbiw	r26, 0x01	; 1
    25e6:	83 83       	std	Z+3, r24	; 0x03
	dataSendBuffer[dataSendBufferHead].data[2]=data[2];
    25e8:	12 96       	adiw	r26, 0x02	; 2
    25ea:	8c 91       	ld	r24, X
    25ec:	12 97       	sbiw	r26, 0x02	; 2
    25ee:	84 83       	std	Z+4, r24	; 0x04
	dataSendBuffer[dataSendBufferHead].data[3]=data[3];
    25f0:	13 96       	adiw	r26, 0x03	; 3
    25f2:	8c 91       	ld	r24, X
    25f4:	13 97       	sbiw	r26, 0x03	; 3
    25f6:	85 83       	std	Z+5, r24	; 0x05
	dataSendBuffer[dataSendBufferHead].data[4]=data[4];
    25f8:	14 96       	adiw	r26, 0x04	; 4
    25fa:	8c 91       	ld	r24, X
    25fc:	86 83       	std	Z+6, r24	; 0x06
	dataSendBufferHead++;
    25fe:	2f 5f       	subi	r18, 0xFF	; 255
    2600:	3f 4f       	sbci	r19, 0xFF	; 255
    2602:	30 93 59 0d 	sts	0x0D59, r19
    2606:	20 93 58 0d 	sts	0x0D58, r18
					if(BusyTxSending==0)
					{
						comPrintString("\r\n<<Transfroming data now is my sending data...");
						addSendData(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]+rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]*256,&(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[11]));
	                }
	                 if(BusyTxSending==1)
    260a:	80 91 57 0d 	lds	r24, 0x0D57
    260e:	88 23       	and	r24, r24
    2610:	09 f4       	brne	.+2      	; 0x2614 <receiveDataPrep+0x3ce>
    2612:	75 c0       	rjmp	.+234    	; 0x26fe <receiveDataPrep+0x4b8>
					 {
						 comPrintString("\r\n<<I have Received but time is not good...");
    2614:	88 e7       	ldi	r24, 0x78	; 120
    2616:	97 e0       	ldi	r25, 0x07	; 7
    2618:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		                 comPrintString("\r\n<<Dest shotAddr apart is:::::...");
    261c:	84 ea       	ldi	r24, 0xA4	; 164
    261e:	97 e0       	ldi	r25, 0x07	; 7
    2620:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[10]);
    2624:	80 91 5d 0d 	lds	r24, 0x0D5D
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	8c 9d       	mul	r24, r12
    262c:	f0 01       	movw	r30, r0
    262e:	8d 9d       	mul	r24, r13
    2630:	f0 0d       	add	r31, r0
    2632:	9c 9d       	mul	r25, r12
    2634:	f0 0d       	add	r31, r0
    2636:	11 24       	eor	r1, r1
    2638:	ef 59       	subi	r30, 0x9F	; 159
    263a:	fd 4e       	sbci	r31, 0xED	; 237
    263c:	82 85       	ldd	r24, Z+10	; 0x0a
    263e:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[9]);
    2642:	80 91 5d 0d 	lds	r24, 0x0D5D
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	8c 9d       	mul	r24, r12
    264a:	f0 01       	movw	r30, r0
    264c:	8d 9d       	mul	r24, r13
    264e:	f0 0d       	add	r31, r0
    2650:	9c 9d       	mul	r25, r12
    2652:	f0 0d       	add	r31, r0
    2654:	11 24       	eor	r1, r1
    2656:	ef 59       	subi	r30, 0x9F	; 159
    2658:	fd 4e       	sbci	r31, 0xED	; 237
    265a:	81 85       	ldd	r24, Z+9	; 0x09
    265c:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						 comPrintString("\r\n<<TO Dest  data is:::::...");
    2660:	87 ec       	ldi	r24, 0xC7	; 199
    2662:	97 e0       	ldi	r25, 0x07	; 7
    2664:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[11]);
    2668:	80 91 5d 0d 	lds	r24, 0x0D5D
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	8c 9d       	mul	r24, r12
    2670:	f0 01       	movw	r30, r0
    2672:	8d 9d       	mul	r24, r13
    2674:	f0 0d       	add	r31, r0
    2676:	9c 9d       	mul	r25, r12
    2678:	f0 0d       	add	r31, r0
    267a:	11 24       	eor	r1, r1
    267c:	ef 59       	subi	r30, 0x9F	; 159
    267e:	fd 4e       	sbci	r31, 0xED	; 237
    2680:	83 85       	ldd	r24, Z+11	; 0x0b
    2682:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[12]);
    2686:	80 91 5d 0d 	lds	r24, 0x0D5D
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	8c 9d       	mul	r24, r12
    268e:	f0 01       	movw	r30, r0
    2690:	8d 9d       	mul	r24, r13
    2692:	f0 0d       	add	r31, r0
    2694:	9c 9d       	mul	r25, r12
    2696:	f0 0d       	add	r31, r0
    2698:	11 24       	eor	r1, r1
    269a:	ef 59       	subi	r30, 0x9F	; 159
    269c:	fd 4e       	sbci	r31, 0xED	; 237
    269e:	84 85       	ldd	r24, Z+12	; 0x0c
    26a0:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[13]);
    26a4:	80 91 5d 0d 	lds	r24, 0x0D5D
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	8c 9d       	mul	r24, r12
    26ac:	f0 01       	movw	r30, r0
    26ae:	8d 9d       	mul	r24, r13
    26b0:	f0 0d       	add	r31, r0
    26b2:	9c 9d       	mul	r25, r12
    26b4:	f0 0d       	add	r31, r0
    26b6:	11 24       	eor	r1, r1
    26b8:	ef 59       	subi	r30, 0x9F	; 159
    26ba:	fd 4e       	sbci	r31, 0xED	; 237
    26bc:	85 85       	ldd	r24, Z+13	; 0x0d
    26be:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						 com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[14]);
    26c2:	80 91 5d 0d 	lds	r24, 0x0D5D
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	8c 9d       	mul	r24, r12
    26ca:	f0 01       	movw	r30, r0
    26cc:	8d 9d       	mul	r24, r13
    26ce:	f0 0d       	add	r31, r0
    26d0:	9c 9d       	mul	r25, r12
    26d2:	f0 0d       	add	r31, r0
    26d4:	11 24       	eor	r1, r1
    26d6:	ef 59       	subi	r30, 0x9F	; 159
    26d8:	fd 4e       	sbci	r31, 0xED	; 237
    26da:	86 85       	ldd	r24, Z+14	; 0x0e
    26dc:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	       			     com_send_hex(rx_pool_network_prep[rx_pool_network_prep_buf_head].data[15]);
    26e0:	80 91 5d 0d 	lds	r24, 0x0D5D
    26e4:	90 e0       	ldi	r25, 0x00	; 0
    26e6:	8c 9d       	mul	r24, r12
    26e8:	f0 01       	movw	r30, r0
    26ea:	8d 9d       	mul	r24, r13
    26ec:	f0 0d       	add	r31, r0
    26ee:	9c 9d       	mul	r25, r12
    26f0:	f0 0d       	add	r31, r0
    26f2:	11 24       	eor	r1, r1
    26f4:	ef 59       	subi	r30, 0x9F	; 159
    26f6:	fd 4e       	sbci	r31, 0xED	; 237
    26f8:	87 85       	ldd	r24, Z+15	; 0x0f
    26fa:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	                  }
				}
            }  
		}
		if(rx_pool_network_prep_buf_head == 0 && p_buf_head>0)//当接收池空了时，处理收到的Prep_RECEIVED
    26fe:	80 91 5d 0d 	lds	r24, 0x0D5D
    2702:	88 23       	and	r24, r24
    2704:	09 f0       	breq	.+2      	; 0x2708 <receiveDataPrep+0x4c2>
    2706:	75 c1       	rjmp	.+746    	; 0x29f2 <receiveDataPrep+0x7ac>
    2708:	e1 14       	cp	r14, r1
    270a:	f1 04       	cpc	r15, r1
    270c:	09 f4       	brne	.+2      	; 0x2710 <receiveDataPrep+0x4ca>
    270e:	71 c1       	rjmp	.+738    	; 0x29f2 <receiveDataPrep+0x7ac>
		{
			if(NewNodeFlag==0)   
    2710:	80 91 4b 0d 	lds	r24, 0x0D4B
    2714:	88 23       	and	r24, r24
    2716:	09 f0       	breq	.+2      	; 0x271a <receiveDataPrep+0x4d4>
    2718:	6c c1       	rjmp	.+728    	; 0x29f2 <receiveDataPrep+0x7ac>
			{   
			   if((dataSendBuffer[dataSendBufferHead].dAddr[0]+dataSendBuffer[dataSendBufferHead].dAddr[1]*256)<sAddr)//将要发送的数据上行
    271a:	80 91 58 0d 	lds	r24, 0x0D58
    271e:	90 91 59 0d 	lds	r25, 0x0D59
    2722:	fc 01       	movw	r30, r24
    2724:	23 e0       	ldi	r18, 0x03	; 3
    2726:	ee 0f       	add	r30, r30
    2728:	ff 1f       	adc	r31, r31
    272a:	2a 95       	dec	r18
    272c:	e1 f7       	brne	.-8      	; 0x2726 <receiveDataPrep+0x4e0>
    272e:	e8 1b       	sub	r30, r24
    2730:	f9 0b       	sbc	r31, r25
    2732:	e0 5a       	subi	r30, 0xA0	; 160
    2734:	f2 4f       	sbci	r31, 0xF2	; 242
    2736:	31 80       	ldd	r3, Z+1	; 0x01
    2738:	22 24       	eor	r2, r2
    273a:	80 81       	ld	r24, Z
    273c:	91 01       	movw	r18, r2
    273e:	28 0f       	add	r18, r24
    2740:	31 1d       	adc	r19, r1
    2742:	80 91 fc 0b 	lds	r24, 0x0BFC
    2746:	90 91 fd 0b 	lds	r25, 0x0BFD
    274a:	08 94       	sec
    274c:	e1 08       	sbc	r14, r1
    274e:	f1 08       	sbc	r15, r1
    2750:	28 17       	cp	r18, r24
    2752:	39 07       	cpc	r19, r25
    2754:	20 f5       	brcc	.+72     	; 0x279e <receiveDataPrep+0x558>
			   {
					comPrintString("\r\n<<Sending Data Upward...");
    2756:	84 ee       	ldi	r24, 0xE4	; 228
    2758:	97 e0       	ldi	r25, 0x07	; 7
    275a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	                rAddr=sAddr;
    275e:	00 91 fc 0b 	lds	r16, 0x0BFC
    2762:	10 91 fd 0b 	lds	r17, 0x0BFD
    2766:	f7 01       	movw	r30, r14
    2768:	ee 0f       	add	r30, r30
    276a:	ff 1f       	adc	r31, r31
    276c:	21 e0       	ldi	r18, 0x01	; 1
    276e:	30 e0       	ldi	r19, 0x00	; 0
    2770:	2c 0f       	add	r18, r28
    2772:	3d 1f       	adc	r19, r29
    2774:	e2 0f       	add	r30, r18
    2776:	f3 1f       	adc	r31, r19
    2778:	31 81       	ldd	r19, Z+1	; 0x01
    277a:	3e a3       	std	Y+38, r19	; 0x26
    277c:	1d a2       	std	Y+37, r1	; 0x25
    277e:	80 81       	ld	r24, Z
    2780:	4d a1       	ldd	r20, Y+37	; 0x25
    2782:	5e a1       	ldd	r21, Y+38	; 0x26
    2784:	48 0f       	add	r20, r24
    2786:	51 1d       	adc	r21, r1
    2788:	40 17       	cp	r20, r16
    278a:	51 07       	cpc	r21, r17
    278c:	08 f4       	brcc	.+2      	; 0x2790 <receiveDataPrep+0x54a>
    278e:	8a 01       	movw	r16, r20
    2790:	32 97       	sbiw	r30, 0x02	; 2
					while(p_buf_head>0)
    2792:	89 a5       	ldd	r24, Y+41	; 0x29
    2794:	9a a5       	ldd	r25, Y+42	; 0x2a
    2796:	e8 17       	cp	r30, r24
    2798:	f9 07       	cpc	r31, r25
    279a:	71 f7       	brne	.-36     	; 0x2778 <receiveDataPrep+0x532>
    279c:	23 c0       	rjmp	.+70     	; 0x27e4 <receiveDataPrep+0x59e>
							rAddr=(p_buf[p_buf_head].rAddr[0]+p_buf[p_buf_head].rAddr[1]*256);
					}
			   }
			   else
			   {
					comPrintString("\r\n<<Sending Data Downward...");
    279e:	8f ef       	ldi	r24, 0xFF	; 255
    27a0:	97 e0       	ldi	r25, 0x07	; 7
    27a2:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
					rAddr=sAddr;
    27a6:	00 91 fc 0b 	lds	r16, 0x0BFC
    27aa:	10 91 fd 0b 	lds	r17, 0x0BFD
    27ae:	f7 01       	movw	r30, r14
    27b0:	ee 0f       	add	r30, r30
    27b2:	ff 1f       	adc	r31, r31
    27b4:	a1 e0       	ldi	r26, 0x01	; 1
    27b6:	b0 e0       	ldi	r27, 0x00	; 0
    27b8:	ac 0f       	add	r26, r28
    27ba:	bd 1f       	adc	r27, r29
    27bc:	ea 0f       	add	r30, r26
    27be:	fb 1f       	adc	r31, r27
    27c0:	b1 81       	ldd	r27, Z+1	; 0x01
    27c2:	b8 a7       	std	Y+40, r27	; 0x28
    27c4:	1f a2       	std	Y+39, r1	; 0x27
    27c6:	80 81       	ld	r24, Z
    27c8:	2f a1       	ldd	r18, Y+39	; 0x27
    27ca:	38 a5       	ldd	r19, Y+40	; 0x28
    27cc:	28 0f       	add	r18, r24
    27ce:	31 1d       	adc	r19, r1
    27d0:	02 17       	cp	r16, r18
    27d2:	13 07       	cpc	r17, r19
    27d4:	08 f4       	brcc	.+2      	; 0x27d8 <receiveDataPrep+0x592>
    27d6:	89 01       	movw	r16, r18
    27d8:	32 97       	sbiw	r30, 0x02	; 2
					while(p_buf_head>0)
    27da:	49 a5       	ldd	r20, Y+41	; 0x29
    27dc:	5a a5       	ldd	r21, Y+42	; 0x2a
    27de:	e4 17       	cp	r30, r20
    27e0:	f5 07       	cpc	r31, r21
    27e2:	71 f7       	brne	.-36     	; 0x27c0 <receiveDataPrep+0x57a>
						p_buf_head--;
						if((p_buf[p_buf_head].rAddr[0]+p_buf[p_buf_head].rAddr[1]*256)>rAddr)
							rAddr=(p_buf[p_buf_head].rAddr[0]+p_buf[p_buf_head].rAddr[1]*256);
					}
			   }
			   comPrintString("\r\n<<To node :::::::.");
    27e4:	8c e1       	ldi	r24, 0x1C	; 28
    27e6:	98 e0       	ldi	r25, 0x08	; 8
    27e8:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			   com_send_hex(rAddr);
    27ec:	80 2f       	mov	r24, r16
    27ee:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
    rx_flag = true; // Set the flag back again. Only used to protect			
}
void SendMessage(uint16_t GDrAddr)
{
	int i;
    tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
    27f2:	81 e6       	ldi	r24, 0x61	; 97
    27f4:	80 93 d0 0d 	sts	0x0DD0, r24
    tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
    27f8:	88 e8       	ldi	r24, 0x88	; 136
    27fa:	80 93 d1 0d 	sts	0x0DD1, r24
    tx_frame[2]= 0; //封包序列号
    27fe:	10 92 d2 0d 	sts	0x0DD2, r1
    tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
    2802:	8c ec       	ldi	r24, 0xCC	; 204
    2804:	80 93 d3 0d 	sts	0x0DD3, r24
    tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
    2808:	8e ee       	ldi	r24, 0xEE	; 238
    280a:	80 93 d4 0d 	sts	0x0DD4, r24
    tx_frame[5] = GDrAddr; //目标短地址低8位.
    280e:	00 93 d5 0d 	sts	0x0DD5, r16
    tx_frame[6] = (GDrAddr)>>8 & 0xFF; //目标短地址高8位
    2812:	10 93 d6 0d 	sts	0x0DD6, r17
    tx_frame[7] = sAddr& 0xFF; //发送源短地址低8位
    2816:	80 91 fc 0b 	lds	r24, 0x0BFC
    281a:	90 91 fd 0b 	lds	r25, 0x0BFD
    281e:	80 93 d7 0d 	sts	0x0DD7, r24
    tx_frame[8] = (sAddr>>8)& 0xFF; //发送源短地址高8位
    2822:	90 93 d8 0d 	sts	0x0DD8, r25
    tx_frame[9] =dataSendBuffer[dataSendBufferHead].dAddr[0];		   
    2826:	80 91 58 0d 	lds	r24, 0x0D58
    282a:	90 91 59 0d 	lds	r25, 0x0D59
    282e:	fc 01       	movw	r30, r24
    2830:	03 e0       	ldi	r16, 0x03	; 3
    2832:	ee 0f       	add	r30, r30
    2834:	ff 1f       	adc	r31, r31
    2836:	0a 95       	dec	r16
    2838:	e1 f7       	brne	.-8      	; 0x2832 <receiveDataPrep+0x5ec>
    283a:	e8 1b       	sub	r30, r24
    283c:	f9 0b       	sbc	r31, r25
    283e:	e0 5a       	subi	r30, 0xA0	; 160
    2840:	f2 4f       	sbci	r31, 0xF2	; 242
    2842:	80 81       	ld	r24, Z
    2844:	80 93 d9 0d 	sts	0x0DD9, r24
    tx_frame[10]=dataSendBuffer[dataSendBufferHead].dAddr[1];
    2848:	81 81       	ldd	r24, Z+1	; 0x01
    284a:	80 93 da 0d 	sts	0x0DDA, r24
    tx_frame[11]=dataSendBuffer[dataSendBufferHead].data[0];
    284e:	82 81       	ldd	r24, Z+2	; 0x02
    2850:	80 93 db 0d 	sts	0x0DDB, r24
    tx_frame[12]=dataSendBuffer[dataSendBufferHead].data[1];
    2854:	83 81       	ldd	r24, Z+3	; 0x03
    2856:	80 93 dc 0d 	sts	0x0DDC, r24
    tx_frame[13]=dataSendBuffer[dataSendBufferHead].data[2];
    285a:	84 81       	ldd	r24, Z+4	; 0x04
    285c:	80 93 dd 0d 	sts	0x0DDD, r24
    tx_frame[14]=dataSendBuffer[dataSendBufferHead].data[3];
    2860:	85 81       	ldd	r24, Z+5	; 0x05
    2862:	80 93 de 0d 	sts	0x0DDE, r24
    tx_frame[15]=dataSendBuffer[dataSendBufferHead].data[4];
    2866:	86 81       	ldd	r24, Z+6	; 0x06
    2868:	80 93 df 0d 	sts	0x0DDF, r24
    comPrintString("Sending Mess:::::::");
    286c:	81 e3       	ldi	r24, 0x31	; 49
    286e:	98 e0       	ldi	r25, 0x08	; 8
    2870:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	comPrintString("Dest Saddr apart:::::::");
    2874:	85 e4       	ldi	r24, 0x45	; 69
    2876:	98 e0       	ldi	r25, 0x08	; 8
    2878:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(dataSendBuffer[dataSendBufferHead].dAddr[1]);  
    287c:	80 91 58 0d 	lds	r24, 0x0D58
    2880:	90 91 59 0d 	lds	r25, 0x0D59
    2884:	fc 01       	movw	r30, r24
    2886:	13 e0       	ldi	r17, 0x03	; 3
    2888:	ee 0f       	add	r30, r30
    288a:	ff 1f       	adc	r31, r31
    288c:	1a 95       	dec	r17
    288e:	e1 f7       	brne	.-8      	; 0x2888 <receiveDataPrep+0x642>
    2890:	e8 1b       	sub	r30, r24
    2892:	f9 0b       	sbc	r31, r25
    2894:	e0 5a       	subi	r30, 0xA0	; 160
    2896:	f2 4f       	sbci	r31, 0xF2	; 242
    2898:	81 81       	ldd	r24, Z+1	; 0x01
    289a:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_send_hex(dataSendBuffer[dataSendBufferHead].dAddr[0]); 
    289e:	80 91 58 0d 	lds	r24, 0x0D58
    28a2:	90 91 59 0d 	lds	r25, 0x0D59
    28a6:	fc 01       	movw	r30, r24
    28a8:	b3 e0       	ldi	r27, 0x03	; 3
    28aa:	ee 0f       	add	r30, r30
    28ac:	ff 1f       	adc	r31, r31
    28ae:	ba 95       	dec	r27
    28b0:	e1 f7       	brne	.-8      	; 0x28aa <receiveDataPrep+0x664>
    28b2:	e8 1b       	sub	r30, r24
    28b4:	f9 0b       	sbc	r31, r25
    28b6:	e0 5a       	subi	r30, 0xA0	; 160
    28b8:	f2 4f       	sbci	r31, 0xF2	; 242
    28ba:	80 81       	ld	r24, Z
    28bc:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	comPrintString("To Dest Data is:::::::");
    28c0:	8d e5       	ldi	r24, 0x5D	; 93
    28c2:	98 e0       	ldi	r25, 0x08	; 8
    28c4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(dataSendBuffer[dataSendBufferHead].data[0]); 
    28c8:	80 91 58 0d 	lds	r24, 0x0D58
    28cc:	90 91 59 0d 	lds	r25, 0x0D59
    28d0:	fc 01       	movw	r30, r24
    28d2:	a3 e0       	ldi	r26, 0x03	; 3
    28d4:	ee 0f       	add	r30, r30
    28d6:	ff 1f       	adc	r31, r31
    28d8:	aa 95       	dec	r26
    28da:	e1 f7       	brne	.-8      	; 0x28d4 <receiveDataPrep+0x68e>
    28dc:	e8 1b       	sub	r30, r24
    28de:	f9 0b       	sbc	r31, r25
    28e0:	e0 5a       	subi	r30, 0xA0	; 160
    28e2:	f2 4f       	sbci	r31, 0xF2	; 242
    28e4:	82 81       	ldd	r24, Z+2	; 0x02
    28e6:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_send_hex(dataSendBuffer[dataSendBufferHead].data[1]); 
    28ea:	80 91 58 0d 	lds	r24, 0x0D58
    28ee:	90 91 59 0d 	lds	r25, 0x0D59
    28f2:	fc 01       	movw	r30, r24
    28f4:	73 e0       	ldi	r23, 0x03	; 3
    28f6:	ee 0f       	add	r30, r30
    28f8:	ff 1f       	adc	r31, r31
    28fa:	7a 95       	dec	r23
    28fc:	e1 f7       	brne	.-8      	; 0x28f6 <receiveDataPrep+0x6b0>
    28fe:	e8 1b       	sub	r30, r24
    2900:	f9 0b       	sbc	r31, r25
    2902:	e0 5a       	subi	r30, 0xA0	; 160
    2904:	f2 4f       	sbci	r31, 0xF2	; 242
    2906:	83 81       	ldd	r24, Z+3	; 0x03
    2908:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_send_hex(dataSendBuffer[dataSendBufferHead].data[2]); 
    290c:	80 91 58 0d 	lds	r24, 0x0D58
    2910:	90 91 59 0d 	lds	r25, 0x0D59
    2914:	fc 01       	movw	r30, r24
    2916:	63 e0       	ldi	r22, 0x03	; 3
    2918:	ee 0f       	add	r30, r30
    291a:	ff 1f       	adc	r31, r31
    291c:	6a 95       	dec	r22
    291e:	e1 f7       	brne	.-8      	; 0x2918 <receiveDataPrep+0x6d2>
    2920:	e8 1b       	sub	r30, r24
    2922:	f9 0b       	sbc	r31, r25
    2924:	e0 5a       	subi	r30, 0xA0	; 160
    2926:	f2 4f       	sbci	r31, 0xF2	; 242
    2928:	84 81       	ldd	r24, Z+4	; 0x04
    292a:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_send_hex(dataSendBuffer[dataSendBufferHead].data[3]); 
    292e:	80 91 58 0d 	lds	r24, 0x0D58
    2932:	90 91 59 0d 	lds	r25, 0x0D59
    2936:	fc 01       	movw	r30, r24
    2938:	53 e0       	ldi	r21, 0x03	; 3
    293a:	ee 0f       	add	r30, r30
    293c:	ff 1f       	adc	r31, r31
    293e:	5a 95       	dec	r21
    2940:	e1 f7       	brne	.-8      	; 0x293a <receiveDataPrep+0x6f4>
    2942:	e8 1b       	sub	r30, r24
    2944:	f9 0b       	sbc	r31, r25
    2946:	e0 5a       	subi	r30, 0xA0	; 160
    2948:	f2 4f       	sbci	r31, 0xF2	; 242
    294a:	85 81       	ldd	r24, Z+5	; 0x05
    294c:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_send_hex(dataSendBuffer[dataSendBufferHead].data[4]);     
    2950:	80 91 58 0d 	lds	r24, 0x0D58
    2954:	90 91 59 0d 	lds	r25, 0x0D59
    2958:	fc 01       	movw	r30, r24
    295a:	43 e0       	ldi	r20, 0x03	; 3
    295c:	ee 0f       	add	r30, r30
    295e:	ff 1f       	adc	r31, r31
    2960:	4a 95       	dec	r20
    2962:	e1 f7       	brne	.-8      	; 0x295c <receiveDataPrep+0x716>
    2964:	e8 1b       	sub	r30, r24
    2966:	f9 0b       	sbc	r31, r25
    2968:	e0 5a       	subi	r30, 0xA0	; 160
    296a:	f2 4f       	sbci	r31, 0xF2	; 242
    296c:	86 81       	ldd	r24, Z+6	; 0x06
    296e:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	if (set_trx_state( TX_ARET_ON ) == TAT_SUCCESS) 
    2972:	89 e1       	ldi	r24, 0x19	; 25
    2974:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    2978:	80 34       	cpi	r24, 0x40	; 64
    297a:	29 f5       	brne	.+74     	; 0x29c6 <receiveDataPrep+0x780>
    {
      rx_flag = false;
    297c:	10 92 52 0e 	sts	0x0E52, r1
	  if (tat_send_data_with_retry( 18, tx_frame,15) == TAT_SUCCESS) 
    2980:	82 e1       	ldi	r24, 0x12	; 18
    2982:	60 ed       	ldi	r22, 0xD0	; 208
    2984:	7d e0       	ldi	r23, 0x0D	; 13
    2986:	4f e0       	ldi	r20, 0x0F	; 15
    2988:	0e 94 d4 06 	call	0xda8	; 0xda8 <tat_send_data_with_retry>
    298c:	80 34       	cpi	r24, 0x40	; 64
    298e:	c1 f4       	brne	.+48     	; 0x29c0 <receiveDataPrep+0x77a>
	  {	   
		 comPrintString("\r\n<<");
    2990:	8e e2       	ldi	r24, 0x2E	; 46
    2992:	92 e0       	ldi	r25, 0x02	; 2
    2994:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    2998:	00 ed       	ldi	r16, 0xD0	; 208
    299a:	1d e0       	ldi	r17, 0x0D	; 13
		 for(i=0;i<=15;i++)
		 {
		 	 com_send_hex(tx_frame[i]);
    299c:	d8 01       	movw	r26, r16
    299e:	8d 91       	ld	r24, X+
    29a0:	8d 01       	movw	r16, r26
    29a2:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
			 comPrintString(" ");
    29a6:	83 e3       	ldi	r24, 0x33	; 51
    29a8:	92 e0       	ldi	r25, 0x02	; 2
    29aa:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    {
      rx_flag = false;
	  if (tat_send_data_with_retry( 18, tx_frame,15) == TAT_SUCCESS) 
	  {	   
		 comPrintString("\r\n<<");
		 for(i=0;i<=15;i++)
    29ae:	bd e0       	ldi	r27, 0x0D	; 13
    29b0:	00 3e       	cpi	r16, 0xE0	; 224
    29b2:	1b 07       	cpc	r17, r27
    29b4:	99 f7       	brne	.-26     	; 0x299c <receiveDataPrep+0x756>
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	90 e9       	ldi	r25, 0x90	; 144
    29ba:	01 97       	sbiw	r24, 0x01	; 1
    29bc:	f1 f7       	brne	.-4      	; 0x29ba <receiveDataPrep+0x774>
    29be:	07 c0       	rjmp	.+14     	; 0x29ce <receiveDataPrep+0x788>
			 comPrintString(" ");
		 }
			delay_ms(20);
		 } 
	 	 else 
			 comPrintString("\r\n!<Sent Failed");
    29c0:	85 e3       	ldi	r24, 0x35	; 53
    29c2:	92 e0       	ldi	r25, 0x02	; 2
    29c4:	02 c0       	rjmp	.+4      	; 0x29ca <receiveDataPrep+0x784>
    }
    else 
	   comPrintString("\r\n!!State Change Failed");
    29c6:	85 e4       	ldi	r24, 0x45	; 69
    29c8:	92 e0       	ldi	r25, 0x02	; 2
    29ca:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    29ce:	86 e1       	ldi	r24, 0x16	; 22
    29d0:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    29d4:	80 34       	cpi	r24, 0x40	; 64
    29d6:	21 f0       	breq	.+8      	; 0x29e0 <receiveDataPrep+0x79a>
	   comPrintString("\r\n!!State Change Failed");
    29d8:	85 e4       	ldi	r24, 0x45	; 69
    29da:	92 e0       	ldi	r25, 0x02	; 2
    29dc:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    rx_flag = true; // Set the flag back again. Only used to protec t
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	80 93 52 0e 	sts	0x0E52, r24
					}
			   }
			   comPrintString("\r\n<<To node :::::::.");
			   com_send_hex(rAddr);
			   SendMessage(rAddr);
			   BusyTxSending=0;
    29e6:	10 92 57 0d 	sts	0x0D57, r1
			   PrepAckFlag=0;
    29ea:	10 92 5a 0d 	sts	0x0D5A, r1
    29ee:	ee 24       	eor	r14, r14
    29f0:	ff 24       	eor	r15, r15
    short int p_buf_head=0;
    comPrintString("\r\n!!into Prep times:");
	com_send_hex(j);
	comPrintString("\r\n!!Please pay attention~~~~~~~~~~~~~~~~~~~");
	j++;
    while (rx_pool_network_prep_buf_head != 0) //查看接收池中是否有未处理的包
    29f2:	80 91 5d 0d 	lds	r24, 0x0D5D
    29f6:	88 23       	and	r24, r24
    29f8:	09 f0       	breq	.+2      	; 0x29fc <receiveDataPrep+0x7b6>
    29fa:	5f cc       	rjmp	.-1858   	; 0x22ba <receiveDataPrep+0x74>
			   BusyTxSending=0;
			   PrepAckFlag=0;
            }
		}	   
	}  
}
    29fc:	aa 96       	adiw	r28, 0x2a	; 42
    29fe:	0f b6       	in	r0, 0x3f	; 63
    2a00:	f8 94       	cli
    2a02:	de bf       	out	0x3e, r29	; 62
    2a04:	0f be       	out	0x3f, r0	; 63
    2a06:	cd bf       	out	0x3d, r28	; 61
    2a08:	cf 91       	pop	r28
    2a0a:	df 91       	pop	r29
    2a0c:	1f 91       	pop	r17
    2a0e:	0f 91       	pop	r16
    2a10:	ff 90       	pop	r15
    2a12:	ef 90       	pop	r14
    2a14:	df 90       	pop	r13
    2a16:	cf 90       	pop	r12
    2a18:	bf 90       	pop	r11
    2a1a:	af 90       	pop	r10
    2a1c:	9f 90       	pop	r9
    2a1e:	8f 90       	pop	r8
    2a20:	7f 90       	pop	r7
    2a22:	6f 90       	pop	r6
    2a24:	5f 90       	pop	r5
    2a26:	4f 90       	pop	r4
    2a28:	3f 90       	pop	r3
    2a2a:	2f 90       	pop	r2
    2a2c:	08 95       	ret

00002a2e <trx_end_handler>:
 *  \param[in] time_stamp Interrupt timestamp in IEEE 802.15.4 symbols.
 */
void trx_end_handler( uint32_t time_stamp )
{
    int i;
	if (rx_flag == true) 
    2a2e:	80 91 52 0e 	lds	r24, 0x0E52
    2a32:	88 23       	and	r24, r24
    2a34:	09 f4       	brne	.+2      	; 0x2a38 <trx_end_handler+0xa>
    2a36:	b7 c0       	rjmp	.+366    	; 0x2ba6 <trx_end_handler+0x178>
	{
        //Check if these is space left in the rx_pool.
		if (rx_pool_items_free == 0) 
    2a38:	80 91 4f 0e 	lds	r24, 0x0E4F
    2a3c:	88 23       	and	r24, r24
    2a3e:	21 f4       	brne	.+8      	; 0x2a48 <trx_end_handler+0x1a>
		{
			rx_pool_overflow_flag = true;
    2a40:	81 e0       	ldi	r24, 0x01	; 1
    2a42:	80 93 51 0e 	sts	0x0E51, r24
    2a46:	08 95       	ret
		} 
		else 
		{
			//Space left, so upload the received frame.
			hal_frame_read( &rx_pool_prep);
    2a48:	8f ed       	ldi	r24, 0xDF	; 223
    2a4a:	91 e1       	ldi	r25, 0x11	; 17
    2a4c:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <hal_frame_read>
			//Then check the CRC. Will not store frames with invalid CRC.
			if (rx_pool_prep.crc == true&&rx_pool_prep.data[3]==PanIdL&&rx_pool_prep.data[4]==PanIdH)
    2a50:	80 91 60 12 	lds	r24, 0x1260
    2a54:	88 23       	and	r24, r24
    2a56:	09 f4       	brne	.+2      	; 0x2a5a <trx_end_handler+0x2c>
    2a58:	a6 c0       	rjmp	.+332    	; 0x2ba6 <trx_end_handler+0x178>
    2a5a:	80 91 e3 11 	lds	r24, 0x11E3
    2a5e:	8c 3c       	cpi	r24, 0xCC	; 204
    2a60:	09 f0       	breq	.+2      	; 0x2a64 <trx_end_handler+0x36>
    2a62:	a1 c0       	rjmp	.+322    	; 0x2ba6 <trx_end_handler+0x178>
    2a64:	80 91 e4 11 	lds	r24, 0x11E4
    2a68:	8e 3e       	cpi	r24, 0xEE	; 238
    2a6a:	09 f0       	breq	.+2      	; 0x2a6e <trx_end_handler+0x40>
    2a6c:	9c c0       	rjmp	.+312    	; 0x2ba6 <trx_end_handler+0x178>
			{
				if(!(rx_pool_prep.data[5]==0xFF&&rx_pool_prep.data[6]==0xFF)&&
    2a6e:	80 91 e5 11 	lds	r24, 0x11E5
    2a72:	8f 3f       	cpi	r24, 0xFF	; 255
    2a74:	21 f4       	brne	.+8      	; 0x2a7e <trx_end_handler+0x50>
    2a76:	80 91 e6 11 	lds	r24, 0x11E6
    2a7a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a7c:	21 f0       	breq	.+8      	; 0x2a86 <trx_end_handler+0x58>
    2a7e:	80 91 eb 11 	lds	r24, 0x11EB
    2a82:	83 30       	cpi	r24, 0x03	; 3
    2a84:	a1 f0       	breq	.+40     	; 0x2aae <trx_end_handler+0x80>
    2a86:	80 91 eb 11 	lds	r24, 0x11EB
    2a8a:	85 30       	cpi	r24, 0x05	; 5
    2a8c:	81 f0       	breq	.+32     	; 0x2aae <trx_end_handler+0x80>
    2a8e:	86 30       	cpi	r24, 0x06	; 6
    2a90:	71 f0       	breq	.+28     	; 0x2aae <trx_end_handler+0x80>
    2a92:	87 30       	cpi	r24, 0x07	; 7
    2a94:	61 f0       	breq	.+24     	; 0x2aae <trx_end_handler+0x80>
    2a96:	88 30       	cpi	r24, 0x08	; 8
    2a98:	51 f0       	breq	.+20     	; 0x2aae <trx_end_handler+0x80>
    2a9a:	89 30       	cpi	r24, 0x09	; 9
    2a9c:	41 f0       	breq	.+16     	; 0x2aae <trx_end_handler+0x80>
    2a9e:	80 31       	cpi	r24, 0x10	; 16
    2aa0:	31 f0       	breq	.+12     	; 0x2aae <trx_end_handler+0x80>
    2aa2:	81 31       	cpi	r24, 0x11	; 17
    2aa4:	21 f0       	breq	.+8      	; 0x2aae <trx_end_handler+0x80>
    2aa6:	82 31       	cpi	r24, 0x12	; 18
    2aa8:	11 f0       	breq	.+4      	; 0x2aae <trx_end_handler+0x80>
    2aaa:	88 23       	and	r24, r24
    2aac:	81 f5       	brne	.+96     	; 0x2b0e <trx_end_handler+0xe0>
				rx_pool_prep.data[11]==SCMD_HEAD_OCCUPY||rx_pool_prep.data[11]==SCMD_HEAD_OCCUPY_CONFIRM||
				rx_pool_prep.data[11]==SCMD_TAIL_FIRST_COME||rx_pool_prep.data[11]==SCMD_HEAD_FIRST_COME||
				rx_pool_prep.data[11]==SCMD_MED_FIRST_COME||rx_pool_prep.data[11]==SCMD_SADDR_BROADCAST)      
				{    
					//Handle wrapping of rx_pool.
					if (rx_pool_head == rx_pool_end) 
    2aae:	20 91 af 10 	lds	r18, 0x10AF
    2ab2:	30 91 b0 10 	lds	r19, 0x10B0
    2ab6:	80 91 ad 10 	lds	r24, 0x10AD
    2aba:	90 91 ae 10 	lds	r25, 0x10AE
    2abe:	28 17       	cp	r18, r24
    2ac0:	39 07       	cpc	r19, r25
    2ac2:	41 f4       	brne	.+16     	; 0x2ad4 <trx_end_handler+0xa6>
					{
						rx_pool_head = rx_pool_start;
    2ac4:	80 91 ab 10 	lds	r24, 0x10AB
    2ac8:	90 91 ac 10 	lds	r25, 0x10AC
    2acc:	90 93 b0 10 	sts	0x10B0, r25
    2ad0:	80 93 af 10 	sts	0x10AF, r24
					}
					// end: if (rx_pool_head == rx_pool_end) ...
	                for(i=0;i<=15;i++)
					{
						rx_pool_head->data[i]=rx_pool_prep.data[i];
    2ad4:	20 91 af 10 	lds	r18, 0x10AF
    2ad8:	30 91 b0 10 	lds	r19, 0x10B0
    2adc:	e0 ee       	ldi	r30, 0xE0	; 224
    2ade:	f1 e1       	ldi	r31, 0x11	; 17
    2ae0:	d9 01       	movw	r26, r18
    2ae2:	81 91       	ld	r24, Z+
    2ae4:	8d 93       	st	X+, r24
					if (rx_pool_head == rx_pool_end) 
					{
						rx_pool_head = rx_pool_start;
					}
					// end: if (rx_pool_head == rx_pool_end) ...
	                for(i=0;i<=15;i++)
    2ae6:	81 e1       	ldi	r24, 0x11	; 17
    2ae8:	e0 3f       	cpi	r30, 0xF0	; 240
    2aea:	f8 07       	cpc	r31, r24
    2aec:	d1 f7       	brne	.-12     	; 0x2ae2 <trx_end_handler+0xb4>
					{
						rx_pool_head->data[i]=rx_pool_prep.data[i];
					}
					++rx_pool_head;
    2aee:	2c 5e       	subi	r18, 0xEC	; 236
    2af0:	3f 4f       	sbci	r19, 0xFF	; 255
    2af2:	30 93 b0 10 	sts	0x10B0, r19
    2af6:	20 93 af 10 	sts	0x10AF, r18
					--rx_pool_items_free;
    2afa:	80 91 4f 0e 	lds	r24, 0x0E4F
    2afe:	81 50       	subi	r24, 0x01	; 1
    2b00:	80 93 4f 0e 	sts	0x0E4F, r24
					++rx_pool_items_used;
    2b04:	80 91 50 0e 	lds	r24, 0x0E50
    2b08:	8f 5f       	subi	r24, 0xFF	; 255
    2b0a:	80 93 50 0e 	sts	0x0E50, r24
				}
				if(rx_pool_prep.data[11]==SCMD_SADDR_BROADCAST&&rx_pool_prep.data[5]==0xFF&&
    2b0e:	80 91 eb 11 	lds	r24, 0x11EB
    2b12:	88 23       	and	r24, r24
    2b14:	11 f5       	brne	.+68     	; 0x2b5a <trx_end_handler+0x12c>
    2b16:	80 91 e5 11 	lds	r24, 0x11E5
    2b1a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b1c:	11 f5       	brne	.+68     	; 0x2b62 <trx_end_handler+0x134>
    2b1e:	80 91 e6 11 	lds	r24, 0x11E6
    2b22:	8f 3f       	cpi	r24, 0xFF	; 255
    2b24:	f1 f4       	brne	.+60     	; 0x2b62 <trx_end_handler+0x134>
				rx_pool_prep.data[6]==0xFF)      
				{    
					if (rx_pool_network_maintain_buf_head == RX_POOL_SIZE/2-1) 
    2b26:	80 91 56 0d 	lds	r24, 0x0D56
    2b2a:	8e 30       	cpi	r24, 0x0E	; 14
    2b2c:	11 f4       	brne	.+4      	; 0x2b32 <trx_end_handler+0x104>
					{
						rx_pool_network_maintain_buf_head = 0;
    2b2e:	10 92 56 0d 	sts	0x0D56, r1
					}
					for(i=0;i<=15;i++)
					{
						rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[i]=rx_pool_prep.data[i];
    2b32:	90 91 56 0d 	lds	r25, 0x0D56
    2b36:	a0 ee       	ldi	r26, 0xE0	; 224
    2b38:	b1 e1       	ldi	r27, 0x11	; 17
    2b3a:	84 e1       	ldi	r24, 0x14	; 20
    2b3c:	98 9f       	mul	r25, r24
    2b3e:	f0 01       	movw	r30, r0
    2b40:	11 24       	eor	r1, r1
    2b42:	ed 54       	subi	r30, 0x4D	; 77
    2b44:	ff 4e       	sbci	r31, 0xEF	; 239
    2b46:	8d 91       	ld	r24, X+
    2b48:	81 93       	st	Z+, r24
				{    
					if (rx_pool_network_maintain_buf_head == RX_POOL_SIZE/2-1) 
					{
						rx_pool_network_maintain_buf_head = 0;
					}
					for(i=0;i<=15;i++)
    2b4a:	81 e1       	ldi	r24, 0x11	; 17
    2b4c:	a0 3f       	cpi	r26, 0xF0	; 240
    2b4e:	b8 07       	cpc	r27, r24
    2b50:	d1 f7       	brne	.-12     	; 0x2b46 <trx_end_handler+0x118>
					{
						rx_pool_network_maintain[rx_pool_network_maintain_buf_head].data[i]=rx_pool_prep.data[i];
					}
						rx_pool_network_maintain_buf_head++;
    2b52:	9f 5f       	subi	r25, 0xFF	; 255
    2b54:	90 93 56 0d 	sts	0x0D56, r25
    2b58:	04 c0       	rjmp	.+8      	; 0x2b62 <trx_end_handler+0x134>
				}
				if(rx_pool_prep.data[11]==SCMD_PREP||rx_pool_prep.data[11]==SCMD_PREP_RECEIVED
    2b5a:	81 30       	cpi	r24, 0x01	; 1
    2b5c:	59 f0       	breq	.+22     	; 0x2b74 <trx_end_handler+0x146>
    2b5e:	84 30       	cpi	r24, 0x04	; 4
    2b60:	49 f0       	breq	.+18     	; 0x2b74 <trx_end_handler+0x146>
    2b62:	80 91 e9 11 	lds	r24, 0x11E9
    2b66:	8f 3f       	cpi	r24, 0xFF	; 255
    2b68:	29 f4       	brne	.+10     	; 0x2b74 <trx_end_handler+0x146>
    2b6a:	80 ee       	ldi	r24, 0xE0	; 224
    2b6c:	91 e1       	ldi	r25, 0x11	; 17
    2b6e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b70:	91 05       	cpc	r25, r1
    2b72:	c9 f0       	breq	.+50     	; 0x2ba6 <trx_end_handler+0x178>
				||!(rx_pool_prep.data[9]==0xFF&&rx_pool_prep.data==0xFF))      
				{    
					if (rx_pool_network_prep_buf_head == RX_POOL_SIZE/2-1) 
    2b74:	80 91 5d 0d 	lds	r24, 0x0D5D
    2b78:	8e 30       	cpi	r24, 0x0E	; 14
    2b7a:	11 f4       	brne	.+4      	; 0x2b80 <trx_end_handler+0x152>
					{
						rx_pool_network_prep_buf_head = 0;
    2b7c:	10 92 5d 0d 	sts	0x0D5D, r1
					}
					for(i=0;i<=18;i++)
					{
						rx_pool_network_prep[rx_pool_network_prep_buf_head].data[i]=rx_pool_prep.data[i];
    2b80:	90 91 5d 0d 	lds	r25, 0x0D5D
    2b84:	a0 ee       	ldi	r26, 0xE0	; 224
    2b86:	b1 e1       	ldi	r27, 0x11	; 17
    2b88:	84 e1       	ldi	r24, 0x14	; 20
    2b8a:	98 9f       	mul	r25, r24
    2b8c:	f0 01       	movw	r30, r0
    2b8e:	11 24       	eor	r1, r1
    2b90:	ef 59       	subi	r30, 0x9F	; 159
    2b92:	fd 4e       	sbci	r31, 0xED	; 237
    2b94:	8d 91       	ld	r24, X+
    2b96:	81 93       	st	Z+, r24
				{    
					if (rx_pool_network_prep_buf_head == RX_POOL_SIZE/2-1) 
					{
						rx_pool_network_prep_buf_head = 0;
					}
					for(i=0;i<=18;i++)
    2b98:	81 e1       	ldi	r24, 0x11	; 17
    2b9a:	a3 3f       	cpi	r26, 0xF3	; 243
    2b9c:	b8 07       	cpc	r27, r24
    2b9e:	d1 f7       	brne	.-12     	; 0x2b94 <trx_end_handler+0x166>
					{
						rx_pool_network_prep[rx_pool_network_prep_buf_head].data[i]=rx_pool_prep.data[i];
					}
						rx_pool_network_prep_buf_head++;
    2ba0:	9f 5f       	subi	r25, 0xFF	; 255
    2ba2:	90 93 5d 0d 	sts	0x0D5D, r25
    2ba6:	08 95       	ret

00002ba8 <avr_init>:
}    
/*! \brief 初始化IO模式
 */
void avr_init( void )
{
	com_init( BR_115200 );
    2ba8:	83 e0       	ldi	r24, 0x03	; 3
    2baa:	0e 94 87 00 	call	0x10e	; 0x10e <com_init>
}
    2bae:	08 95       	ret

00002bb0 <trx_init>:
 *  \retval true if the TRX was successfully configured.
 *  \retval false if the TRX was not configured properly.
 */
bool trx_init( void )//R212 Modify
{
	if (hal_init() != SUCCESS)
    2bb0:	0e 94 9b 01 	call	0x336	; 0x336 <hal_init>
    2bb4:	88 23       	and	r24, r24
    2bb6:	79 f5       	brne	.+94     	; 0x2c16 <trx_init+0x66>
	{
		return false;
	}
	trx_config();	
    2bb8:	0e 94 45 09 	call	0x128a	; 0x128a <trx_config>
	if (tat_init() != TAT_SUCCESS)
    2bbc:	0e 94 97 0a 	call	0x152e	; 0x152e <tat_init>
    2bc0:	80 34       	cpi	r24, 0x40	; 64
    2bc2:	49 f5       	brne	.+82     	; 0x2c16 <trx_init+0x66>
	{
		return false;
	}
	if (tat_set_operating_channel( RF212_WPAN_CHANNLE0 ) != TAT_SUCCESS) 
    2bc4:	8e e6       	ldi	r24, 0x6E	; 110
    2bc6:	0e 94 65 0a 	call	0x14ca	; 0x14ca <tat_set_operating_channel>
    2bca:	80 34       	cpi	r24, 0x40	; 64
    2bcc:	21 f5       	brne	.+72     	; 0x2c16 <trx_init+0x66>
	{
		return false;    
	}	
	tat_set_modulation_datarate(BPSK_20);
    2bce:	80 e0       	ldi	r24, 0x00	; 0
    2bd0:	0e 94 34 0a 	call	0x1468	; 0x1468 <tat_set_modulation_datarate>
	tat_set_tx_power_level(WPAN_TXPWR_BP10DBM, R212_PABOOST_ON);	
    2bd4:	80 ec       	ldi	r24, 0xC0	; 192
    2bd6:	61 e0       	ldi	r22, 0x01	; 1
    2bd8:	0e 94 78 09 	call	0x12f0	; 0x12f0 <tat_set_tx_power_level>
    /*Set up the extended modes:*/
    //RX_AACK:
    tat_set_short_address( sAddr ); //Short Address.
    2bdc:	80 91 fc 0b 	lds	r24, 0x0BFC
    2be0:	90 91 fd 0b 	lds	r25, 0x0BFD
    2be4:	0e 94 2d 09 	call	0x125a	; 0x125a <tat_set_short_address>
    tat_set_pan_id( PAN_ID ); //PAN ID.
    2be8:	8c ec       	ldi	r24, 0xCC	; 204
    2bea:	9e ee       	ldi	r25, 0xEE	; 238
    2bec:	0e 94 39 09 	call	0x1272	; 0x1272 <tat_set_pan_id>
    tat_set_device_role( false ); // No Coordintor support is necessary.     
    2bf0:	80 e0       	ldi	r24, 0x00	; 0
    2bf2:	0e 94 98 07 	call	0xf30	; 0xf30 <tat_set_device_role>
    //TX_ARET:
    tat_configure_csma( 234, 0xE2 ); // Default CSMA_SEED_0, MIN_BE = 3, MAX_CSMA_RETRIES = , and CSMA_SEED_1 =     
    2bf6:	8a ee       	ldi	r24, 0xEA	; 234
    2bf8:	62 ee       	ldi	r22, 0xE2	; 226
    2bfa:	0e 94 a9 08 	call	0x1152	; 0x1152 <tat_configure_csma>
    //Both Modes:
    tat_use_auto_tx_crc( true ); //Automatic CRC must be enabled.
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	0e 94 9f 07 	call	0xf3e	; 0xf3e <tat_use_auto_tx_crc>
    hal_set_trx_end_event_handler( trx_end_handler ); // Event handler for TRX_END events.       
    2c04:	87 e1       	ldi	r24, 0x17	; 23
    2c06:	95 e1       	ldi	r25, 0x15	; 21
    2c08:	0e 94 63 02 	call	0x4c6	; 0x4c6 <hal_set_trx_end_event_handler>
	hal_register_read(RG_IRQ_STATUS);    /* clear pending irqs, dummy read */
    2c0c:	8f e0       	ldi	r24, 0x0F	; 15
    2c0e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <hal_register_read>
    2c12:	81 e0       	ldi	r24, 0x01	; 1
    2c14:	08 95       	ret
	return true;
    2c16:	80 e0       	ldi	r24, 0x00	; 0
}    
    2c18:	08 95       	ret

00002c1a <main>:
		networkOK=false;
	}
	return networkOK;
}
int main( void )     
{            
    2c1a:	2f 92       	push	r2
    2c1c:	3f 92       	push	r3
    2c1e:	4f 92       	push	r4
    2c20:	5f 92       	push	r5
    2c22:	6f 92       	push	r6
    2c24:	7f 92       	push	r7
    2c26:	8f 92       	push	r8
    2c28:	9f 92       	push	r9
    2c2a:	af 92       	push	r10
    2c2c:	bf 92       	push	r11
    2c2e:	cf 92       	push	r12
    2c30:	df 92       	push	r13
    2c32:	ef 92       	push	r14
    2c34:	ff 92       	push	r15
    2c36:	0f 93       	push	r16
    2c38:	1f 93       	push	r17
    2c3a:	df 93       	push	r29
    2c3c:	cf 93       	push	r28
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	cf 5f       	subi	r28, 0xFF	; 255
    2c44:	d0 40       	sbci	r29, 0x00	; 0
    2c46:	0f b6       	in	r0, 0x3f	; 63
    2c48:	f8 94       	cli
    2c4a:	de bf       	out	0x3e, r29	; 62
    2c4c:	0f be       	out	0x3f, r0	; 63
    2c4e:	cd bf       	out	0x3d, r28	; 61
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    2c50:	43 e5       	ldi	r20, 0x53	; 83
    2c52:	64 2e       	mov	r6, r20
    2c54:	4e e0       	ldi	r20, 0x0E	; 14
    2c56:	74 2e       	mov	r7, r20
    2c58:	38 eb       	ldi	r19, 0xB8	; 184
    2c5a:	a3 2e       	mov	r10, r19
    2c5c:	b1 2c       	mov	r11, r1
    2c5e:	10 c0       	rjmp	.+32     	; 0x2c80 <main+0x66>
		networkOK=false;
	}
	return networkOK;
}
int main( void )     
{            
    2c60:	20 e0       	ldi	r18, 0x00	; 0
    2c62:	30 e0       	ldi	r19, 0x00	; 0
    2c64:	0a c0       	rjmp	.+20     	; 0x2c7a <main+0x60>
    2c66:	f5 01       	movw	r30, r10
    2c68:	31 97       	sbiw	r30, 0x01	; 1
    2c6a:	f1 f7       	brne	.-4      	; 0x2c68 <main+0x4e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c6c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c6e:	d9 f7       	brne	.-10     	; 0x2c66 <main+0x4c>
	int i,j;
	int k=0;
start:
	if(k>0)
	{
		for(i=0;i<=4;i++)
    2c70:	2f 5f       	subi	r18, 0xFF	; 255
    2c72:	3f 4f       	sbci	r19, 0xFF	; 255
    2c74:	25 30       	cpi	r18, 0x05	; 5
    2c76:	31 05       	cpc	r19, r1
    2c78:	19 f0       	breq	.+6      	; 0x2c80 <main+0x66>
    2c7a:	88 ec       	ldi	r24, 0xC8	; 200
    2c7c:	9f ea       	ldi	r25, 0xAF	; 175
    2c7e:	f3 cf       	rjmp	.-26     	; 0x2c66 <main+0x4c>
			delay_ms(15*TPU);
    }
	k++;
	Num=0;
	NewNodeFlag=1;
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	80 93 4b 0d 	sts	0x0D4B, r24
    rx_flag = true;    
    2c86:	80 93 52 0e 	sts	0x0E52, r24
	cli();
    2c8a:	f8 94       	cli
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    2c8c:	70 92 ac 10 	sts	0x10AC, r7
    2c90:	60 92 ab 10 	sts	0x10AB, r6
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    2c94:	87 e9       	ldi	r24, 0x97	; 151
    2c96:	90 e1       	ldi	r25, 0x10	; 16
    2c98:	90 93 ae 10 	sts	0x10AE, r25
    2c9c:	80 93 ad 10 	sts	0x10AD, r24
    rx_pool_head = rx_pool_start;
    2ca0:	70 92 b0 10 	sts	0x10B0, r7
    2ca4:	60 92 af 10 	sts	0x10AF, r6
	rx_pool_tail = rx_pool_end;
    2ca8:	90 93 b2 10 	sts	0x10B2, r25
    2cac:	80 93 b1 10 	sts	0x10B1, r24
	rx_pool_items_free = RX_POOL_SIZE;
    2cb0:	8e e1       	ldi	r24, 0x1E	; 30
    2cb2:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    2cb6:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    2cba:	10 92 51 0e 	sts	0x0E51, r1
	Num=0;
	NewNodeFlag=1;
    rx_flag = true;    
	cli();
	rx_pool_init( );
	sei();
    2cbe:	78 94       	sei
}    
/*! \brief 初始化IO模式
 */
void avr_init( void )
{
	com_init( BR_115200 );
    2cc0:	83 e0       	ldi	r24, 0x03	; 3
    2cc2:	0e 94 87 00 	call	0x10e	; 0x10e <com_init>
    rx_flag = true;    
	cli();
	rx_pool_init( );
	sei();
	avr_init( );
	trx_init( );
    2cc6:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <trx_init>
    2cca:	80 e0       	ldi	r24, 0x00	; 0
    2ccc:	90 e9       	ldi	r25, 0x90	; 144
    2cce:	01 97       	sbiw	r24, 0x01	; 1
    2cd0:	f1 f7       	brne	.-4      	; 0x2cce <main+0xb4>
	delay_ms(20);
	if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS) //转移状态机至RX_AACK_ON状态,以侦听传入包
    2cd2:	86 e1       	ldi	r24, 0x16	; 22
    2cd4:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    2cd8:	80 34       	cpi	r24, 0x40	; 64
    2cda:	29 f0       	breq	.+10     	; 0x2ce6 <main+0xcc>
		com_send_string( debug_fatal_error, sizeof( debug_fatal_error ) );
    2cdc:	8e ef       	ldi	r24, 0xFE	; 254
    2cde:	9b e0       	ldi	r25, 0x0B	; 11
    2ce0:	67 e2       	ldi	r22, 0x27	; 39
    2ce2:	0e 94 a0 00 	call	0x140	; 0x140 <com_send_string>
	sei( );
    2ce6:	78 94       	sei
	Timer4_init();//初始化发送延迟计数器
    2ce8:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <Timer4_init>
	hal_set_net_led();//亮灯,表示网络就绪
    2cec:	5f 98       	cbi	0x0b, 7	; 11
	return 0;
}
uint8_t scanNeighborNodes(neighborNode* neighborTable)
{
	uint8_t i=0;
	uint8_t rssi=0;
    2cee:	19 82       	std	Y+1, r1	; 0x01
	short int searchCount=0;
	comPrintString("\r\n!!Start to search the neighbor nodes...");
    2cf0:	84 e7       	ldi	r24, 0x74	; 116
    2cf2:	98 e0       	ldi	r25, 0x08	; 8
    2cf4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    2cf8:	80 e0       	ldi	r24, 0x00	; 0
    2cfa:	90 e9       	ldi	r25, 0x90	; 144
    2cfc:	01 97       	sbiw	r24, 0x01	; 1
    2cfe:	f1 f7       	brne	.-4      	; 0x2cfc <main+0xe2>
	delay_ms(20);
	if (set_trx_state( RX_ON ) != TAT_SUCCESS) //转移状态机至RX_AACK_ON状态,以侦听传入包
    2d00:	86 e0       	ldi	r24, 0x06	; 6
    2d02:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    2d06:	80 34       	cpi	r24, 0x40	; 64
    2d08:	21 f0       	breq	.+8      	; 0x2d12 <main+0xf8>
	{
		comPrintString("\r\n!!FETAL ERROR");
    2d0a:	8e e9       	ldi	r24, 0x9E	; 158
    2d0c:	98 e0       	ldi	r25, 0x08	; 8
    2d0e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    2d12:	dd 24       	eor	r13, r13
    2d14:	ee 24       	eor	r14, r14
    2d16:	ff 24       	eor	r15, r15
			readRxPool();
			if(rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_SADDR_BROADCAST)//收到短地址广播
			{
				neighborTable[i].sAddr[0]=rx_pool_tail->data[7];
				neighborTable[i].sAddr[1]=rx_pool_tail->data[8];
				tat_do_ed_scan(&rssi);
    2d18:	4e 01       	movw	r8, r28
    2d1a:	08 94       	sec
    2d1c:	81 1c       	adc	r8, r1
    2d1e:	91 1c       	adc	r9, r1
	{
		comPrintString("\r\n!!FETAL ERROR");
	} 
	while(searchCount<Search_Count_Number)
	{
		if (rx_pool_items_used != 0) //查看接收池中是否有未处理的包
    2d20:	80 91 50 0e 	lds	r24, 0x0E50
    2d24:	88 23       	and	r24, r24
    2d26:	09 f4       	brne	.+2      	; 0x2d2a <main+0x110>
    2d28:	84 c0       	rjmp	.+264    	; 0x2e32 <main+0x218>
	}
	return i;
}
void readRxPool(void)
{
	hal_set_data_led();//亮灯,表示收到信息
    2d2a:	2e 98       	cbi	0x05, 6	; 5
	if (rx_pool_tail == rx_pool_end) 
    2d2c:	20 91 b1 10 	lds	r18, 0x10B1
    2d30:	30 91 b2 10 	lds	r19, 0x10B2
    2d34:	80 91 ad 10 	lds	r24, 0x10AD
    2d38:	90 91 ae 10 	lds	r25, 0x10AE
    2d3c:	28 17       	cp	r18, r24
    2d3e:	39 07       	cpc	r19, r25
    2d40:	49 f4       	brne	.+18     	; 0x2d54 <main+0x13a>
	{
		rx_pool_tail = rx_pool_start;
    2d42:	80 91 ab 10 	lds	r24, 0x10AB
    2d46:	90 91 ac 10 	lds	r25, 0x10AC
    2d4a:	90 93 b2 10 	sts	0x10B2, r25
    2d4e:	80 93 b1 10 	sts	0x10B1, r24
    2d52:	06 c0       	rjmp	.+12     	; 0x2d60 <main+0x146>
	} 
	else 
	{
		++rx_pool_tail;
    2d54:	2c 5e       	subi	r18, 0xEC	; 236
    2d56:	3f 4f       	sbci	r19, 0xFF	; 255
    2d58:	30 93 b2 10 	sts	0x10B2, r19
    2d5c:	20 93 b1 10 	sts	0x10B1, r18
	} 
	cli( );
    2d60:	f8 94       	cli
	++rx_pool_items_free;
    2d62:	80 91 4f 0e 	lds	r24, 0x0E4F
    2d66:	8f 5f       	subi	r24, 0xFF	; 255
    2d68:	80 93 4f 0e 	sts	0x0E4F, r24
	--rx_pool_items_used;
    2d6c:	80 91 50 0e 	lds	r24, 0x0E50
    2d70:	81 50       	subi	r24, 0x01	; 1
    2d72:	80 93 50 0e 	sts	0x0E50, r24
	sei( );//接收池中数据出队
    2d76:	78 94       	sei
	hal_clear_data_led();//灭灯
    2d78:	2e 9a       	sbi	0x05, 6	; 5
	while(searchCount<Search_Count_Number)
	{
		if (rx_pool_items_used != 0) //查看接收池中是否有未处理的包
		{
			readRxPool();
			if(rx_pool_tail->data[9]== 0xFF && rx_pool_tail->data[10]==0xFF && rx_pool_tail->data[11]==SCMD_SADDR_BROADCAST)//收到短地址广播
    2d7a:	e0 91 b1 10 	lds	r30, 0x10B1
    2d7e:	f0 91 b2 10 	lds	r31, 0x10B2
    2d82:	81 85       	ldd	r24, Z+9	; 0x09
    2d84:	8f 3f       	cpi	r24, 0xFF	; 255
    2d86:	09 f0       	breq	.+2      	; 0x2d8a <main+0x170>
    2d88:	5b c0       	rjmp	.+182    	; 0x2e40 <main+0x226>
    2d8a:	82 85       	ldd	r24, Z+10	; 0x0a
    2d8c:	8f 3f       	cpi	r24, 0xFF	; 255
    2d8e:	09 f0       	breq	.+2      	; 0x2d92 <main+0x178>
    2d90:	57 c0       	rjmp	.+174    	; 0x2e40 <main+0x226>
    2d92:	83 85       	ldd	r24, Z+11	; 0x0b
    2d94:	88 23       	and	r24, r24
    2d96:	09 f0       	breq	.+2      	; 0x2d9a <main+0x180>
    2d98:	53 c0       	rjmp	.+166    	; 0x2e40 <main+0x226>
			{
				neighborTable[i].sAddr[0]=rx_pool_tail->data[7];
    2d9a:	0d 2d       	mov	r16, r13
    2d9c:	10 e0       	ldi	r17, 0x00	; 0
    2d9e:	00 0f       	add	r16, r16
    2da0:	11 1f       	adc	r17, r17
    2da2:	00 0f       	add	r16, r16
    2da4:	11 1f       	adc	r17, r17
    2da6:	82 e0       	ldi	r24, 0x02	; 2
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	8c 0f       	add	r24, r28
    2dac:	9d 1f       	adc	r25, r29
    2dae:	08 0f       	add	r16, r24
    2db0:	19 1f       	adc	r17, r25
    2db2:	87 81       	ldd	r24, Z+7	; 0x07
    2db4:	f8 01       	movw	r30, r16
    2db6:	80 83       	st	Z, r24
				neighborTable[i].sAddr[1]=rx_pool_tail->data[8];
    2db8:	e0 91 b1 10 	lds	r30, 0x10B1
    2dbc:	f0 91 b2 10 	lds	r31, 0x10B2
    2dc0:	80 85       	ldd	r24, Z+8	; 0x08
    2dc2:	f8 01       	movw	r30, r16
    2dc4:	81 83       	std	Z+1, r24	; 0x01
				tat_do_ed_scan(&rssi);
    2dc6:	c4 01       	movw	r24, r8
    2dc8:	0e 94 16 0a 	call	0x142c	; 0x142c <tat_do_ed_scan>
				neighborTable[i].rssi=rssi;
    2dcc:	89 81       	ldd	r24, Y+1	; 0x01
    2dce:	f8 01       	movw	r30, r16
    2dd0:	82 83       	std	Z+2, r24	; 0x02
				neighborTable[i].attri=rx_pool_tail->data[12];
    2dd2:	e0 91 b1 10 	lds	r30, 0x10B1
    2dd6:	f0 91 b2 10 	lds	r31, 0x10B2
    2dda:	84 85       	ldd	r24, Z+12	; 0x0c
    2ddc:	f8 01       	movw	r30, r16
    2dde:	83 83       	std	Z+3, r24	; 0x03
				com_send_string(search_found,sizeof(search_found));
    2de0:	86 e2       	ldi	r24, 0x26	; 38
    2de2:	9c e0       	ldi	r25, 0x0C	; 12
    2de4:	69 e1       	ldi	r22, 0x19	; 25
    2de6:	0e 94 a0 00 	call	0x140	; 0x140 <com_send_string>
				com_send_string(search_sAddr,sizeof(search_sAddr));
    2dea:	8f e3       	ldi	r24, 0x3F	; 63
    2dec:	9c e0       	ldi	r25, 0x0C	; 12
    2dee:	63 e1       	ldi	r22, 0x13	; 19
    2df0:	0e 94 a0 00 	call	0x140	; 0x140 <com_send_string>
				com_send_dec(neighborTable[i].sAddr[1]);
    2df4:	f8 01       	movw	r30, r16
    2df6:	81 81       	ldd	r24, Z+1	; 0x01
    2df8:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
				comPrintString(".");
    2dfc:	8e ea       	ldi	r24, 0xAE	; 174
    2dfe:	98 e0       	ldi	r25, 0x08	; 8
    2e00:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				com_send_dec(neighborTable[i].sAddr[0]);
    2e04:	f8 01       	movw	r30, r16
    2e06:	80 81       	ld	r24, Z
    2e08:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
				if(neighborTable[i].attri==0x01)
    2e0c:	f8 01       	movw	r30, r16
    2e0e:	83 81       	ldd	r24, Z+3	; 0x03
    2e10:	81 30       	cpi	r24, 0x01	; 1
    2e12:	21 f4       	brne	.+8      	; 0x2e1c <main+0x202>
				{
					comPrintString("(is Tail)");
    2e14:	80 eb       	ldi	r24, 0xB0	; 176
    2e16:	98 e0       	ldi	r25, 0x08	; 8
    2e18:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				}
				com_send_string(search_rssi,sizeof(search_rssi));
    2e1c:	82 e5       	ldi	r24, 0x52	; 82
    2e1e:	9c e0       	ldi	r25, 0x0C	; 12
    2e20:	6a e0       	ldi	r22, 0x0A	; 10
    2e22:	0e 94 a0 00 	call	0x140	; 0x140 <com_send_string>
				com_send_hex(neighborTable[i].rssi);
    2e26:	f8 01       	movw	r30, r16
    2e28:	82 81       	ldd	r24, Z+2	; 0x02
    2e2a:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
				i++;
    2e2e:	d3 94       	inc	r13
    2e30:	07 c0       	rjmp	.+14     	; 0x2e40 <main+0x226>
    2e32:	80 e6       	ldi	r24, 0x60	; 96
    2e34:	99 e0       	ldi	r25, 0x09	; 9
    2e36:	f5 01       	movw	r30, r10
    2e38:	31 97       	sbiw	r30, 0x01	; 1
    2e3a:	f1 f7       	brne	.-4      	; 0x2e38 <main+0x21e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e3c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e3e:	d9 f7       	brne	.-10     	; 0x2e36 <main+0x21c>
		}
		else
		{
			delay_ms(4*TPU/5);
		}
		searchCount++;
    2e40:	08 94       	sec
    2e42:	e1 1c       	adc	r14, r1
    2e44:	f1 1c       	adc	r15, r1
	delay_ms(20);
	if (set_trx_state( RX_ON ) != TAT_SUCCESS) //转移状态机至RX_AACK_ON状态,以侦听传入包
	{
		comPrintString("\r\n!!FETAL ERROR");
	} 
	while(searchCount<Search_Count_Number)
    2e46:	fc e3       	ldi	r31, 0x3C	; 60
    2e48:	ef 16       	cp	r14, r31
    2e4a:	f1 04       	cpc	r15, r1
    2e4c:	09 f0       	breq	.+2      	; 0x2e50 <main+0x236>
    2e4e:	68 cf       	rjmp	.-304    	; 0x2d20 <main+0x106>
		{
			delay_ms(4*TPU/5);
		}
		searchCount++;
	}
	comPrintString("\r\n!!Searching Finished.Number of Neighbor Nodes Found:");
    2e50:	8a eb       	ldi	r24, 0xBA	; 186
    2e52:	98 e0       	ldi	r25, 0x08	; 8
    2e54:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_dec(i);
    2e58:	8d 2d       	mov	r24, r13
    2e5a:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
    2e5e:	80 e0       	ldi	r24, 0x00	; 0
    2e60:	90 e9       	ldi	r25, 0x90	; 144
    2e62:	01 97       	sbiw	r24, 0x01	; 1
    2e64:	f1 f7       	brne	.-4      	; 0x2e62 <main+0x248>
	delay_ms(20);
	if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    2e66:	86 e1       	ldi	r24, 0x16	; 22
    2e68:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    2e6c:	80 34       	cpi	r24, 0x40	; 64
    2e6e:	21 f0       	breq	.+8      	; 0x2e78 <main+0x25e>
	{
		comPrintString("\r\n!!FETAL ERROR");
    2e70:	8e e9       	ldi	r24, 0x9E	; 158
    2e72:	98 e0       	ldi	r25, 0x08	; 8
    2e74:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    2e78:	de 01       	movw	r26, r28
    2e7a:	12 96       	adiw	r26, 0x02	; 2
    2e7c:	ff 24       	eor	r15, r15
    2e7e:	10 e0       	ldi	r17, 0x00	; 0
    2e80:	00 e0       	ldi	r16, 0x00	; 0
    2e82:	20 e0       	ldi	r18, 0x00	; 0
    2e84:	30 e0       	ldi	r19, 0x00	; 0
	hal_set_net_led();//亮灯,表示网络就绪
    tlength=scanNeighborNodes(neighborTable);//搜索到附近的节点
	rssi_h=0;
	rssi_m=0;
	rssi_t=0;
	for(i=0;i<tlength;i++)//寻找头结点场强
    2e86:	cd 2c       	mov	r12, r13
    2e88:	dd 24       	eor	r13, r13
		if(neighborTable[i].attri==0x01)
		{
			rssi_t=neighborTable[i].rssi;
			sAddr_t=neighborTable[i].sAddr[0]+neighborTable[i].sAddr[1]*256;
		}
		for(j=i;j<tlength;j++)
    2e8a:	a6 01       	movw	r20, r12
    2e8c:	44 0f       	add	r20, r20
    2e8e:	55 1f       	adc	r21, r21
    2e90:	44 0f       	add	r20, r20
    2e92:	55 1f       	adc	r21, r21
    2e94:	4a 0f       	add	r20, r26
    2e96:	5b 1f       	adc	r21, r27
    2e98:	67 c0       	rjmp	.+206    	; 0x2f68 <main+0x34e>
	rssi_h=0;
	rssi_m=0;
	rssi_t=0;
	for(i=0;i<tlength;i++)//寻找头结点场强
	{
		if(neighborTable[i].sAddr[0]==0x00 && neighborTable[i].sAddr[1]==0x00)
    2e9a:	6c 91       	ld	r22, X
    2e9c:	66 23       	and	r22, r22
    2e9e:	41 f4       	brne	.+16     	; 0x2eb0 <main+0x296>
    2ea0:	11 96       	adiw	r26, 0x01	; 1
    2ea2:	8c 91       	ld	r24, X
    2ea4:	11 97       	sbiw	r26, 0x01	; 1
    2ea6:	88 23       	and	r24, r24
    2ea8:	19 f4       	brne	.+6      	; 0x2eb0 <main+0x296>
		{
			rssi_h=neighborTable[i].rssi;
    2eaa:	12 96       	adiw	r26, 0x02	; 2
    2eac:	fc 90       	ld	r15, X
    2eae:	12 97       	sbiw	r26, 0x02	; 2
		}
		if(neighborTable[i].attri==0x01)
    2eb0:	13 96       	adiw	r26, 0x03	; 3
    2eb2:	8c 91       	ld	r24, X
    2eb4:	13 97       	sbiw	r26, 0x03	; 3
    2eb6:	81 30       	cpi	r24, 0x01	; 1
    2eb8:	f1 f4       	brne	.+60     	; 0x2ef6 <main+0x2dc>
		{
			rssi_t=neighborTable[i].rssi;
    2eba:	12 96       	adiw	r26, 0x02	; 2
    2ebc:	0c 91       	ld	r16, X
    2ebe:	12 97       	sbiw	r26, 0x02	; 2
			sAddr_t=neighborTable[i].sAddr[0]+neighborTable[i].sAddr[1]*256;
    2ec0:	11 96       	adiw	r26, 0x01	; 1
    2ec2:	9c 90       	ld	r9, X
    2ec4:	11 97       	sbiw	r26, 0x01	; 1
    2ec6:	c1 50       	subi	r28, 0x01	; 1
    2ec8:	df 4f       	sbci	r29, 0xFF	; 255
    2eca:	98 82       	st	Y, r9
    2ecc:	cf 5f       	subi	r28, 0xFF	; 255
    2ece:	d0 40       	sbci	r29, 0x00	; 0
    2ed0:	c2 50       	subi	r28, 0x02	; 2
    2ed2:	df 4f       	sbci	r29, 0xFF	; 255
    2ed4:	18 82       	st	Y, r1
    2ed6:	ce 5f       	subi	r28, 0xFE	; 254
    2ed8:	d0 40       	sbci	r29, 0x00	; 0
    2eda:	c2 50       	subi	r28, 0x02	; 2
    2edc:	df 4f       	sbci	r29, 0xFF	; 255
    2ede:	88 81       	ld	r24, Y
    2ee0:	99 81       	ldd	r25, Y+1	; 0x01
    2ee2:	ce 5f       	subi	r28, 0xFE	; 254
    2ee4:	d0 40       	sbci	r29, 0x00	; 0
    2ee6:	86 0f       	add	r24, r22
    2ee8:	91 1d       	adc	r25, r1
    2eea:	c6 50       	subi	r28, 0x06	; 6
    2eec:	df 4f       	sbci	r29, 0xFF	; 255
    2eee:	99 83       	std	Y+1, r25	; 0x01
    2ef0:	88 83       	st	Y, r24
    2ef2:	ca 5f       	subi	r28, 0xFA	; 250
    2ef4:	d0 40       	sbci	r29, 0x00	; 0
		}
		for(j=i;j<tlength;j++)
		{
			if(neighborTable[i].sAddr[1]==neighborTable[j].sAddr[1] && abs(neighborTable[i].sAddr[0]-neighborTable[j].sAddr[0])==1
    2ef6:	11 96       	adiw	r26, 0x01	; 1
    2ef8:	ec 90       	ld	r14, X
    2efa:	11 97       	sbiw	r26, 0x01	; 1
				&& min(neighborTable[i].rssi,neighborTable[j].rssi)>rssi_m)
			{
				rssi_m=min(neighborTable[i].rssi,neighborTable[j].rssi);
				sAddr_m=neighborTable[i].sAddr[1]*256+max(neighborTable[i].sAddr[0],neighborTable[j].sAddr[0]);
    2efc:	3e 2c       	mov	r3, r14
    2efe:	22 24       	eor	r2, r2
    2f00:	f9 01       	movw	r30, r18
    2f02:	ee 0f       	add	r30, r30
    2f04:	ff 1f       	adc	r31, r31
    2f06:	ee 0f       	add	r30, r30
    2f08:	ff 1f       	adc	r31, r31
    2f0a:	72 e0       	ldi	r23, 0x02	; 2
    2f0c:	87 2e       	mov	r8, r23
    2f0e:	91 2c       	mov	r9, r1
    2f10:	8c 0e       	add	r8, r28
    2f12:	9d 1e       	adc	r9, r29
    2f14:	e8 0d       	add	r30, r8
    2f16:	f9 1d       	adc	r31, r9
    2f18:	91 2f       	mov	r25, r17
			rssi_t=neighborTable[i].rssi;
			sAddr_t=neighborTable[i].sAddr[0]+neighborTable[i].sAddr[1]*256;
		}
		for(j=i;j<tlength;j++)
		{
			if(neighborTable[i].sAddr[1]==neighborTable[j].sAddr[1] && abs(neighborTable[i].sAddr[0]-neighborTable[j].sAddr[0])==1
    2f1a:	81 81       	ldd	r24, Z+1	; 0x01
    2f1c:	e8 16       	cp	r14, r24
    2f1e:	e1 f4       	brne	.+56     	; 0x2f58 <main+0x33e>
    2f20:	70 81       	ld	r23, Z
    2f22:	86 2f       	mov	r24, r22
    2f24:	87 1b       	sub	r24, r23
    2f26:	81 30       	cpi	r24, 0x01	; 1
    2f28:	b9 f4       	brne	.+46     	; 0x2f58 <main+0x33e>
	tat_set_short_address(newShortAddress);
	sAddr=tat_get_short_address();
}
uint8_t min(uint8_t a,uint8_t b)
{
	return a>b?b:a;
    2f2a:	12 96       	adiw	r26, 0x02	; 2
    2f2c:	8c 91       	ld	r24, X
    2f2e:	12 97       	sbiw	r26, 0x02	; 2
    2f30:	12 81       	ldd	r17, Z+2	; 0x02
    2f32:	81 17       	cp	r24, r17
    2f34:	08 f4       	brcc	.+2      	; 0x2f38 <main+0x31e>
    2f36:	18 2f       	mov	r17, r24
			rssi_t=neighborTable[i].rssi;
			sAddr_t=neighborTable[i].sAddr[0]+neighborTable[i].sAddr[1]*256;
		}
		for(j=i;j<tlength;j++)
		{
			if(neighborTable[i].sAddr[1]==neighborTable[j].sAddr[1] && abs(neighborTable[i].sAddr[0]-neighborTable[j].sAddr[0])==1
    2f38:	91 17       	cp	r25, r17
    2f3a:	70 f4       	brcc	.+28     	; 0x2f58 <main+0x33e>
				&& min(neighborTable[i].rssi,neighborTable[j].rssi)>rssi_m)
			{
				rssi_m=min(neighborTable[i].rssi,neighborTable[j].rssi);
				sAddr_m=neighborTable[i].sAddr[1]*256+max(neighborTable[i].sAddr[0],neighborTable[j].sAddr[0]);
    2f3c:	87 2f       	mov	r24, r23
    2f3e:	76 17       	cp	r23, r22
    2f40:	08 f4       	brcc	.+2      	; 0x2f44 <main+0x32a>
    2f42:	86 2f       	mov	r24, r22
    2f44:	41 01       	movw	r8, r2
    2f46:	88 0e       	add	r8, r24
    2f48:	91 1c       	adc	r9, r1
    2f4a:	c4 50       	subi	r28, 0x04	; 4
    2f4c:	df 4f       	sbci	r29, 0xFF	; 255
    2f4e:	99 82       	std	Y+1, r9	; 0x01
    2f50:	88 82       	st	Y, r8
    2f52:	cc 5f       	subi	r28, 0xFC	; 252
    2f54:	d0 40       	sbci	r29, 0x00	; 0
    2f56:	01 c0       	rjmp	.+2      	; 0x2f5a <main+0x340>
    2f58:	19 2f       	mov	r17, r25
    2f5a:	34 96       	adiw	r30, 0x04	; 4
		if(neighborTable[i].attri==0x01)
		{
			rssi_t=neighborTable[i].rssi;
			sAddr_t=neighborTable[i].sAddr[0]+neighborTable[i].sAddr[1]*256;
		}
		for(j=i;j<tlength;j++)
    2f5c:	e4 17       	cp	r30, r20
    2f5e:	f5 07       	cpc	r31, r21
    2f60:	d9 f6       	brne	.-74     	; 0x2f18 <main+0x2fe>
	hal_set_net_led();//亮灯,表示网络就绪
    tlength=scanNeighborNodes(neighborTable);//搜索到附近的节点
	rssi_h=0;
	rssi_m=0;
	rssi_t=0;
	for(i=0;i<tlength;i++)//寻找头结点场强
    2f62:	2f 5f       	subi	r18, 0xFF	; 255
    2f64:	3f 4f       	sbci	r19, 0xFF	; 255
    2f66:	14 96       	adiw	r26, 0x04	; 4
    2f68:	2c 15       	cp	r18, r12
    2f6a:	3d 05       	cpc	r19, r13
    2f6c:	0c f4       	brge	.+2      	; 0x2f70 <main+0x356>
    2f6e:	95 cf       	rjmp	.-214    	; 0x2e9a <main+0x280>
    2f70:	c4 50       	subi	r28, 0x04	; 4
    2f72:	df 4f       	sbci	r29, 0xFF	; 255
    2f74:	e8 80       	ld	r14, Y
    2f76:	cc 5f       	subi	r28, 0xFC	; 252
    2f78:	d0 40       	sbci	r29, 0x00	; 0
    2f7a:	c3 50       	subi	r28, 0x03	; 3
    2f7c:	df 4f       	sbci	r29, 0xFF	; 255
    2f7e:	d8 80       	ld	r13, Y
    2f80:	cd 5f       	subi	r28, 0xFD	; 253
    2f82:	d0 40       	sbci	r29, 0x00	; 0
				rssi_m=min(neighborTable[i].rssi,neighborTable[j].rssi);
				sAddr_m=neighborTable[i].sAddr[1]*256+max(neighborTable[i].sAddr[0],neighborTable[j].sAddr[0]);
			}
		}
	}
	comPrintString("\r\n>>Head ED:");
    2f84:	81 ef       	ldi	r24, 0xF1	; 241
    2f86:	98 e0       	ldi	r25, 0x08	; 8
    2f88:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(rssi_h);
    2f8c:	8f 2d       	mov	r24, r15
    2f8e:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	comPrintString("\r\n>>Middle ED:");
    2f92:	8e ef       	ldi	r24, 0xFE	; 254
    2f94:	98 e0       	ldi	r25, 0x08	; 8
    2f96:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(rssi_m);
    2f9a:	81 2f       	mov	r24, r17
    2f9c:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	comPrintString("\r\n>>TAIL ED:");
    2fa0:	8d e0       	ldi	r24, 0x0D	; 13
    2fa2:	99 e0       	ldi	r25, 0x09	; 9
    2fa4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	com_send_hex(rssi_t);
    2fa8:	80 2f       	mov	r24, r16
    2faa:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	if(rssi_h==0 && rssi_m==0 && rssi_t==0)//未找到网络
    2fae:	ff 20       	and	r15, r15
    2fb0:	91 f4       	brne	.+36     	; 0x2fd6 <main+0x3bc>
    2fb2:	11 23       	and	r17, r17
    2fb4:	99 f4       	brne	.+38     	; 0x2fdc <main+0x3c2>
    2fb6:	00 23       	and	r16, r16
    2fb8:	a1 f4       	brne	.+40     	; 0x2fe2 <main+0x3c8>
	{
		#ifdef NETSEED//如果是NETSEED,就开启新网络
			comPrintString("\r\n!!Creating New Network...");
    2fba:	8a e1       	ldi	r24, 0x1A	; 26
    2fbc:	99 e0       	ldi	r25, 0x09	; 9
    2fbe:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			setShortAddress(0x0000);
    2fc2:	80 e0       	ldi	r24, 0x00	; 0
    2fc4:	90 e0       	ldi	r25, 0x00	; 0
    2fc6:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
			NewNodeFlag=0;
    2fca:	10 92 4b 0d 	sts	0x0D4B, r1
			attri=0x01;
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	80 93 4c 0d 	sts	0x0D4C, r24
    2fd4:	40 c1       	rjmp	.+640    	; 0x3256 <main+0x63c>
		#else//如果不是NETSEED，等待5秒后重新尝试入网
			delay_ms(1000);
			goto start:
		#endif
	}
	else if(rssi_t>=rssi_h && rssi_t>=rssi_m)//如果是rssi_t最大，执行尾插入网，发送尾节点占用广播
    2fd6:	0f 15       	cp	r16, r15
    2fd8:	08 f4       	brcc	.+2      	; 0x2fdc <main+0x3c2>
    2fda:	8c c0       	rjmp	.+280    	; 0x30f4 <main+0x4da>
    2fdc:	01 17       	cp	r16, r17
    2fde:	08 f4       	brcc	.+2      	; 0x2fe2 <main+0x3c8>
    2fe0:	89 c0       	rjmp	.+274    	; 0x30f4 <main+0x4da>
	{
		NewNodeFlag=1;
    2fe2:	11 e0       	ldi	r17, 0x01	; 1
    2fe4:	10 93 4b 0d 	sts	0x0D4B, r17
		Comparerssi=rssi_t;
    2fe8:	00 93 4d 0d 	sts	0x0D4D, r16
		comPrintString("\r\n!!Current Tail Node Short Address is:");
    2fec:	86 e3       	ldi	r24, 0x36	; 54
    2fee:	99 e0       	ldi	r25, 0x09	; 9
    2ff0:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		attri=0x0001;
    2ff4:	10 93 4c 0d 	sts	0x0D4C, r17
		com_send_dec((sAddr_t>>8) & 0xFF);
    2ff8:	c5 50       	subi	r28, 0x05	; 5
    2ffa:	df 4f       	sbci	r29, 0xFF	; 255
    2ffc:	88 81       	ld	r24, Y
    2ffe:	cb 5f       	subi	r28, 0xFB	; 251
    3000:	d0 40       	sbci	r29, 0x00	; 0
    3002:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		comPrintString(".");
    3006:	8e ea       	ldi	r24, 0xAE	; 174
    3008:	98 e0       	ldi	r25, 0x08	; 8
    300a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_dec(sAddr_t&0xFF);
    300e:	c6 50       	subi	r28, 0x06	; 6
    3010:	df 4f       	sbci	r29, 0xFF	; 255
    3012:	88 81       	ld	r24, Y
    3014:	ca 5f       	subi	r28, 0xFA	; 250
    3016:	d0 40       	sbci	r29, 0x00	; 0
    3018:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		setShortAddress(sAddr_t+1);
    301c:	c6 50       	subi	r28, 0x06	; 6
    301e:	df 4f       	sbci	r29, 0xFF	; 255
    3020:	88 81       	ld	r24, Y
    3022:	99 81       	ldd	r25, Y+1	; 0x01
    3024:	ca 5f       	subi	r28, 0xFA	; 250
    3026:	d0 40       	sbci	r29, 0x00	; 0
    3028:	01 96       	adiw	r24, 0x01	; 1
    302a:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
		receiveData();
    302e:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		if(FirstTailFlag==1)
    3032:	80 91 4e 0d 	lds	r24, 0x0D4E
    3036:	88 23       	and	r24, r24
    3038:	09 f0       	breq	.+2      	; 0x303c <main+0x422>
    303a:	42 c0       	rjmp	.+132    	; 0x30c0 <main+0x4a6>
		{
			attri=0;
			FirstTailFlag=0;
			goto start;
        }
		comPrintString("\r\nBY first juege I am the First Tail~~~");
    303c:	8e e5       	ldi	r24, 0x5E	; 94
    303e:	99 e0       	ldi	r25, 0x09	; 9
    3040:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		SendWild(sAddr,SCMD_TAIL_FIRST_COME);
    3044:	80 91 fc 0b 	lds	r24, 0x0BFC
    3048:	90 91 fd 0b 	lds	r25, 0x0BFD
    304c:	60 e1       	ldi	r22, 0x10	; 16
    304e:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		comPrintString("\r\n<<Broadcast tail occupation...");
    3052:	86 e8       	ldi	r24, 0x86	; 134
    3054:	99 e0       	ldi	r25, 0x09	; 9
    3056:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    305a:	00 e0       	ldi	r16, 0x00	; 0
    305c:	10 e0       	ldi	r17, 0x00	; 0
    305e:	19 c0       	rjmp	.+50     	; 0x3092 <main+0x478>
    3060:	f5 01       	movw	r30, r10
    3062:	31 97       	sbiw	r30, 0x01	; 1
    3064:	f1 f7       	brne	.-4      	; 0x3062 <main+0x448>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3066:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3068:	d9 f7       	brne	.-10     	; 0x3060 <main+0x446>
		for(i=0;i<New_Appling_Cover_Times;i++)
		{
			delay_ms(TPU);
			SendWild(sAddr,SCMD_TAIL_FIRST_COME);
    306a:	80 91 fc 0b 	lds	r24, 0x0BFC
    306e:	90 91 fd 0b 	lds	r25, 0x0BFD
    3072:	60 e1       	ldi	r22, 0x10	; 16
    3074:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			SendWild(sAddr-1,SCMD_TAIL_OCCUPY);//发送短地址占用广播
    3078:	80 91 fc 0b 	lds	r24, 0x0BFC
    307c:	90 91 fd 0b 	lds	r25, 0x0BFD
    3080:	01 97       	sbiw	r24, 0x01	; 1
    3082:	63 e0       	ldi	r22, 0x03	; 3
    3084:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			goto start;
        }
		comPrintString("\r\nBY first juege I am the First Tail~~~");
		SendWild(sAddr,SCMD_TAIL_FIRST_COME);
		comPrintString("\r\n<<Broadcast tail occupation...");
		for(i=0;i<New_Appling_Cover_Times;i++)
    3088:	0f 5f       	subi	r16, 0xFF	; 255
    308a:	1f 4f       	sbci	r17, 0xFF	; 255
    308c:	0a 30       	cpi	r16, 0x0A	; 10
    308e:	11 05       	cpc	r17, r1
    3090:	19 f0       	breq	.+6      	; 0x3098 <main+0x47e>
    3092:	88 eb       	ldi	r24, 0xB8	; 184
    3094:	9b e0       	ldi	r25, 0x0B	; 11
    3096:	e4 cf       	rjmp	.-56     	; 0x3060 <main+0x446>
    3098:	80 e3       	ldi	r24, 0x30	; 48
    309a:	95 e7       	ldi	r25, 0x75	; 117
    309c:	f5 01       	movw	r30, r10
    309e:	31 97       	sbiw	r30, 0x01	; 1
    30a0:	f1 f7       	brne	.-4      	; 0x309e <main+0x484>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    30a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    30a4:	d9 f7       	brne	.-10     	; 0x309c <main+0x482>
			delay_ms(TPU);
			SendWild(sAddr,SCMD_TAIL_FIRST_COME);
			SendWild(sAddr-1,SCMD_TAIL_OCCUPY);//发送短地址占用广播
		}
		delay_ms(First_Wait_time*TPU);
		SendWild(sAddr,SCMD_TAIL_FIRST_COME);
    30a6:	80 91 fc 0b 	lds	r24, 0x0BFC
    30aa:	90 91 fd 0b 	lds	r25, 0x0BFD
    30ae:	60 e1       	ldi	r22, 0x10	; 16
    30b0:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		receiveData();
    30b4:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		if(FirstTailFlag==1)
    30b8:	80 91 4e 0d 	lds	r24, 0x0D4E
    30bc:	88 23       	and	r24, r24
    30be:	29 f0       	breq	.+10     	; 0x30ca <main+0x4b0>
		{		
			attri=0;
    30c0:	10 92 4c 0d 	sts	0x0D4C, r1
			FirstTailFlag=0;
    30c4:	10 92 4e 0d 	sts	0x0D4E, r1
    30c8:	cb cd       	rjmp	.-1130   	; 0x2c60 <main+0x46>
			goto start;
        }
		if(TailConfirmFlag==0)
    30ca:	80 91 4f 0d 	lds	r24, 0x0D4F
    30ce:	88 23       	and	r24, r24
    30d0:	19 f4       	brne	.+6      	; 0x30d8 <main+0x4be>
		{	
			attri=0;
    30d2:	10 92 4c 0d 	sts	0x0D4C, r1
    30d6:	c4 cd       	rjmp	.-1144   	; 0x2c60 <main+0x46>
			goto start;
        }
        NewNodeFlag=0;
    30d8:	10 92 4b 0d 	sts	0x0D4B, r1
		comPrintString("\r\nFinally I am the First Tail~~~");
    30dc:	87 ea       	ldi	r24, 0xA7	; 167
    30de:	99 e0       	ldi	r25, 0x09	; 9
    30e0:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		SendWild(sAddr,SCMD_SADDR_BROADCAST);
    30e4:	80 91 fc 0b 	lds	r24, 0x0BFC
    30e8:	90 91 fd 0b 	lds	r25, 0x0BFD
    30ec:	60 e0       	ldi	r22, 0x00	; 0
    30ee:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
    30f2:	b1 c0       	rjmp	.+354    	; 0x3256 <main+0x63c>
	}
	else if(rssi_m>=rssi_t && rssi_m>=rssi_h)//执行中插入网
    30f4:	10 17       	cp	r17, r16
    30f6:	08 f4       	brcc	.+2      	; 0x30fa <main+0x4e0>
    30f8:	b1 c0       	rjmp	.+354    	; 0x325c <main+0x642>
    30fa:	1f 15       	cp	r17, r15
    30fc:	08 f4       	brcc	.+2      	; 0x3100 <main+0x4e6>
    30fe:	ae c0       	rjmp	.+348    	; 0x325c <main+0x642>
	{
		NewNodeFlag=1;
    3100:	81 e0       	ldi	r24, 0x01	; 1
    3102:	80 93 4b 0d 	sts	0x0D4B, r24
		Comparerssi=rssi_m;
    3106:	10 93 4d 0d 	sts	0x0D4D, r17
		comPrintString("\r\n!!Occupy Short Address:");
    310a:	88 ec       	ldi	r24, 0xC8	; 200
    310c:	99 e0       	ldi	r25, 0x09	; 9
    310e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_dec((sAddr_m>>8) & 0xFF);
    3112:	8d 2d       	mov	r24, r13
    3114:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		comPrintString(".");
    3118:	8e ea       	ldi	r24, 0xAE	; 174
    311a:	98 e0       	ldi	r25, 0x08	; 8
    311c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_dec(sAddr_m&0xFF);
    3120:	8e 2d       	mov	r24, r14
    3122:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		setShortAddress(sAddr_m);
    3126:	8e 2d       	mov	r24, r14
    3128:	9d 2d       	mov	r25, r13
    312a:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
		receiveData();
    312e:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		if(FirstMedFlag==1)
    3132:	80 91 50 0d 	lds	r24, 0x0D50
    3136:	88 23       	and	r24, r24
    3138:	09 f0       	breq	.+2      	; 0x313c <main+0x522>
    313a:	4d c0       	rjmp	.+154    	; 0x31d6 <main+0x5bc>
		{		
			FirstMedFlag=0;
			goto start;
        }
		comPrintString("\r\n<<BY first juege I am the First Med...");
    313c:	82 ee       	ldi	r24, 0xE2	; 226
    313e:	99 e0       	ldi	r25, 0x09	; 9
    3140:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		SendWild(sAddr,SCMD_MED_FIRST_COME);
    3144:	80 91 fc 0b 	lds	r24, 0x0BFC
    3148:	90 91 fd 0b 	lds	r25, 0x0BFD
    314c:	62 e1       	ldi	r22, 0x12	; 18
    314e:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
        receiveData();
    3152:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		comPrintString("\r\n<<Med Broadcast shortAddress occupation...");
    3156:	8b e0       	ldi	r24, 0x0B	; 11
    3158:	9a e0       	ldi	r25, 0x0A	; 10
    315a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		setShortAddress(sAddr_m);
    315e:	8e 2d       	mov	r24, r14
    3160:	9d 2d       	mov	r25, r13
    3162:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
    3166:	00 e0       	ldi	r16, 0x00	; 0
    3168:	10 e0       	ldi	r17, 0x00	; 0
    316a:	19 c0       	rjmp	.+50     	; 0x319e <main+0x584>
    316c:	f5 01       	movw	r30, r10
    316e:	31 97       	sbiw	r30, 0x01	; 1
    3170:	f1 f7       	brne	.-4      	; 0x316e <main+0x554>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3172:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3174:	d9 f7       	brne	.-10     	; 0x316c <main+0x552>
		for(i=0;i<New_Appling_Cover_Times;i++)
		{
			delay_ms(TPU);
			SendWild(sAddr,SCMD_MED_FIRST_COME);
    3176:	80 91 fc 0b 	lds	r24, 0x0BFC
    317a:	90 91 fd 0b 	lds	r25, 0x0BFD
    317e:	62 e1       	ldi	r22, 0x12	; 18
    3180:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			SendWild(sAddr-1,SCMD_SADDR_BROADCAST_NEW);
    3184:	80 91 fc 0b 	lds	r24, 0x0BFC
    3188:	90 91 fd 0b 	lds	r25, 0x0BFD
    318c:	01 97       	sbiw	r24, 0x01	; 1
    318e:	65 e0       	ldi	r22, 0x05	; 5
    3190:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		comPrintString("\r\n<<BY first juege I am the First Med...");
		SendWild(sAddr,SCMD_MED_FIRST_COME);
        receiveData();
		comPrintString("\r\n<<Med Broadcast shortAddress occupation...");
		setShortAddress(sAddr_m);
		for(i=0;i<New_Appling_Cover_Times;i++)
    3194:	0f 5f       	subi	r16, 0xFF	; 255
    3196:	1f 4f       	sbci	r17, 0xFF	; 255
    3198:	0a 30       	cpi	r16, 0x0A	; 10
    319a:	11 05       	cpc	r17, r1
    319c:	19 f0       	breq	.+6      	; 0x31a4 <main+0x58a>
    319e:	88 eb       	ldi	r24, 0xB8	; 184
    31a0:	9b e0       	ldi	r25, 0x0B	; 11
    31a2:	e4 cf       	rjmp	.-56     	; 0x316c <main+0x552>
    31a4:	80 e3       	ldi	r24, 0x30	; 48
    31a6:	95 e7       	ldi	r25, 0x75	; 117
    31a8:	f5 01       	movw	r30, r10
    31aa:	31 97       	sbiw	r30, 0x01	; 1
    31ac:	f1 f7       	brne	.-4      	; 0x31aa <main+0x590>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    31ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    31b0:	d9 f7       	brne	.-10     	; 0x31a8 <main+0x58e>
			delay_ms(TPU);
			SendWild(sAddr,SCMD_MED_FIRST_COME);
			SendWild(sAddr-1,SCMD_SADDR_BROADCAST_NEW);
		}
		delay_ms(First_Wait_time*TPU);
		SendWild(sAddr,SCMD_MED_FIRST_COME);
    31b2:	80 91 fc 0b 	lds	r24, 0x0BFC
    31b6:	90 91 fd 0b 	lds	r25, 0x0BFD
    31ba:	62 e1       	ldi	r22, 0x12	; 18
    31bc:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		receiveData();
    31c0:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
	    if(NewConfirmFlag==0)
    31c4:	80 91 51 0d 	lds	r24, 0x0D51
    31c8:	88 23       	and	r24, r24
    31ca:	09 f4       	brne	.+2      	; 0x31ce <main+0x5b4>
    31cc:	49 cd       	rjmp	.-1390   	; 0x2c60 <main+0x46>
		{	
			goto start;
		}
        if(FirstMedFlag==1)
    31ce:	80 91 50 0d 	lds	r24, 0x0D50
    31d2:	88 23       	and	r24, r24
    31d4:	19 f0       	breq	.+6      	; 0x31dc <main+0x5c2>
		{
			FirstMedFlag=0;
    31d6:	10 92 50 0d 	sts	0x0D50, r1
    31da:	42 cd       	rjmp	.-1404   	; 0x2c60 <main+0x46>
			goto start;
        }
		NewNodeFlag=0;
    31dc:	10 92 4b 0d 	sts	0x0D4B, r1
	   	comPrintString("\r\nFinally I am the First Med~~~");
    31e0:	88 e3       	ldi	r24, 0x38	; 56
    31e2:	9a e0       	ldi	r25, 0x0A	; 10
    31e4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    31e8:	00 e0       	ldi	r16, 0x00	; 0
    31ea:	10 e0       	ldi	r17, 0x00	; 0
    31ec:	18 c0       	rjmp	.+48     	; 0x321e <main+0x604>
    31ee:	f5 01       	movw	r30, r10
    31f0:	31 97       	sbiw	r30, 0x01	; 1
    31f2:	f1 f7       	brne	.-4      	; 0x31f0 <main+0x5d6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    31f4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    31f6:	d9 f7       	brne	.-10     	; 0x31ee <main+0x5d4>
		for(i=0;i<=Broad_Cover_Times;i++)
		{
			delay_ms(TPU);
			SendWild(sAddr,SCMD_MED_FIRST_COME);
    31f8:	80 91 fc 0b 	lds	r24, 0x0BFC
    31fc:	90 91 fd 0b 	lds	r25, 0x0BFD
    3200:	62 e1       	ldi	r22, 0x12	; 18
    3202:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			SendWild(sAddr,SCMD_SADDR_BROADCAST);
    3206:	80 91 fc 0b 	lds	r24, 0x0BFC
    320a:	90 91 fd 0b 	lds	r25, 0x0BFD
    320e:	60 e0       	ldi	r22, 0x00	; 0
    3210:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			FirstMedFlag=0;
			goto start;
        }
		NewNodeFlag=0;
	   	comPrintString("\r\nFinally I am the First Med~~~");
		for(i=0;i<=Broad_Cover_Times;i++)
    3214:	0f 5f       	subi	r16, 0xFF	; 255
    3216:	1f 4f       	sbci	r17, 0xFF	; 255
    3218:	05 31       	cpi	r16, 0x15	; 21
    321a:	11 05       	cpc	r17, r1
    321c:	19 f0       	breq	.+6      	; 0x3224 <main+0x60a>
    321e:	88 eb       	ldi	r24, 0xB8	; 184
    3220:	9b e0       	ldi	r25, 0x0B	; 11
    3222:	e5 cf       	rjmp	.-54     	; 0x31ee <main+0x5d4>
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    3224:	70 92 ac 10 	sts	0x10AC, r7
    3228:	60 92 ab 10 	sts	0x10AB, r6
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    322c:	87 e9       	ldi	r24, 0x97	; 151
    322e:	90 e1       	ldi	r25, 0x10	; 16
    3230:	90 93 ae 10 	sts	0x10AE, r25
    3234:	80 93 ad 10 	sts	0x10AD, r24
    rx_pool_head = rx_pool_start;
    3238:	70 92 b0 10 	sts	0x10B0, r7
    323c:	60 92 af 10 	sts	0x10AF, r6
	rx_pool_tail = rx_pool_end;
    3240:	90 93 b2 10 	sts	0x10B2, r25
    3244:	80 93 b1 10 	sts	0x10B1, r24
	rx_pool_items_free = RX_POOL_SIZE;
    3248:	8e e1       	ldi	r24, 0x1E	; 30
    324a:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    324e:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    3252:	10 92 51 0e 	sts	0x0E51, r1
    3256:	88 24       	eor	r8, r8
    3258:	99 24       	eor	r9, r9
    325a:	88 c0       	rjmp	.+272    	; 0x336c <main+0x752>
			SendWild(sAddr,SCMD_MED_FIRST_COME);
			SendWild(sAddr,SCMD_SADDR_BROADCAST);
        }
		rx_pool_init();
    }
	else if(rssi_h>=rssi_t && rssi_h>=rssi_m)//如果头结点场强最大，执行头插入网，发送头结点占用广播
    325c:	f0 16       	cp	r15, r16
    325e:	d8 f3       	brcs	.-10     	; 0x3256 <main+0x63c>
    3260:	f1 16       	cp	r15, r17
    3262:	c8 f3       	brcs	.-14     	; 0x3256 <main+0x63c>
	{
		NewNodeFlag=1;
    3264:	81 e0       	ldi	r24, 0x01	; 1
    3266:	80 93 4b 0d 	sts	0x0D4B, r24
		Comparerssi=rssi_h;
    326a:	f0 92 4d 0d 	sts	0x0D4D, r15
		setShortAddress(0x0000);
    326e:	80 e0       	ldi	r24, 0x00	; 0
    3270:	90 e0       	ldi	r25, 0x00	; 0
    3272:	0e 94 bd 0b 	call	0x177a	; 0x177a <setShortAddress>
		receiveData();
    3276:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		if(FirstHeadFlag==1)
    327a:	80 91 52 0d 	lds	r24, 0x0D52
    327e:	88 23       	and	r24, r24
    3280:	09 f0       	breq	.+2      	; 0x3284 <main+0x66a>
    3282:	47 c0       	rjmp	.+142    	; 0x3312 <main+0x6f8>
		{
			FirstHeadFlag=0;
			goto start;
        }
		comPrintString("\r\nBY first juege I am the First Head~~~");
    3284:	88 e5       	ldi	r24, 0x58	; 88
    3286:	9a e0       	ldi	r25, 0x0A	; 10
    3288:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		SendWild(sAddr,SCMD_HEAD_FIRST_COME);
    328c:	80 91 fc 0b 	lds	r24, 0x0BFC
    3290:	90 91 fd 0b 	lds	r25, 0x0BFD
    3294:	61 e1       	ldi	r22, 0x11	; 17
    3296:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
        receiveData();
    329a:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		if(FirstHeadFlag==1)
    329e:	80 91 52 0d 	lds	r24, 0x0D52
    32a2:	88 23       	and	r24, r24
    32a4:	b1 f5       	brne	.+108    	; 0x3312 <main+0x6f8>
		{
			FirstHeadFlag=0;
			goto start;
        }
		comPrintString("\r\n<<Broadcast head occupation...");
    32a6:	80 e8       	ldi	r24, 0x80	; 128
    32a8:	9a e0       	ldi	r25, 0x0A	; 10
    32aa:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    32ae:	00 e0       	ldi	r16, 0x00	; 0
    32b0:	10 e0       	ldi	r17, 0x00	; 0
    32b2:	18 c0       	rjmp	.+48     	; 0x32e4 <main+0x6ca>
    32b4:	f5 01       	movw	r30, r10
    32b6:	31 97       	sbiw	r30, 0x01	; 1
    32b8:	f1 f7       	brne	.-4      	; 0x32b6 <main+0x69c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    32bc:	d9 f7       	brne	.-10     	; 0x32b4 <main+0x69a>
		for(i=0;i<New_Appling_Cover_Times;i++)
		{
			delay_ms(TPU);
			SendWild(sAddr,SCMD_HEAD_FIRST_COME);
    32be:	80 91 fc 0b 	lds	r24, 0x0BFC
    32c2:	90 91 fd 0b 	lds	r25, 0x0BFD
    32c6:	61 e1       	ldi	r22, 0x11	; 17
    32c8:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			SendWild(sAddr,SCMD_HEAD_OCCUPY);
    32cc:	80 91 fc 0b 	lds	r24, 0x0BFC
    32d0:	90 91 fd 0b 	lds	r25, 0x0BFD
    32d4:	68 e0       	ldi	r22, 0x08	; 8
    32d6:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		{
			FirstHeadFlag=0;
			goto start;
        }
		comPrintString("\r\n<<Broadcast head occupation...");
		for(i=0;i<New_Appling_Cover_Times;i++)
    32da:	0f 5f       	subi	r16, 0xFF	; 255
    32dc:	1f 4f       	sbci	r17, 0xFF	; 255
    32de:	0a 30       	cpi	r16, 0x0A	; 10
    32e0:	11 05       	cpc	r17, r1
    32e2:	19 f0       	breq	.+6      	; 0x32ea <main+0x6d0>
    32e4:	88 eb       	ldi	r24, 0xB8	; 184
    32e6:	9b e0       	ldi	r25, 0x0B	; 11
    32e8:	e5 cf       	rjmp	.-54     	; 0x32b4 <main+0x69a>
    32ea:	80 e3       	ldi	r24, 0x30	; 48
    32ec:	95 e7       	ldi	r25, 0x75	; 117
    32ee:	f5 01       	movw	r30, r10
    32f0:	31 97       	sbiw	r30, 0x01	; 1
    32f2:	f1 f7       	brne	.-4      	; 0x32f0 <main+0x6d6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    32f4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    32f6:	d9 f7       	brne	.-10     	; 0x32ee <main+0x6d4>
			delay_ms(TPU);
			SendWild(sAddr,SCMD_HEAD_FIRST_COME);
			SendWild(sAddr,SCMD_HEAD_OCCUPY);
	    }	
		delay_ms(First_Wait_time*TPU);
		SendWild(sAddr,SCMD_HEAD_FIRST_COME);
    32f8:	80 91 fc 0b 	lds	r24, 0x0BFC
    32fc:	90 91 fd 0b 	lds	r25, 0x0BFD
    3300:	61 e1       	ldi	r22, 0x11	; 17
    3302:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		receiveData();
    3306:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
	    if(FirstHeadFlag==1)
    330a:	80 91 52 0d 	lds	r24, 0x0D52
    330e:	88 23       	and	r24, r24
    3310:	19 f0       	breq	.+6      	; 0x3318 <main+0x6fe>
		{
			FirstHeadFlag=0;
    3312:	10 92 52 0d 	sts	0x0D52, r1
    3316:	a4 cc       	rjmp	.-1720   	; 0x2c60 <main+0x46>
			goto start;
        }
		if(HeadConfirmFlag==0)
    3318:	80 91 53 0d 	lds	r24, 0x0D53
    331c:	88 23       	and	r24, r24
    331e:	09 f4       	brne	.+2      	; 0x3322 <main+0x708>
    3320:	9f cc       	rjmp	.-1730   	; 0x2c60 <main+0x46>
		{
			goto start;
		}
        NewNodeFlag=0;
    3322:	10 92 4b 0d 	sts	0x0D4B, r1
		comPrintString("\r\nFinally I am the First Head~~~");
    3326:	81 ea       	ldi	r24, 0xA1	; 161
    3328:	9a e0       	ldi	r25, 0x0A	; 10
    332a:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    332e:	00 e0       	ldi	r16, 0x00	; 0
    3330:	10 e0       	ldi	r17, 0x00	; 0
    3332:	19 c0       	rjmp	.+50     	; 0x3366 <main+0x74c>
    3334:	f5 01       	movw	r30, r10
    3336:	31 97       	sbiw	r30, 0x01	; 1
    3338:	f1 f7       	brne	.-4      	; 0x3336 <main+0x71c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    333a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    333c:	d9 f7       	brne	.-10     	; 0x3334 <main+0x71a>
        for(i=0;i<Broad_Cover_Times;i++)
		{
			delay_ms(TPU);
			SendWild(sAddr,SCMD_HEAD_FIRST_COME);
    333e:	80 91 fc 0b 	lds	r24, 0x0BFC
    3342:	90 91 fd 0b 	lds	r25, 0x0BFD
    3346:	61 e1       	ldi	r22, 0x11	; 17
    3348:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
			SendWild(sAddr,SCMD_SADDR_BROADCAST);
    334c:	80 91 fc 0b 	lds	r24, 0x0BFC
    3350:	90 91 fd 0b 	lds	r25, 0x0BFD
    3354:	60 e0       	ldi	r22, 0x00	; 0
    3356:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		{
			goto start;
		}
        NewNodeFlag=0;
		comPrintString("\r\nFinally I am the First Head~~~");
        for(i=0;i<Broad_Cover_Times;i++)
    335a:	0f 5f       	subi	r16, 0xFF	; 255
    335c:	1f 4f       	sbci	r17, 0xFF	; 255
    335e:	04 31       	cpi	r16, 0x14	; 20
    3360:	11 05       	cpc	r17, r1
    3362:	09 f4       	brne	.+2      	; 0x3366 <main+0x74c>
    3364:	5f cf       	rjmp	.-322    	; 0x3224 <main+0x60a>
    3366:	88 eb       	ldi	r24, 0xB8	; 184
    3368:	9b e0       	ldi	r25, 0x0B	; 11
    336a:	e4 cf       	rjmp	.-56     	; 0x3334 <main+0x71a>
        }	
		rx_pool_init();
	}
	while (true)//主循环
	{
	    if(sleep_flag)
    336c:	80 91 25 0c 	lds	r24, 0x0C25
    3370:	88 23       	and	r24, r24
    3372:	a9 f0       	breq	.+42     	; 0x339e <main+0x784>
		{
			if(tat_enter_sleep_mode()==TAT_SUCCESS)
    3374:	0e 94 bb 07 	call	0xf76	; 0xf76 <tat_enter_sleep_mode>
    3378:	80 34       	cpi	r24, 0x40	; 64
    337a:	79 f4       	brne	.+30     	; 0x339a <main+0x780>
			{
				comPrintString("\r\n!!Enter sleep mode");
    337c:	82 ec       	ldi	r24, 0xC2	; 194
    337e:	9a e0       	ldi	r25, 0x0A	; 10
    3380:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				routine();
    3384:	0e 94 23 1c 	call	0x3846	; 0x3846 <routine>
    3388:	88 eb       	ldi	r24, 0xB8	; 184
    338a:	9b e0       	ldi	r25, 0x0B	; 11
    338c:	f5 01       	movw	r30, r10
    338e:	31 97       	sbiw	r30, 0x01	; 1
    3390:	f1 f7       	brne	.-4      	; 0x338e <main+0x774>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3392:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3394:	d9 f7       	brne	.-10     	; 0x338c <main+0x772>
				delay_ms(1*TPU);
				tat_leave_sleep_mode();
    3396:	0e 94 3d 07 	call	0xe7a	; 0xe7a <tat_leave_sleep_mode>
			}//睡眠8个TPU后唤醒
			trx_init( );
    339a:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <trx_init>
		}
		if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS) //转移状态机至RX_AACK_ON状态,以侦听传入包
    339e:	86 e1       	ldi	r24, 0x16	; 22
    33a0:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    33a4:	80 34       	cpi	r24, 0x40	; 64
    33a6:	31 f0       	breq	.+12     	; 0x33b4 <main+0x79a>
			com_send_string( debug_fatal_error, sizeof( debug_fatal_error ) );
    33a8:	8e ef       	ldi	r24, 0xFE	; 254
    33aa:	9b e0       	ldi	r25, 0x0B	; 11
    33ac:	67 e2       	ldi	r22, 0x27	; 39
    33ae:	0e 94 a0 00 	call	0x140	; 0x140 <com_send_string>
    33b2:	04 c0       	rjmp	.+8      	; 0x33bc <main+0x7a2>
		else
			comPrintString("\r\n!!Waked Up.");
    33b4:	87 ed       	ldi	r24, 0xD7	; 215
    33b6:	9a e0       	ldi	r25, 0x0A	; 10
    33b8:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		if(!sleep_flag)
    33bc:	80 91 25 0c 	lds	r24, 0x0C25
    33c0:	88 23       	and	r24, r24
    33c2:	51 f4       	brne	.+20     	; 0x33d8 <main+0x7be>
    33c4:	88 eb       	ldi	r24, 0xB8	; 184
    33c6:	9b e0       	ldi	r25, 0x0B	; 11
    33c8:	f5 01       	movw	r30, r10
    33ca:	31 97       	sbiw	r30, 0x01	; 1
    33cc:	f1 f7       	brne	.-4      	; 0x33ca <main+0x7b0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    33ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    33d0:	d9 f7       	brne	.-10     	; 0x33c8 <main+0x7ae>
		{
			delay_ms(1*TPU);
			sleep_flag=1;
    33d2:	81 e0       	ldi	r24, 0x01	; 1
    33d4:	80 93 25 0c 	sts	0x0C25, r24
		}
		comPrintString("\r\n!!Current short Address is:");
    33d8:	85 ee       	ldi	r24, 0xE5	; 229
    33da:	9a e0       	ldi	r25, 0x0A	; 10
    33dc:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_dec((sAddr>>8)&0xFF);
    33e0:	80 91 fd 0b 	lds	r24, 0x0BFD
    33e4:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		comPrintString(".");
    33e8:	8e ea       	ldi	r24, 0xAE	; 174
    33ea:	98 e0       	ldi	r25, 0x08	; 8
    33ec:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_dec(sAddr&0xFF);
    33f0:	80 91 fc 0b 	lds	r24, 0x0BFC
    33f4:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <com_send_dec>
		comPrintString("\r\n!!Net work NUM::::::::::");
    33f8:	83 e0       	ldi	r24, 0x03	; 3
    33fa:	9b e0       	ldi	r25, 0x0B	; 11
    33fc:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
		com_send_hex(Num);
    3400:	88 2d       	mov	r24, r8
    3402:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
		if(Num==5)
    3406:	85 e0       	ldi	r24, 0x05	; 5
    3408:	88 16       	cp	r8, r24
    340a:	91 04       	cpc	r9, r1
    340c:	09 f0       	breq	.+2      	; 0x3410 <main+0x7f6>
    340e:	8c c0       	rjmp	.+280    	; 0x3528 <main+0x90e>
}
bool networkStateTest()
{
    int i;
	bool networkOK=true;
	comPrintString("\r\n!!Now is testing time~~~~~~~~~~");
    3410:	8e e1       	ldi	r24, 0x1E	; 30
    3412:	9b e0       	ldi	r25, 0x0B	; 11
    3414:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	MaxNodeFlag=1;//是否应该把自己定为尾节点
    3418:	81 e0       	ldi	r24, 0x01	; 1
    341a:	80 93 8d 13 	sts	0x138D, r24
	GotoStartFlag=0;//是否需要重起
    341e:	10 92 54 0d 	sts	0x0D54, r1
	NetWorkFlag=0;//是否找到前驱节点
    3422:	10 92 55 0d 	sts	0x0D55, r1
	rx_pool_network_maintain_buf_head=0;
    3426:	10 92 56 0d 	sts	0x0D56, r1
	if(sAddr!=0x0000)
    342a:	80 91 fc 0b 	lds	r24, 0x0BFC
    342e:	90 91 fd 0b 	lds	r25, 0x0BFD
    3432:	89 2b       	or	r24, r25
    3434:	81 f1       	breq	.+96     	; 0x3496 <main+0x87c>
    3436:	00 e0       	ldi	r16, 0x00	; 0
    3438:	10 e0       	ldi	r17, 0x00	; 0
    343a:	20 c0       	rjmp	.+64     	; 0x347c <main+0x862>
    343c:	f5 01       	movw	r30, r10
    343e:	31 97       	sbiw	r30, 0x01	; 1
    3440:	f1 f7       	brne	.-4      	; 0x343e <main+0x824>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3442:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3444:	d9 f7       	brne	.-10     	; 0x343c <main+0x822>
	{
		for(i=0;i<=4;i++)
		{	
			delay_ms(8*TPU);
			SendWild(0xFFFF,SCMD_SADDR_BROADCAST);
    3446:	8f ef       	ldi	r24, 0xFF	; 255
    3448:	9f ef       	ldi	r25, 0xFF	; 255
    344a:	60 e0       	ldi	r22, 0x00	; 0
    344c:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
    3450:	80 e7       	ldi	r24, 0x70	; 112
    3452:	97 e1       	ldi	r25, 0x17	; 23
    3454:	f5 01       	movw	r30, r10
    3456:	31 97       	sbiw	r30, 0x01	; 1
    3458:	f1 f7       	brne	.-4      	; 0x3456 <main+0x83c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    345a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    345c:	d9 f7       	brne	.-10     	; 0x3454 <main+0x83a>
			delay_ms(2*TPU);
			receiveDatamaintain();
    345e:	0e 94 43 0b 	call	0x1686	; 0x1686 <receiveDatamaintain>
			if(GotoStartFlag)
    3462:	80 91 54 0d 	lds	r24, 0x0D54
    3466:	88 23       	and	r24, r24
    3468:	61 f4       	brne	.+24     	; 0x3482 <main+0x868>
				break;
			if(NetWorkFlag)
    346a:	80 91 55 0d 	lds	r24, 0x0D55
    346e:	88 23       	and	r24, r24
    3470:	41 f4       	brne	.+16     	; 0x3482 <main+0x868>
	GotoStartFlag=0;//是否需要重起
	NetWorkFlag=0;//是否找到前驱节点
	rx_pool_network_maintain_buf_head=0;
	if(sAddr!=0x0000)
	{
		for(i=0;i<=4;i++)
    3472:	0f 5f       	subi	r16, 0xFF	; 255
    3474:	1f 4f       	sbci	r17, 0xFF	; 255
    3476:	05 30       	cpi	r16, 0x05	; 5
    3478:	11 05       	cpc	r17, r1
    347a:	19 f0       	breq	.+6      	; 0x3482 <main+0x868>
    347c:	80 ec       	ldi	r24, 0xC0	; 192
    347e:	9d e5       	ldi	r25, 0x5D	; 93
    3480:	dd cf       	rjmp	.-70     	; 0x343c <main+0x822>
			if(GotoStartFlag)
				break;
			if(NetWorkFlag)
				break;       
		}
		if(NetWorkFlag==0)
    3482:	80 91 55 0d 	lds	r24, 0x0D55
    3486:	88 23       	and	r24, r24
    3488:	31 f4       	brne	.+12     	; 0x3496 <main+0x87c>
		{
	     	comPrintString("\r\n!!My parant Lost~~~~~~~~~~~~");
    348a:	80 e4       	ldi	r24, 0x40	; 64
    348c:	9b e0       	ldi	r25, 0x0B	; 11
    348e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    3492:	90 e0       	ldi	r25, 0x00	; 0
    3494:	39 c0       	rjmp	.+114    	; 0x3508 <main+0x8ee>
    3496:	00 e0       	ldi	r16, 0x00	; 0
    3498:	10 e0       	ldi	r17, 0x00	; 0
    349a:	20 c0       	rjmp	.+64     	; 0x34dc <main+0x8c2>
    349c:	f5 01       	movw	r30, r10
    349e:	31 97       	sbiw	r30, 0x01	; 1
    34a0:	f1 f7       	brne	.-4      	; 0x349e <main+0x884>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34a4:	d9 f7       	brne	.-10     	; 0x349c <main+0x882>
	if(networkOK)
	{
		for(i=0;i<=4;i++)
		{	
			delay_ms(8*TPU);
			SendWild(0xFFFF,SCMD_SADDR_BROADCAST);
    34a6:	8f ef       	ldi	r24, 0xFF	; 255
    34a8:	9f ef       	ldi	r25, 0xFF	; 255
    34aa:	60 e0       	ldi	r22, 0x00	; 0
    34ac:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
    34b0:	80 e7       	ldi	r24, 0x70	; 112
    34b2:	97 e1       	ldi	r25, 0x17	; 23
    34b4:	f5 01       	movw	r30, r10
    34b6:	31 97       	sbiw	r30, 0x01	; 1
    34b8:	f1 f7       	brne	.-4      	; 0x34b6 <main+0x89c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34bc:	d9 f7       	brne	.-10     	; 0x34b4 <main+0x89a>
			delay_ms(2*TPU);
			receiveDatamaintain();
    34be:	0e 94 43 0b 	call	0x1686	; 0x1686 <receiveDatamaintain>
			if(GotoStartFlag)
    34c2:	80 91 54 0d 	lds	r24, 0x0D54
    34c6:	88 23       	and	r24, r24
    34c8:	61 f4       	brne	.+24     	; 0x34e2 <main+0x8c8>
				break;
			if(MaxNodeFlag==0x00)
    34ca:	80 91 8d 13 	lds	r24, 0x138D
    34ce:	88 23       	and	r24, r24
    34d0:	41 f0       	breq	.+16     	; 0x34e2 <main+0x8c8>
			networkOK=false;
		}
	}
	if(networkOK)
	{
		for(i=0;i<=4;i++)
    34d2:	0f 5f       	subi	r16, 0xFF	; 255
    34d4:	1f 4f       	sbci	r17, 0xFF	; 255
    34d6:	05 30       	cpi	r16, 0x05	; 5
    34d8:	11 05       	cpc	r17, r1
    34da:	19 f0       	breq	.+6      	; 0x34e2 <main+0x8c8>
    34dc:	80 ec       	ldi	r24, 0xC0	; 192
    34de:	9d e5       	ldi	r25, 0x5D	; 93
    34e0:	dd cf       	rjmp	.-70     	; 0x349c <main+0x882>
			if(GotoStartFlag)
				break;
			if(MaxNodeFlag==0x00)
				break;    
		}
		if(MaxNodeFlag==0x01)
    34e2:	80 91 8d 13 	lds	r24, 0x138D
    34e6:	88 23       	and	r24, r24
    34e8:	71 f0       	breq	.+28     	; 0x3506 <main+0x8ec>
		{
	     	attri=0x01;
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	80 93 4c 0d 	sts	0x0D4C, r24
			comPrintString("\r\n!!I am the New Tail~~~~~~~~~~~");
    34f0:	8f e5       	ldi	r24, 0x5F	; 95
    34f2:	9b e0       	ldi	r25, 0x0B	; 11
    34f4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
			SendWild(sAddr,SCMD_SADDR_BROADCAST);
    34f8:	80 91 fc 0b 	lds	r24, 0x0BFC
    34fc:	90 91 fd 0b 	lds	r25, 0x0BFD
    3500:	60 e0       	ldi	r22, 0x00	; 0
    3502:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
    3506:	91 e0       	ldi	r25, 0x01	; 1
		}
	}
	if(GotoStartFlag!=0x00)
    3508:	80 91 54 0d 	lds	r24, 0x0D54
    350c:	88 23       	and	r24, r24
    350e:	39 f0       	breq	.+14     	; 0x351e <main+0x904>
	{
		GotoStartFlag=0;
    3510:	10 92 54 0d 	sts	0x0D54, r1
		comPrintString("\r\n!!Net work has sth wrong I have to go to start~~~~~~~~~~");
    3514:	80 e8       	ldi	r24, 0x80	; 128
    3516:	9b e0       	ldi	r25, 0x0B	; 11
    3518:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    351c:	a1 cb       	rjmp	.-2238   	; 0x2c60 <main+0x46>
		comPrintString("\r\n!!Net work NUM::::::::::");
		com_send_hex(Num);
		if(Num==5)
		{
			Num=0;
	    	if(!networkStateTest())
    351e:	99 23       	and	r25, r25
    3520:	09 f4       	brne	.+2      	; 0x3524 <main+0x90a>
    3522:	9e cb       	rjmp	.-2244   	; 0x2c60 <main+0x46>
				goto start;
    3524:	88 24       	eor	r8, r8
    3526:	99 24       	eor	r9, r9
    3528:	88 e7       	ldi	r24, 0x78	; 120
    352a:	99 e6       	ldi	r25, 0x69	; 105
    352c:	f5 01       	movw	r30, r10
    352e:	31 97       	sbiw	r30, 0x01	; 1
    3530:	f1 f7       	brne	.-4      	; 0x352e <main+0x914>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3532:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3534:	d9 f7       	brne	.-10     	; 0x352c <main+0x912>
}
void sendPrep()
{
	int i,j;
	int k=0;
	BusyTxSending=1;
    3536:	41 e0       	ldi	r20, 0x01	; 1
    3538:	40 93 57 0d 	sts	0x0D57, r20
	if(dataSendBufferHead>0)
    353c:	80 91 58 0d 	lds	r24, 0x0D58
    3540:	90 91 59 0d 	lds	r25, 0x0D59
    3544:	18 16       	cp	r1, r24
    3546:	19 06       	cpc	r1, r25
    3548:	0c f0       	brlt	.+2      	; 0x354c <main+0x932>
    354a:	4e c1       	rjmp	.+668    	; 0x37e8 <main+0xbce>
	{
		dataSendBufferHead--;
    354c:	01 97       	sbiw	r24, 0x01	; 1
    354e:	90 93 59 0d 	sts	0x0D59, r25
    3552:	80 93 58 0d 	sts	0x0D58, r24
		if((dataSendBuffer[dataSendBufferHead].dAddr[0]+dataSendBuffer[dataSendBufferHead].dAddr[1]*256)==sAddr)
    3556:	fc 01       	movw	r30, r24
    3558:	33 e0       	ldi	r19, 0x03	; 3
    355a:	ee 0f       	add	r30, r30
    355c:	ff 1f       	adc	r31, r31
    355e:	3a 95       	dec	r19
    3560:	e1 f7       	brne	.-8      	; 0x355a <main+0x940>
    3562:	e8 1b       	sub	r30, r24
    3564:	f9 0b       	sbc	r31, r25
    3566:	e0 5a       	subi	r30, 0xA0	; 160
    3568:	f2 4f       	sbci	r31, 0xF2	; 242
    356a:	51 81       	ldd	r21, Z+1	; 0x01
    356c:	55 2e       	mov	r5, r21
    356e:	44 24       	eor	r4, r4
    3570:	e0 81       	ld	r30, Z
    3572:	92 01       	movw	r18, r4
    3574:	2e 0f       	add	r18, r30
    3576:	31 1d       	adc	r19, r1
    3578:	80 91 fc 0b 	lds	r24, 0x0BFC
    357c:	90 91 fd 0b 	lds	r25, 0x0BFD
    3580:	28 17       	cp	r18, r24
    3582:	39 07       	cpc	r19, r25
    3584:	81 f4       	brne	.+32     	; 0x35a6 <main+0x98c>
    3586:	88 ee       	ldi	r24, 0xE8	; 232
    3588:	93 e0       	ldi	r25, 0x03	; 3
    358a:	f5 01       	movw	r30, r10
    358c:	31 97       	sbiw	r30, 0x01	; 1
    358e:	f1 f7       	brne	.-4      	; 0x358c <main+0x972>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3590:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3592:	d9 f7       	brne	.-10     	; 0x358a <main+0x970>
		{
			delay_ms(100);
			comPrintString("amazing within Prep~~~~");
    3594:	8b eb       	ldi	r24, 0xBB	; 187
    3596:	9b e0       	ldi	r25, 0x0B	; 11
    3598:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
	   comPrintString("\r\n!!State Change Failed");
    rx_flag = true; // Set the flag back again. Only used to protec t
}
void download()
{
	comPrintString("\r\n>>yangjieshahuhu!");
    359c:	84 e3       	ldi	r24, 0x34	; 52
    359e:	97 e0       	ldi	r25, 0x07	; 7
    35a0:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    35a4:	21 c1       	rjmp	.+578    	; 0x37e8 <main+0xbce>
			comPrintString("amazing within Prep~~~~");
			download();
		}
		else
		{
			PrepAckFlag=1;
    35a6:	40 93 5a 0d 	sts	0x0D5A, r20
			tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
    35aa:	81 e6       	ldi	r24, 0x61	; 97
    35ac:	80 93 d0 0d 	sts	0x0DD0, r24
			tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
    35b0:	88 e8       	ldi	r24, 0x88	; 136
    35b2:	80 93 d1 0d 	sts	0x0DD1, r24
			tx_frame[2]= 0; //封包序列号
    35b6:	10 92 d2 0d 	sts	0x0DD2, r1
			tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
    35ba:	8c ec       	ldi	r24, 0xCC	; 204
    35bc:	80 93 d3 0d 	sts	0x0DD3, r24
			tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
    35c0:	8e ee       	ldi	r24, 0xEE	; 238
    35c2:	80 93 d4 0d 	sts	0x0DD4, r24
			tx_frame[5] = 0xFF; //目标短地址低8位.
    35c6:	9f ef       	ldi	r25, 0xFF	; 255
    35c8:	90 93 d5 0d 	sts	0x0DD5, r25
			tx_frame[6] = 0xFF; //目标短地址高8位
    35cc:	90 93 d6 0d 	sts	0x0DD6, r25
			tx_frame[7] = sAddr & 0xFF; //发送源短地址低8位
    35d0:	80 91 fc 0b 	lds	r24, 0x0BFC
    35d4:	80 93 d7 0d 	sts	0x0DD7, r24
			tx_frame[8] = (sAddr>>8)& 0xFF;//发送源短地址高8位
    35d8:	80 91 fd 0b 	lds	r24, 0x0BFD
    35dc:	80 93 d8 0d 	sts	0x0DD8, r24
			tx_frame[9] =0xFF;		   
    35e0:	90 93 d9 0d 	sts	0x0DD9, r25
			tx_frame[10]=0xFF;
    35e4:	90 93 da 0d 	sts	0x0DDA, r25
			tx_frame[11]=SCMD_PREP;
    35e8:	40 93 db 0d 	sts	0x0DDB, r20
			tx_frame[12]=dataSendBuffer[dataSendBufferHead].dAddr[0];
    35ec:	e0 93 dc 0d 	sts	0x0DDC, r30
			tx_frame[13]=dataSendBuffer[dataSendBufferHead].dAddr[1];
    35f0:	50 93 dd 0d 	sts	0x0DDD, r21
    35f4:	ee 24       	eor	r14, r14
    35f6:	ff 24       	eor	r15, r15
				}
				else 
					comPrintString("\r\n!!State Change Failed");
				if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
					comPrintString("\r\n!!State Change Failed");
				rx_flag = true;
    35f8:	dd 24       	eor	r13, r13
    35fa:	d3 94       	inc	r13
			tx_frame[11]=SCMD_PREP;
			tx_frame[12]=dataSendBuffer[dataSendBufferHead].dAddr[0];
			tx_frame[13]=dataSendBuffer[dataSendBufferHead].dAddr[1];
			for(i=0;i<3;i++)
			{
				comPrintString("\r\n<<Sending Prep...");
    35fc:	83 ed       	ldi	r24, 0xD3	; 211
    35fe:	9b e0       	ldi	r25, 0x0B	; 11
    3600:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
    3604:	89 e0       	ldi	r24, 0x09	; 9
    3606:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    360a:	80 34       	cpi	r24, 0x40	; 64
    360c:	f9 f4       	brne	.+62     	; 0x364c <main+0xa32>
				{
					rx_flag = false;
    360e:	10 92 52 0e 	sts	0x0E52, r1
					tat_send_data( 16, tx_frame);
    3612:	80 e1       	ldi	r24, 0x10	; 16
    3614:	60 ed       	ldi	r22, 0xD0	; 208
    3616:	7d e0       	ldi	r23, 0x0D	; 13
    3618:	0e 94 20 07 	call	0xe40	; 0xe40 <tat_send_data>
					comPrintString("\r\n<<");
    361c:	8e e2       	ldi	r24, 0x2E	; 46
    361e:	92 e0       	ldi	r25, 0x02	; 2
    3620:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    3624:	00 ed       	ldi	r16, 0xD0	; 208
    3626:	1d e0       	ldi	r17, 0x0D	; 13
					for(j=0;j<=13;j++)
					{
						com_send_hex(tx_frame[j]);
    3628:	f8 01       	movw	r30, r16
    362a:	81 91       	ld	r24, Z+
    362c:	8f 01       	movw	r16, r30
    362e:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
						comPrintString(" ");
    3632:	83 e3       	ldi	r24, 0x33	; 51
    3634:	92 e0       	ldi	r25, 0x02	; 2
    3636:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
				{
					rx_flag = false;
					tat_send_data( 16, tx_frame);
					comPrintString("\r\n<<");
					for(j=0;j<=13;j++)
    363a:	fd e0       	ldi	r31, 0x0D	; 13
    363c:	0e 3d       	cpi	r16, 0xDE	; 222
    363e:	1f 07       	cpc	r17, r31
    3640:	99 f7       	brne	.-26     	; 0x3628 <main+0xa0e>
    3642:	80 e0       	ldi	r24, 0x00	; 0
    3644:	90 e9       	ldi	r25, 0x90	; 144
    3646:	01 97       	sbiw	r24, 0x01	; 1
    3648:	f1 f7       	brne	.-4      	; 0x3646 <main+0xa2c>
    364a:	04 c0       	rjmp	.+8      	; 0x3654 <main+0xa3a>
						comPrintString(" ");
					}
					delay_ms(20);//状态转换时间
				}
				else 
					comPrintString("\r\n!!State Change Failed");
    364c:	85 e4       	ldi	r24, 0x45	; 69
    364e:	92 e0       	ldi	r25, 0x02	; 2
    3650:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    3654:	86 e1       	ldi	r24, 0x16	; 22
    3656:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    365a:	80 34       	cpi	r24, 0x40	; 64
    365c:	21 f0       	breq	.+8      	; 0x3666 <main+0xa4c>
					comPrintString("\r\n!!State Change Failed");
    365e:	85 e4       	ldi	r24, 0x45	; 69
    3660:	92 e0       	ldi	r25, 0x02	; 2
    3662:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				rx_flag = true;
    3666:	d0 92 52 0e 	sts	0x0E52, r13
    366a:	8c e6       	ldi	r24, 0x6C	; 108
    366c:	97 e0       	ldi	r25, 0x07	; 7
    366e:	f5 01       	movw	r30, r10
    3670:	31 97       	sbiw	r30, 0x01	; 1
    3672:	f1 f7       	brne	.-4      	; 0x3670 <main+0xa56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3674:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3676:	d9 f7       	brne	.-10     	; 0x366e <main+0xa54>
			tx_frame[9] =0xFF;		   
			tx_frame[10]=0xFF;
			tx_frame[11]=SCMD_PREP;
			tx_frame[12]=dataSendBuffer[dataSendBufferHead].dAddr[0];
			tx_frame[13]=dataSendBuffer[dataSendBufferHead].dAddr[1];
			for(i=0;i<3;i++)
    3678:	08 94       	sec
    367a:	e1 1c       	adc	r14, r1
    367c:	f1 1c       	adc	r15, r1
    367e:	83 e0       	ldi	r24, 0x03	; 3
    3680:	e8 16       	cp	r14, r24
    3682:	f1 04       	cpc	r15, r1
    3684:	09 f0       	breq	.+2      	; 0x3688 <main+0xa6e>
    3686:	ba cf       	rjmp	.-140    	; 0x35fc <main+0x9e2>
				if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
					comPrintString("\r\n!!State Change Failed");
				rx_flag = true;
				delay_ms(2*TPU/3-10);
			}
			sleep_flag=0;
    3688:	10 92 25 0c 	sts	0x0C25, r1
    368c:	80 e7       	ldi	r24, 0x70	; 112
    368e:	97 e1       	ldi	r25, 0x17	; 23
    3690:	f5 01       	movw	r30, r10
    3692:	31 97       	sbiw	r30, 0x01	; 1
    3694:	f1 f7       	brne	.-4      	; 0x3692 <main+0xa78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3696:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3698:	d9 f7       	brne	.-10     	; 0x3690 <main+0xa76>
			delay_ms(2*TPU);
			receiveDataPrep();
    369a:	0e 94 23 11 	call	0x2246	; 0x2246 <receiveDataPrep>
    369e:	dd 24       	eor	r13, r13
    36a0:	d3 94       	inc	r13
				 	tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
					tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
					tx_frame[2]= 0; //封包序列号
					tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
					tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
					tx_frame[5] = 0xFF; //目标短地址低8位.
    36a2:	cc 24       	eor	r12, r12
    36a4:	ca 94       	dec	r12
    36a6:	9b c0       	rjmp	.+310    	; 0x37de <main+0xbc4>
			sleep_flag=0;
			delay_ms(2*TPU);
			receiveDataPrep();
			while(PrepAckFlag)
			{
				 comPrintString("\r\n!!retry times:::::");
    36a8:	87 ee       	ldi	r24, 0xE7	; 231
    36aa:	9b e0       	ldi	r25, 0x0B	; 11
    36ac:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
				 k++;
				 com_send_hex(k);
    36b0:	8d 2d       	mov	r24, r13
    36b2:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
				 com_send_hex(k);
    36b6:	8d 2d       	mov	r24, r13
    36b8:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
				 if(k<=25)
    36bc:	9a e1       	ldi	r25, 0x1A	; 26
    36be:	d9 16       	cp	r13, r25
    36c0:	09 f4       	brne	.+2      	; 0x36c4 <main+0xaaa>
    36c2:	92 c0       	rjmp	.+292    	; 0x37e8 <main+0xbce>
				 {
				 	tx_frame[0] = 0x61; //IEEE 802.15.4的标准包头帧
    36c4:	e1 e6       	ldi	r30, 0x61	; 97
    36c6:	e0 93 d0 0d 	sts	0x0DD0, r30
					tx_frame[1] = 0x88; //IEEE 802.15.4的标准包头帧
    36ca:	f8 e8       	ldi	r31, 0x88	; 136
    36cc:	f0 93 d1 0d 	sts	0x0DD1, r31
					tx_frame[2]= 0; //封包序列号
    36d0:	10 92 d2 0d 	sts	0x0DD2, r1
					tx_frame[3] = PAN_ID & 0xFF; //网络地址低8位
    36d4:	8c ec       	ldi	r24, 0xCC	; 204
    36d6:	80 93 d3 0d 	sts	0x0DD3, r24
					tx_frame[4] = (PAN_ID >> 8 ) & 0xFF; //网络地址高8位
    36da:	9e ee       	ldi	r25, 0xEE	; 238
    36dc:	90 93 d4 0d 	sts	0x0DD4, r25
					tx_frame[5] = 0xFF; //目标短地址低8位.
    36e0:	c0 92 d5 0d 	sts	0x0DD5, r12
					tx_frame[6] = 0xFF; //目标短地址高8位
    36e4:	c0 92 d6 0d 	sts	0x0DD6, r12
					tx_frame[7] = sAddr & 0xFF; //发送源短地址低8位
    36e8:	80 91 fc 0b 	lds	r24, 0x0BFC
    36ec:	80 93 d7 0d 	sts	0x0DD7, r24
					tx_frame[8] = (sAddr>>8)& 0xFF;//发送源短地址高8位
    36f0:	80 91 fd 0b 	lds	r24, 0x0BFD
    36f4:	80 93 d8 0d 	sts	0x0DD8, r24
					tx_frame[9] =0xFF;		   
    36f8:	c0 92 d9 0d 	sts	0x0DD9, r12
					tx_frame[10]=0xFF;
    36fc:	c0 92 da 0d 	sts	0x0DDA, r12
					tx_frame[11]=SCMD_PREP;
    3700:	e1 e0       	ldi	r30, 0x01	; 1
    3702:	e0 93 db 0d 	sts	0x0DDB, r30
					tx_frame[12]=dataSendBuffer[dataSendBufferHead].dAddr[0];
    3706:	80 91 58 0d 	lds	r24, 0x0D58
    370a:	90 91 59 0d 	lds	r25, 0x0D59
    370e:	fc 01       	movw	r30, r24
    3710:	23 e0       	ldi	r18, 0x03	; 3
    3712:	ee 0f       	add	r30, r30
    3714:	ff 1f       	adc	r31, r31
    3716:	2a 95       	dec	r18
    3718:	e1 f7       	brne	.-8      	; 0x3712 <main+0xaf8>
    371a:	e8 1b       	sub	r30, r24
    371c:	f9 0b       	sbc	r31, r25
    371e:	e0 5a       	subi	r30, 0xA0	; 160
    3720:	f2 4f       	sbci	r31, 0xF2	; 242
    3722:	80 81       	ld	r24, Z
    3724:	80 93 dc 0d 	sts	0x0DDC, r24
					tx_frame[13]=dataSendBuffer[dataSendBufferHead].dAddr[1];
    3728:	81 81       	ldd	r24, Z+1	; 0x01
    372a:	80 93 dd 0d 	sts	0x0DDD, r24
    372e:	ee 24       	eor	r14, r14
    3730:	ff 24       	eor	r15, r15
					for(i=0;i<3;i++)
					{
						comPrintString("\r\n<<Sending Prep...");
    3732:	83 ed       	ldi	r24, 0xD3	; 211
    3734:	9b e0       	ldi	r25, 0x0B	; 11
    3736:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
    373a:	89 e0       	ldi	r24, 0x09	; 9
    373c:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    3740:	80 34       	cpi	r24, 0x40	; 64
    3742:	f9 f4       	brne	.+62     	; 0x3782 <main+0xb68>
						{
							rx_flag = false;
    3744:	10 92 52 0e 	sts	0x0E52, r1
							tat_send_data( 16, tx_frame);
    3748:	80 e1       	ldi	r24, 0x10	; 16
    374a:	60 ed       	ldi	r22, 0xD0	; 208
    374c:	7d e0       	ldi	r23, 0x0D	; 13
    374e:	0e 94 20 07 	call	0xe40	; 0xe40 <tat_send_data>
							comPrintString("\r\n<<");
    3752:	8e e2       	ldi	r24, 0x2E	; 46
    3754:	92 e0       	ldi	r25, 0x02	; 2
    3756:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    375a:	00 ed       	ldi	r16, 0xD0	; 208
    375c:	1d e0       	ldi	r17, 0x0D	; 13
							for(j=0;j<=13;j++)
							{
								com_send_hex(tx_frame[j]);
    375e:	f8 01       	movw	r30, r16
    3760:	81 91       	ld	r24, Z+
    3762:	8f 01       	movw	r16, r30
    3764:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
								comPrintString(" ");
    3768:	83 e3       	ldi	r24, 0x33	; 51
    376a:	92 e0       	ldi	r25, 0x02	; 2
    376c:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						if (set_trx_state( PLL_ON ) == TAT_SUCCESS) 
						{
							rx_flag = false;
							tat_send_data( 16, tx_frame);
							comPrintString("\r\n<<");
							for(j=0;j<=13;j++)
    3770:	fd e0       	ldi	r31, 0x0D	; 13
    3772:	0e 3d       	cpi	r16, 0xDE	; 222
    3774:	1f 07       	cpc	r17, r31
    3776:	99 f7       	brne	.-26     	; 0x375e <main+0xb44>
    3778:	80 e0       	ldi	r24, 0x00	; 0
    377a:	90 e9       	ldi	r25, 0x90	; 144
    377c:	01 97       	sbiw	r24, 0x01	; 1
    377e:	f1 f7       	brne	.-4      	; 0x377c <main+0xb62>
    3780:	04 c0       	rjmp	.+8      	; 0x378a <main+0xb70>
								comPrintString(" ");
							}
							delay_ms(20);//状态转换时间
						}
						else 
							comPrintString("\r\n!!State Change Failed");
    3782:	85 e4       	ldi	r24, 0x45	; 69
    3784:	92 e0       	ldi	r25, 0x02	; 2
    3786:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						if (set_trx_state( RX_AACK_ON ) != TAT_SUCCESS)  //转移状态机至RX_AACK_ON状态,以侦听传入包
    378a:	86 e1       	ldi	r24, 0x16	; 22
    378c:	0e 94 cd 07 	call	0xf9a	; 0xf9a <set_trx_state>
    3790:	80 34       	cpi	r24, 0x40	; 64
    3792:	21 f0       	breq	.+8      	; 0x379c <main+0xb82>
							comPrintString("\r\n!!State Change Failed");
    3794:	85 e4       	ldi	r24, 0x45	; 69
    3796:	92 e0       	ldi	r25, 0x02	; 2
    3798:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
						rx_flag = true;
    379c:	81 e0       	ldi	r24, 0x01	; 1
    379e:	80 93 52 0e 	sts	0x0E52, r24
    37a2:	8c e6       	ldi	r24, 0x6C	; 108
    37a4:	97 e0       	ldi	r25, 0x07	; 7
    37a6:	f5 01       	movw	r30, r10
    37a8:	31 97       	sbiw	r30, 0x01	; 1
    37aa:	f1 f7       	brne	.-4      	; 0x37a8 <main+0xb8e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37ac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37ae:	d9 f7       	brne	.-10     	; 0x37a6 <main+0xb8c>
					tx_frame[9] =0xFF;		   
					tx_frame[10]=0xFF;
					tx_frame[11]=SCMD_PREP;
					tx_frame[12]=dataSendBuffer[dataSendBufferHead].dAddr[0];
					tx_frame[13]=dataSendBuffer[dataSendBufferHead].dAddr[1];
					for(i=0;i<3;i++)
    37b0:	08 94       	sec
    37b2:	e1 1c       	adc	r14, r1
    37b4:	f1 1c       	adc	r15, r1
    37b6:	93 e0       	ldi	r25, 0x03	; 3
    37b8:	e9 16       	cp	r14, r25
    37ba:	f1 04       	cpc	r15, r1
    37bc:	09 f0       	breq	.+2      	; 0x37c0 <main+0xba6>
    37be:	b9 cf       	rjmp	.-142    	; 0x3732 <main+0xb18>
    37c0:	80 e7       	ldi	r24, 0x70	; 112
    37c2:	97 e1       	ldi	r25, 0x17	; 23
    37c4:	f5 01       	movw	r30, r10
    37c6:	31 97       	sbiw	r30, 0x01	; 1
    37c8:	f1 f7       	brne	.-4      	; 0x37c6 <main+0xbac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    37ca:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37cc:	d9 f7       	brne	.-10     	; 0x37c4 <main+0xbaa>
							comPrintString("\r\n!!State Change Failed");
						rx_flag = true;
						delay_ms(2*TPU/3-10);
					}
					delay_ms(2*TPU);
					receiveDataPrep();
    37ce:	0e 94 23 11 	call	0x2246	; 0x2246 <receiveDataPrep>
					SendWild(0xFFFF,SCMD_SADDR_BROADCAST);
    37d2:	8f ef       	ldi	r24, 0xFF	; 255
    37d4:	9f ef       	ldi	r25, 0xFF	; 255
    37d6:	60 e0       	ldi	r22, 0x00	; 0
    37d8:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
    37dc:	d3 94       	inc	r13
				delay_ms(2*TPU/3-10);
			}
			sleep_flag=0;
			delay_ms(2*TPU);
			receiveDataPrep();
			while(PrepAckFlag)
    37de:	80 91 5a 0d 	lds	r24, 0x0D5A
    37e2:	88 23       	and	r24, r24
    37e4:	09 f0       	breq	.+2      	; 0x37e8 <main+0xbce>
    37e6:	60 cf       	rjmp	.-320    	; 0x36a8 <main+0xa8e>
		{
			Num=0;
	    	if(!networkStateTest())
				goto start;
		}
		Num++;
    37e8:	08 94       	sec
    37ea:	81 1c       	adc	r8, r1
    37ec:	91 1c       	adc	r9, r1
	             if(k>25)
				 	break;
			}
		}
	}
    BusyTxSending=0;
    37ee:	10 92 57 0d 	sts	0x0D57, r1
		Num++;
		/*------处理发送池的信息------*/
		/*------处理接收到的信息------*/
		delay_ms(9*TPU);
		sendPrep();
		receiveData();
    37f2:	0e 94 93 0c 	call	0x1926	; 0x1926 <receiveData>
		receiveDataPrep();
    37f6:	0e 94 23 11 	call	0x2246	; 0x2246 <receiveDataPrep>
		receiveDatamaintain();	
    37fa:	0e 94 43 0b 	call	0x1686	; 0x1686 <receiveDatamaintain>
	
		hal_set_data_led();//亮灯,表示发送数据
    37fe:	2e 98       	cbi	0x05, 6	; 5
		SendWild(0xFFFF,SCMD_SADDR_BROADCAST);
    3800:	8f ef       	ldi	r24, 0xFF	; 255
    3802:	9f ef       	ldi	r25, 0xFF	; 255
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	0e 94 25 0c 	call	0x184a	; 0x184a <SendWild>
		com_reset_receiver();
    380a:	0e 94 2d 01 	call	0x25a	; 0x25a <com_reset_receiver>
		cli();
    380e:	f8 94       	cli
}
/*! \brief 初始化接收池
 */
void rx_pool_init( void )
{
    rx_pool_start = rx_pool;
    3810:	70 92 ac 10 	sts	0x10AC, r7
    3814:	60 92 ab 10 	sts	0x10AB, r6
	rx_pool_end = &rx_pool[ RX_POOL_SIZE - 1 ];
    3818:	e7 e9       	ldi	r30, 0x97	; 151
    381a:	f0 e1       	ldi	r31, 0x10	; 16
    381c:	f0 93 ae 10 	sts	0x10AE, r31
    3820:	e0 93 ad 10 	sts	0x10AD, r30
    rx_pool_head = rx_pool_start;
    3824:	70 92 b0 10 	sts	0x10B0, r7
    3828:	60 92 af 10 	sts	0x10AF, r6
	rx_pool_tail = rx_pool_end;
    382c:	f0 93 b2 10 	sts	0x10B2, r31
    3830:	e0 93 b1 10 	sts	0x10B1, r30
	rx_pool_items_free = RX_POOL_SIZE;
    3834:	8e e1       	ldi	r24, 0x1E	; 30
    3836:	80 93 4f 0e 	sts	0x0E4F, r24
	rx_pool_items_used = 0;
    383a:	10 92 50 0e 	sts	0x0E50, r1
    rx_pool_overflow_flag = false;
    383e:	10 92 51 0e 	sts	0x0E51, r1
		hal_set_data_led();//亮灯,表示发送数据
		SendWild(0xFFFF,SCMD_SADDR_BROADCAST);
		com_reset_receiver();
		cli();
		rx_pool_init( );
		sei();
    3842:	78 94       	sei
    3844:	93 cd       	rjmp	.-1242   	; 0x336c <main+0x752>

00003846 <routine>:
 * 每次设备达到固定的唤醒次数时会执行此函数
 * 
 * 
 */
void routine(void)
{
    3846:	0f 93       	push	r16
    3848:	1f 93       	push	r17
    384a:	df 93       	push	r29
    384c:	cf 93       	push	r28
    384e:	00 d0       	rcall	.+0      	; 0x3850 <routine+0xa>
    3850:	00 d0       	rcall	.+0      	; 0x3852 <routine+0xc>
    3852:	0f 92       	push	r0
    3854:	cd b7       	in	r28, 0x3d	; 61
    3856:	de b7       	in	r29, 0x3e	; 62
	uint8_t data[5]={0xAB,0xCD,0xEF,0xAA,0xAA};
    3858:	de 01       	movw	r26, r28
    385a:	11 96       	adiw	r26, 0x01	; 1
    385c:	eb e8       	ldi	r30, 0x8B	; 139
    385e:	fc e0       	ldi	r31, 0x0C	; 12
    3860:	85 e0       	ldi	r24, 0x05	; 5
    3862:	01 90       	ld	r0, Z+
    3864:	0d 92       	st	X+, r0
    3866:	81 50       	subi	r24, 0x01	; 1
    3868:	e1 f7       	brne	.-8      	; 0x3862 <routine+0x1c>
		}
		m=0;
	}*/
	int i;
	//com_get_received_data();
    comPrintString("\r\nPlease enter:::::::");
    386a:	8c e5       	ldi	r24, 0x5C	; 92
    386c:	9c e0       	ldi	r25, 0x0C	; 12
    386e:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    3872:	80 e2       	ldi	r24, 0x20	; 32
    3874:	9e e4       	ldi	r25, 0x4E	; 78
    3876:	28 eb       	ldi	r18, 0xB8	; 184
    3878:	30 e0       	ldi	r19, 0x00	; 0
    387a:	f9 01       	movw	r30, r18
    387c:	31 97       	sbiw	r30, 0x01	; 1
    387e:	f1 f7       	brne	.-4      	; 0x387c <routine+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3880:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3882:	d9 f7       	brne	.-10     	; 0x387a <routine+0x34>
	delay_ms(2000);
	com_get_received_data_use(com_buffer_use);
    3884:	8e e8       	ldi	r24, 0x8E	; 142
    3886:	93 e1       	ldi	r25, 0x13	; 19
    3888:	0e 94 15 01 	call	0x22a	; 0x22a <com_get_received_data_use>
    388c:	20 e0       	ldi	r18, 0x00	; 0
    388e:	30 e0       	ldi	r19, 0x00	; 0
	for(i=0;i<=20;i++)
	{
	com_buffer_useful[i]=com_buffer_use[i]-48;
    3890:	f9 01       	movw	r30, r18
    3892:	eb 5f       	subi	r30, 0xFB	; 251
    3894:	fb 4e       	sbci	r31, 0xEB	; 235
    3896:	d9 01       	movw	r26, r18
    3898:	a2 57       	subi	r26, 0x72	; 114
    389a:	bc 4e       	sbci	r27, 0xEC	; 236
    389c:	8c 91       	ld	r24, X
    389e:	80 53       	subi	r24, 0x30	; 48
    38a0:	80 83       	st	Z, r24
	int i;
	//com_get_received_data();
    comPrintString("\r\nPlease enter:::::::");
	delay_ms(2000);
	com_get_received_data_use(com_buffer_use);
	for(i=0;i<=20;i++)
    38a2:	2f 5f       	subi	r18, 0xFF	; 255
    38a4:	3f 4f       	sbci	r19, 0xFF	; 255
    38a6:	25 31       	cpi	r18, 0x15	; 21
    38a8:	31 05       	cpc	r19, r1
    38aa:	91 f7       	brne	.-28     	; 0x3890 <routine+0x4a>
    38ac:	05 e0       	ldi	r16, 0x05	; 5
    38ae:	14 e1       	ldi	r17, 0x14	; 20
	{
	com_buffer_useful[i]=com_buffer_use[i]-48;
	}
    for(i=0;i<=15;i++)
		com_send_hex(com_buffer_useful[i]);
    38b0:	f8 01       	movw	r30, r16
    38b2:	81 91       	ld	r24, Z+
    38b4:	8f 01       	movw	r16, r30
    38b6:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_get_received_data_use(com_buffer_use);
	for(i=0;i<=20;i++)
	{
	com_buffer_useful[i]=com_buffer_use[i]-48;
	}
    for(i=0;i<=15;i++)
    38ba:	f4 e1       	ldi	r31, 0x14	; 20
    38bc:	05 31       	cpi	r16, 0x15	; 21
    38be:	1f 07       	cpc	r17, r31
    38c0:	b9 f7       	brne	.-18     	; 0x38b0 <routine+0x6a>
		com_send_hex(com_buffer_useful[i]);
	comPrintString("\r\n");
    38c2:	82 e7       	ldi	r24, 0x72	; 114
    38c4:	9c e0       	ldi	r25, 0x0C	; 12
    38c6:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    38ca:	0e e8       	ldi	r16, 0x8E	; 142
    38cc:	13 e1       	ldi	r17, 0x13	; 19
	for(i=0;i<=15;i++)
		com_send_hex(com_buffer_use[i]);
    38ce:	f8 01       	movw	r30, r16
    38d0:	81 91       	ld	r24, Z+
    38d2:	8f 01       	movw	r16, r30
    38d4:	0e 94 b9 00 	call	0x172	; 0x172 <com_send_hex>
	com_buffer_useful[i]=com_buffer_use[i]-48;
	}
    for(i=0;i<=15;i++)
		com_send_hex(com_buffer_useful[i]);
	comPrintString("\r\n");
	for(i=0;i<=15;i++)
    38d8:	f3 e1       	ldi	r31, 0x13	; 19
    38da:	0e 39       	cpi	r16, 0x9E	; 158
    38dc:	1f 07       	cpc	r17, r31
    38de:	b9 f7       	brne	.-18     	; 0x38ce <routine+0x88>
		com_send_hex(com_buffer_use[i]);
    if(com_buffer_useful[0]==0x09&&com_buffer_useful[1]==0x09)
    38e0:	80 91 05 14 	lds	r24, 0x1405
    38e4:	89 30       	cpi	r24, 0x09	; 9
    38e6:	f1 f4       	brne	.+60     	; 0x3924 <routine+0xde>
    38e8:	80 91 06 14 	lds	r24, 0x1406
    38ec:	89 30       	cpi	r24, 0x09	; 9
    38ee:	d1 f4       	brne	.+52     	; 0x3924 <routine+0xde>
	{
		comPrintString("Ready to Send ~~~~~~~");
    38f0:	85 e7       	ldi	r24, 0x75	; 117
    38f2:	9c e0       	ldi	r25, 0x0C	; 12
    38f4:	0e 94 ac 00 	call	0x158	; 0x158 <comPrintString>
    38f8:	e9 e0       	ldi	r30, 0x09	; 9
    38fa:	f4 e1       	ldi	r31, 0x14	; 20
    38fc:	de 01       	movw	r26, r28
    38fe:	11 96       	adiw	r26, 0x01	; 1
		for(i=0;i<=4;i++)
		{
			data[i]=com_buffer_useful[i+4];
    3900:	81 91       	ld	r24, Z+
    3902:	8d 93       	st	X+, r24
	for(i=0;i<=15;i++)
		com_send_hex(com_buffer_use[i]);
    if(com_buffer_useful[0]==0x09&&com_buffer_useful[1]==0x09)
	{
		comPrintString("Ready to Send ~~~~~~~");
		for(i=0;i<=4;i++)
    3904:	84 e1       	ldi	r24, 0x14	; 20
    3906:	ee 30       	cpi	r30, 0x0E	; 14
    3908:	f8 07       	cpc	r31, r24
    390a:	d1 f7       	brne	.-12     	; 0x3900 <routine+0xba>
		{
			data[i]=com_buffer_useful[i+4];
		}
		addSendData((com_buffer_useful[2]+256*com_buffer_useful[3]),data);
    390c:	90 91 08 14 	lds	r25, 0x1408
    3910:	80 e0       	ldi	r24, 0x00	; 0
    3912:	20 91 07 14 	lds	r18, 0x1407
    3916:	82 0f       	add	r24, r18
    3918:	91 1d       	adc	r25, r1
    391a:	be 01       	movw	r22, r28
    391c:	6f 5f       	subi	r22, 0xFF	; 255
    391e:	7f 4f       	sbci	r23, 0xFF	; 255
    3920:	0e 94 1a 0b 	call	0x1634	; 0x1634 <addSendData>
    }
	com_reset_receiver();
    3924:	0e 94 2d 01 	call	0x25a	; 0x25a <com_reset_receiver>
}
    3928:	0f 90       	pop	r0
    392a:	0f 90       	pop	r0
    392c:	0f 90       	pop	r0
    392e:	0f 90       	pop	r0
    3930:	0f 90       	pop	r0
    3932:	cf 91       	pop	r28
    3934:	df 91       	pop	r29
    3936:	1f 91       	pop	r17
    3938:	0f 91       	pop	r16
    393a:	08 95       	ret

0000393c <__udivmodqi4>:
    393c:	99 1b       	sub	r25, r25
    393e:	79 e0       	ldi	r23, 0x09	; 9
    3940:	04 c0       	rjmp	.+8      	; 0x394a <__udivmodqi4_ep>

00003942 <__udivmodqi4_loop>:
    3942:	99 1f       	adc	r25, r25
    3944:	96 17       	cp	r25, r22
    3946:	08 f0       	brcs	.+2      	; 0x394a <__udivmodqi4_ep>
    3948:	96 1b       	sub	r25, r22

0000394a <__udivmodqi4_ep>:
    394a:	88 1f       	adc	r24, r24
    394c:	7a 95       	dec	r23
    394e:	c9 f7       	brne	.-14     	; 0x3942 <__udivmodqi4_loop>
    3950:	80 95       	com	r24
    3952:	08 95       	ret

00003954 <_exit>:
    3954:	f8 94       	cli

00003956 <__stop_program>:
    3956:	ff cf       	rjmp	.-2      	; 0x3956 <__stop_program>
